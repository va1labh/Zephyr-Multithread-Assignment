
zephyr.elf:     file format elf32-i386


Disassembly of section .init:

08049000 <_init>:
 8049000:	f3 0f 1e fb          	endbr32 
 8049004:	53                   	push   %ebx
 8049005:	83 ec 08             	sub    $0x8,%esp
 8049008:	e8 e3 02 00 00       	call   80492f0 <__x86.get_pc_thunk.bx>
 804900d:	81 c3 37 7f 00 00    	add    $0x7f37,%ebx
 8049013:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
 8049019:	85 c0                	test   %eax,%eax
 804901b:	74 02                	je     804901f <_init+0x1f>
 804901d:	ff d0                	call   *%eax
 804901f:	83 c4 08             	add    $0x8,%esp
 8049022:	5b                   	pop    %ebx
 8049023:	c3                   	ret    

Disassembly of section .plt:

08049030 <sigemptyset@plt-0x10>:
 8049030:	ff 35 48 0f 05 08    	push   0x8050f48
 8049036:	ff 25 4c 0f 05 08    	jmp    *0x8050f4c
 804903c:	00 00                	add    %al,(%eax)
	...

08049040 <sigemptyset@plt>:
 8049040:	ff 25 50 0f 05 08    	jmp    *0x8050f50
 8049046:	68 00 00 00 00       	push   $0x0
 804904b:	e9 e0 ff ff ff       	jmp    8049030 <_init+0x30>

08049050 <pthread_exit@plt>:
 8049050:	ff 25 54 0f 05 08    	jmp    *0x8050f54
 8049056:	68 08 00 00 00       	push   $0x8
 804905b:	e9 d0 ff ff ff       	jmp    8049030 <_init+0x30>

08049060 <clock_gettime@plt>:
 8049060:	ff 25 58 0f 05 08    	jmp    *0x8050f58
 8049066:	68 10 00 00 00       	push   $0x10
 804906b:	e9 c0 ff ff ff       	jmp    8049030 <_init+0x30>

08049070 <__fprintf_chk@plt>:
 8049070:	ff 25 5c 0f 05 08    	jmp    *0x8050f5c
 8049076:	68 18 00 00 00       	push   $0x18
 804907b:	e9 b0 ff ff ff       	jmp    8049030 <_init+0x30>

08049080 <realloc@plt>:
 8049080:	ff 25 60 0f 05 08    	jmp    *0x8050f60
 8049086:	68 20 00 00 00       	push   $0x20
 804908b:	e9 a0 ff ff ff       	jmp    8049030 <_init+0x30>

08049090 <strtod@plt>:
 8049090:	ff 25 64 0f 05 08    	jmp    *0x8050f64
 8049096:	68 28 00 00 00       	push   $0x28
 804909b:	e9 90 ff ff ff       	jmp    8049030 <_init+0x30>

080490a0 <calloc@plt>:
 80490a0:	ff 25 68 0f 05 08    	jmp    *0x8050f68
 80490a6:	68 30 00 00 00       	push   $0x30
 80490ab:	e9 80 ff ff ff       	jmp    8049030 <_init+0x30>

080490b0 <strtoll@plt>:
 80490b0:	ff 25 6c 0f 05 08    	jmp    *0x8050f6c
 80490b6:	68 38 00 00 00       	push   $0x38
 80490bb:	e9 70 ff ff ff       	jmp    8049030 <_init+0x30>

080490c0 <strtol@plt>:
 80490c0:	ff 25 70 0f 05 08    	jmp    *0x8050f70
 80490c6:	68 40 00 00 00       	push   $0x40
 80490cb:	e9 60 ff ff ff       	jmp    8049030 <_init+0x30>

080490d0 <pthread_create@plt>:
 80490d0:	ff 25 74 0f 05 08    	jmp    *0x8050f74
 80490d6:	68 48 00 00 00       	push   $0x48
 80490db:	e9 50 ff ff ff       	jmp    8049030 <_init+0x30>

080490e0 <free@plt>:
 80490e0:	ff 25 78 0f 05 08    	jmp    *0x8050f78
 80490e6:	68 50 00 00 00       	push   $0x50
 80490eb:	e9 40 ff ff ff       	jmp    8049030 <_init+0x30>

080490f0 <strtoull@plt>:
 80490f0:	ff 25 7c 0f 05 08    	jmp    *0x8050f7c
 80490f6:	68 58 00 00 00       	push   $0x58
 80490fb:	e9 30 ff ff ff       	jmp    8049030 <_init+0x30>

08049100 <sigaction@plt>:
 8049100:	ff 25 80 0f 05 08    	jmp    *0x8050f80
 8049106:	68 60 00 00 00       	push   $0x60
 804910b:	e9 20 ff ff ff       	jmp    8049030 <_init+0x30>

08049110 <__vfprintf_chk@plt>:
 8049110:	ff 25 84 0f 05 08    	jmp    *0x8050f84
 8049116:	68 68 00 00 00       	push   $0x68
 804911b:	e9 10 ff ff ff       	jmp    8049030 <_init+0x30>

08049120 <__ctype_b_loc@plt>:
 8049120:	ff 25 88 0f 05 08    	jmp    *0x8050f88
 8049126:	68 70 00 00 00       	push   $0x70
 804912b:	e9 00 ff ff ff       	jmp    8049030 <_init+0x30>

08049130 <pthread_mutex_unlock@plt>:
 8049130:	ff 25 8c 0f 05 08    	jmp    *0x8050f8c
 8049136:	68 78 00 00 00       	push   $0x78
 804913b:	e9 f0 fe ff ff       	jmp    8049030 <_init+0x30>

08049140 <isatty@plt>:
 8049140:	ff 25 90 0f 05 08    	jmp    *0x8050f90
 8049146:	68 80 00 00 00       	push   $0x80
 804914b:	e9 e0 fe ff ff       	jmp    8049030 <_init+0x30>

08049150 <nanosleep@plt>:
 8049150:	ff 25 94 0f 05 08    	jmp    *0x8050f94
 8049156:	68 88 00 00 00       	push   $0x88
 804915b:	e9 d0 fe ff ff       	jmp    8049030 <_init+0x30>

08049160 <strtoul@plt>:
 8049160:	ff 25 98 0f 05 08    	jmp    *0x8050f98
 8049166:	68 90 00 00 00       	push   $0x90
 804916b:	e9 c0 fe ff ff       	jmp    8049030 <_init+0x30>

08049170 <strlen@plt>:
 8049170:	ff 25 9c 0f 05 08    	jmp    *0x8050f9c
 8049176:	68 98 00 00 00       	push   $0x98
 804917b:	e9 b0 fe ff ff       	jmp    8049030 <_init+0x30>

08049180 <pthread_detach@plt>:
 8049180:	ff 25 a0 0f 05 08    	jmp    *0x8050fa0
 8049186:	68 a0 00 00 00       	push   $0xa0
 804918b:	e9 a0 fe ff ff       	jmp    8049030 <_init+0x30>

08049190 <pthread_cancel@plt>:
 8049190:	ff 25 a4 0f 05 08    	jmp    *0x8050fa4
 8049196:	68 a8 00 00 00       	push   $0xa8
 804919b:	e9 90 fe ff ff       	jmp    8049030 <_init+0x30>

080491a0 <strcasecmp@plt>:
 80491a0:	ff 25 a8 0f 05 08    	jmp    *0x8050fa8
 80491a6:	68 b0 00 00 00       	push   $0xb0
 80491ab:	e9 80 fe ff ff       	jmp    8049030 <_init+0x30>

080491b0 <setvbuf@plt>:
 80491b0:	ff 25 ac 0f 05 08    	jmp    *0x8050fac
 80491b6:	68 b8 00 00 00       	push   $0xb8
 80491bb:	e9 70 fe ff ff       	jmp    8049030 <_init+0x30>

080491c0 <pthread_mutex_lock@plt>:
 80491c0:	ff 25 b0 0f 05 08    	jmp    *0x8050fb0
 80491c6:	68 c0 00 00 00       	push   $0xc0
 80491cb:	e9 60 fe ff ff       	jmp    8049030 <_init+0x30>

080491d0 <__stack_chk_fail@plt>:
 80491d0:	ff 25 b4 0f 05 08    	jmp    *0x8050fb4
 80491d6:	68 c8 00 00 00       	push   $0xc8
 80491db:	e9 50 fe ff ff       	jmp    8049030 <_init+0x30>

080491e0 <strnlen@plt>:
 80491e0:	ff 25 b8 0f 05 08    	jmp    *0x8050fb8
 80491e6:	68 d0 00 00 00       	push   $0xd0
 80491eb:	e9 40 fe ff ff       	jmp    8049030 <_init+0x30>

080491f0 <sleep@plt>:
 80491f0:	ff 25 bc 0f 05 08    	jmp    *0x8050fbc
 80491f6:	68 d8 00 00 00       	push   $0xd8
 80491fb:	e9 30 fe ff ff       	jmp    8049030 <_init+0x30>

08049200 <pthread_cond_wait@plt>:
 8049200:	ff 25 c0 0f 05 08    	jmp    *0x8050fc0
 8049206:	68 e0 00 00 00       	push   $0xe0
 804920b:	e9 20 fe ff ff       	jmp    8049030 <_init+0x30>

08049210 <__snprintf_chk@plt>:
 8049210:	ff 25 c4 0f 05 08    	jmp    *0x8050fc4
 8049216:	68 e8 00 00 00       	push   $0xe8
 804921b:	e9 10 fe ff ff       	jmp    8049030 <_init+0x30>

08049220 <__pthread_unwind_next@plt>:
 8049220:	ff 25 c8 0f 05 08    	jmp    *0x8050fc8
 8049226:	68 f0 00 00 00       	push   $0xf0
 804922b:	e9 00 fe ff ff       	jmp    8049030 <_init+0x30>

08049230 <snprintf@plt>:
 8049230:	ff 25 cc 0f 05 08    	jmp    *0x8050fcc
 8049236:	68 f8 00 00 00       	push   $0xf8
 804923b:	e9 f0 fd ff ff       	jmp    8049030 <_init+0x30>

08049240 <__pthread_register_cancel@plt>:
 8049240:	ff 25 d0 0f 05 08    	jmp    *0x8050fd0
 8049246:	68 00 01 00 00       	push   $0x100
 804924b:	e9 e0 fd ff ff       	jmp    8049030 <_init+0x30>

08049250 <__libc_start_main@plt>:
 8049250:	ff 25 d4 0f 05 08    	jmp    *0x8050fd4
 8049256:	68 08 01 00 00       	push   $0x108
 804925b:	e9 d0 fd ff ff       	jmp    8049030 <_init+0x30>

08049260 <pthread_cond_broadcast@plt>:
 8049260:	ff 25 d8 0f 05 08    	jmp    *0x8050fd8
 8049266:	68 10 01 00 00       	push   $0x110
 804926b:	e9 c0 fd ff ff       	jmp    8049030 <_init+0x30>

08049270 <strcmp@plt>:
 8049270:	ff 25 dc 0f 05 08    	jmp    *0x8050fdc
 8049276:	68 18 01 00 00       	push   $0x118
 804927b:	e9 b0 fd ff ff       	jmp    8049030 <_init+0x30>

08049280 <__sigsetjmp@plt>:
 8049280:	ff 25 e0 0f 05 08    	jmp    *0x8050fe0
 8049286:	68 20 01 00 00       	push   $0x120
 804928b:	e9 a0 fd ff ff       	jmp    8049030 <_init+0x30>

08049290 <exit@plt>:
 8049290:	ff 25 e4 0f 05 08    	jmp    *0x8050fe4
 8049296:	68 28 01 00 00       	push   $0x128
 804929b:	e9 90 fd ff ff       	jmp    8049030 <_init+0x30>

080492a0 <pthread_self@plt>:
 80492a0:	ff 25 e8 0f 05 08    	jmp    *0x8050fe8
 80492a6:	68 30 01 00 00       	push   $0x130
 80492ab:	e9 80 fd ff ff       	jmp    8049030 <_init+0x30>

Disassembly of section .plt.got:

080492b0 <__cxa_finalize@plt>:
 80492b0:	ff 25 f8 0f 05 08    	jmp    *0x8050ff8
 80492b6:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

080492c0 <_start>:
 80492c0:	f3 0f 1e fb          	endbr32 
 80492c4:	31 ed                	xor    %ebp,%ebp
 80492c6:	5e                   	pop    %esi
 80492c7:	89 e1                	mov    %esp,%ecx
 80492c9:	83 e4 f0             	and    $0xfffffff0,%esp
 80492cc:	50                   	push   %eax
 80492cd:	54                   	push   %esp
 80492ce:	52                   	push   %edx
 80492cf:	e8 18 00 00 00       	call   80492ec <_start+0x2c>
 80492d4:	81 c3 70 7c 00 00    	add    $0x7c70,%ebx
 80492da:	6a 00                	push   $0x0
 80492dc:	6a 00                	push   $0x0
 80492de:	51                   	push   %ecx
 80492df:	56                   	push   %esi
 80492e0:	ff b3 b8 00 00 00    	push   0xb8(%ebx)
 80492e6:	e8 65 ff ff ff       	call   8049250 <__libc_start_main@plt>
 80492eb:	f4                   	hlt    
 80492ec:	8b 1c 24             	mov    (%esp),%ebx
 80492ef:	c3                   	ret    

080492f0 <__x86.get_pc_thunk.bx>:
 80492f0:	8b 1c 24             	mov    (%esp),%ebx
 80492f3:	c3                   	ret    
 80492f4:	66 90                	xchg   %ax,%ax
 80492f6:	66 90                	xchg   %ax,%ax
 80492f8:	66 90                	xchg   %ax,%ax
 80492fa:	66 90                	xchg   %ax,%ax
 80492fc:	66 90                	xchg   %ax,%ax
 80492fe:	66 90                	xchg   %ax,%ax

08049300 <deregister_tm_clones>:
 8049300:	e8 f2 03 00 00       	call   80496f7 <__x86.get_pc_thunk.dx>
 8049305:	81 c2 3f 7c 00 00    	add    $0x7c3f,%edx
 804930b:	8d 8a 98 02 00 00    	lea    0x298(%edx),%ecx
 8049311:	8d 82 98 02 00 00    	lea    0x298(%edx),%eax
 8049317:	39 c8                	cmp    %ecx,%eax
 8049319:	74 1d                	je     8049338 <deregister_tm_clones+0x38>
 804931b:	8b 82 ac 00 00 00    	mov    0xac(%edx),%eax
 8049321:	85 c0                	test   %eax,%eax
 8049323:	74 13                	je     8049338 <deregister_tm_clones+0x38>
 8049325:	55                   	push   %ebp
 8049326:	89 e5                	mov    %esp,%ebp
 8049328:	83 ec 14             	sub    $0x14,%esp
 804932b:	51                   	push   %ecx
 804932c:	ff d0                	call   *%eax
 804932e:	83 c4 10             	add    $0x10,%esp
 8049331:	c9                   	leave  
 8049332:	c3                   	ret    
 8049333:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049337:	90                   	nop
 8049338:	c3                   	ret    
 8049339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049340 <register_tm_clones>:
 8049340:	e8 b2 03 00 00       	call   80496f7 <__x86.get_pc_thunk.dx>
 8049345:	81 c2 ff 7b 00 00    	add    $0x7bff,%edx
 804934b:	55                   	push   %ebp
 804934c:	89 e5                	mov    %esp,%ebp
 804934e:	53                   	push   %ebx
 804934f:	8d 8a 98 02 00 00    	lea    0x298(%edx),%ecx
 8049355:	8d 82 98 02 00 00    	lea    0x298(%edx),%eax
 804935b:	83 ec 04             	sub    $0x4,%esp
 804935e:	29 c8                	sub    %ecx,%eax
 8049360:	89 c3                	mov    %eax,%ebx
 8049362:	c1 e8 1f             	shr    $0x1f,%eax
 8049365:	c1 fb 02             	sar    $0x2,%ebx
 8049368:	01 d8                	add    %ebx,%eax
 804936a:	d1 f8                	sar    %eax
 804936c:	74 14                	je     8049382 <register_tm_clones+0x42>
 804936e:	8b 92 b0 00 00 00    	mov    0xb0(%edx),%edx
 8049374:	85 d2                	test   %edx,%edx
 8049376:	74 0a                	je     8049382 <register_tm_clones+0x42>
 8049378:	83 ec 08             	sub    $0x8,%esp
 804937b:	50                   	push   %eax
 804937c:	51                   	push   %ecx
 804937d:	ff d2                	call   *%edx
 804937f:	83 c4 10             	add    $0x10,%esp
 8049382:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8049385:	c9                   	leave  
 8049386:	c3                   	ret    
 8049387:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804938e:	66 90                	xchg   %ax,%ax

08049390 <__do_global_dtors_aux>:
 8049390:	f3 0f 1e fb          	endbr32 
 8049394:	55                   	push   %ebp
 8049395:	89 e5                	mov    %esp,%ebp
 8049397:	53                   	push   %ebx
 8049398:	e8 53 ff ff ff       	call   80492f0 <__x86.get_pc_thunk.bx>
 804939d:	81 c3 a7 7b 00 00    	add    $0x7ba7,%ebx
 80493a3:	83 ec 04             	sub    $0x4,%esp
 80493a6:	80 bb 2c 0a 00 00 00 	cmpb   $0x0,0xa2c(%ebx)
 80493ad:	75 27                	jne    80493d6 <__do_global_dtors_aux+0x46>
 80493af:	8b 83 b4 00 00 00    	mov    0xb4(%ebx),%eax
 80493b5:	85 c0                	test   %eax,%eax
 80493b7:	74 11                	je     80493ca <__do_global_dtors_aux+0x3a>
 80493b9:	83 ec 0c             	sub    $0xc,%esp
 80493bc:	ff b3 6c 02 00 00    	push   0x26c(%ebx)
 80493c2:	e8 e9 fe ff ff       	call   80492b0 <__cxa_finalize@plt>
 80493c7:	83 c4 10             	add    $0x10,%esp
 80493ca:	e8 31 ff ff ff       	call   8049300 <deregister_tm_clones>
 80493cf:	c6 83 2c 0a 00 00 01 	movb   $0x1,0xa2c(%ebx)
 80493d6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 80493d9:	c9                   	leave  
 80493da:	c3                   	ret    
 80493db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80493df:	90                   	nop

080493e0 <frame_dummy>:
 80493e0:	f3 0f 1e fb          	endbr32 
 80493e4:	e9 57 ff ff ff       	jmp    8049340 <register_tm_clones>
 80493e9:	66 90                	xchg   %ax,%ax
 80493eb:	66 90                	xchg   %ax,%ax
 80493ed:	66 90                	xchg   %ax,%ax
 80493ef:	90                   	nop

080493f0 <__udivdi3>:
 80493f0:	f3 0f 1e fb          	endbr32 
 80493f4:	55                   	push   %ebp
 80493f5:	57                   	push   %edi
 80493f6:	56                   	push   %esi
 80493f7:	53                   	push   %ebx
 80493f8:	83 ec 1c             	sub    $0x1c,%esp
 80493fb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 80493ff:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 8049403:	8b 74 24 34          	mov    0x34(%esp),%esi
 8049407:	8b 5c 24 38          	mov    0x38(%esp),%ebx
 804940b:	85 c0                	test   %eax,%eax
 804940d:	75 19                	jne    8049428 <__udivdi3+0x38>
 804940f:	39 f3                	cmp    %esi,%ebx
 8049411:	76 4d                	jbe    8049460 <__udivdi3+0x70>
 8049413:	31 ff                	xor    %edi,%edi
 8049415:	89 e8                	mov    %ebp,%eax
 8049417:	89 f2                	mov    %esi,%edx
 8049419:	f7 f3                	div    %ebx
 804941b:	89 fa                	mov    %edi,%edx
 804941d:	83 c4 1c             	add    $0x1c,%esp
 8049420:	5b                   	pop    %ebx
 8049421:	5e                   	pop    %esi
 8049422:	5f                   	pop    %edi
 8049423:	5d                   	pop    %ebp
 8049424:	c3                   	ret    
 8049425:	8d 76 00             	lea    0x0(%esi),%esi
 8049428:	39 f0                	cmp    %esi,%eax
 804942a:	76 14                	jbe    8049440 <__udivdi3+0x50>
 804942c:	31 ff                	xor    %edi,%edi
 804942e:	31 c0                	xor    %eax,%eax
 8049430:	89 fa                	mov    %edi,%edx
 8049432:	83 c4 1c             	add    $0x1c,%esp
 8049435:	5b                   	pop    %ebx
 8049436:	5e                   	pop    %esi
 8049437:	5f                   	pop    %edi
 8049438:	5d                   	pop    %ebp
 8049439:	c3                   	ret    
 804943a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049440:	0f bd f8             	bsr    %eax,%edi
 8049443:	83 f7 1f             	xor    $0x1f,%edi
 8049446:	75 48                	jne    8049490 <__udivdi3+0xa0>
 8049448:	39 f0                	cmp    %esi,%eax
 804944a:	72 06                	jb     8049452 <__udivdi3+0x62>
 804944c:	31 c0                	xor    %eax,%eax
 804944e:	39 eb                	cmp    %ebp,%ebx
 8049450:	77 de                	ja     8049430 <__udivdi3+0x40>
 8049452:	b8 01 00 00 00       	mov    $0x1,%eax
 8049457:	eb d7                	jmp    8049430 <__udivdi3+0x40>
 8049459:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049460:	89 d9                	mov    %ebx,%ecx
 8049462:	85 db                	test   %ebx,%ebx
 8049464:	75 0b                	jne    8049471 <__udivdi3+0x81>
 8049466:	b8 01 00 00 00       	mov    $0x1,%eax
 804946b:	31 d2                	xor    %edx,%edx
 804946d:	f7 f3                	div    %ebx
 804946f:	89 c1                	mov    %eax,%ecx
 8049471:	31 d2                	xor    %edx,%edx
 8049473:	89 f0                	mov    %esi,%eax
 8049475:	f7 f1                	div    %ecx
 8049477:	89 c6                	mov    %eax,%esi
 8049479:	89 e8                	mov    %ebp,%eax
 804947b:	89 f7                	mov    %esi,%edi
 804947d:	f7 f1                	div    %ecx
 804947f:	89 fa                	mov    %edi,%edx
 8049481:	83 c4 1c             	add    $0x1c,%esp
 8049484:	5b                   	pop    %ebx
 8049485:	5e                   	pop    %esi
 8049486:	5f                   	pop    %edi
 8049487:	5d                   	pop    %ebp
 8049488:	c3                   	ret    
 8049489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049490:	89 f9                	mov    %edi,%ecx
 8049492:	ba 20 00 00 00       	mov    $0x20,%edx
 8049497:	29 fa                	sub    %edi,%edx
 8049499:	d3 e0                	shl    %cl,%eax
 804949b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804949f:	89 d1                	mov    %edx,%ecx
 80494a1:	89 d8                	mov    %ebx,%eax
 80494a3:	d3 e8                	shr    %cl,%eax
 80494a5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 80494a9:	09 c1                	or     %eax,%ecx
 80494ab:	89 f0                	mov    %esi,%eax
 80494ad:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 80494b1:	89 f9                	mov    %edi,%ecx
 80494b3:	d3 e3                	shl    %cl,%ebx
 80494b5:	89 d1                	mov    %edx,%ecx
 80494b7:	d3 e8                	shr    %cl,%eax
 80494b9:	89 f9                	mov    %edi,%ecx
 80494bb:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 80494bf:	89 eb                	mov    %ebp,%ebx
 80494c1:	d3 e6                	shl    %cl,%esi
 80494c3:	89 d1                	mov    %edx,%ecx
 80494c5:	d3 eb                	shr    %cl,%ebx
 80494c7:	09 f3                	or     %esi,%ebx
 80494c9:	89 c6                	mov    %eax,%esi
 80494cb:	89 f2                	mov    %esi,%edx
 80494cd:	89 d8                	mov    %ebx,%eax
 80494cf:	f7 74 24 08          	divl   0x8(%esp)
 80494d3:	89 d6                	mov    %edx,%esi
 80494d5:	89 c3                	mov    %eax,%ebx
 80494d7:	f7 64 24 0c          	mull   0xc(%esp)
 80494db:	39 d6                	cmp    %edx,%esi
 80494dd:	72 19                	jb     80494f8 <__udivdi3+0x108>
 80494df:	89 f9                	mov    %edi,%ecx
 80494e1:	d3 e5                	shl    %cl,%ebp
 80494e3:	39 c5                	cmp    %eax,%ebp
 80494e5:	73 04                	jae    80494eb <__udivdi3+0xfb>
 80494e7:	39 d6                	cmp    %edx,%esi
 80494e9:	74 0d                	je     80494f8 <__udivdi3+0x108>
 80494eb:	89 d8                	mov    %ebx,%eax
 80494ed:	31 ff                	xor    %edi,%edi
 80494ef:	e9 3c ff ff ff       	jmp    8049430 <__udivdi3+0x40>
 80494f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80494f8:	8d 43 ff             	lea    -0x1(%ebx),%eax
 80494fb:	31 ff                	xor    %edi,%edi
 80494fd:	e9 2e ff ff ff       	jmp    8049430 <__udivdi3+0x40>
 8049502:	66 90                	xchg   %ax,%ax
 8049504:	66 90                	xchg   %ax,%ax
 8049506:	66 90                	xchg   %ax,%ax
 8049508:	66 90                	xchg   %ax,%ax
 804950a:	66 90                	xchg   %ax,%ax
 804950c:	66 90                	xchg   %ax,%ax
 804950e:	66 90                	xchg   %ax,%ax

08049510 <__udivmoddi4>:
 8049510:	f3 0f 1e fb          	endbr32 
 8049514:	55                   	push   %ebp
 8049515:	57                   	push   %edi
 8049516:	56                   	push   %esi
 8049517:	53                   	push   %ebx
 8049518:	83 ec 2c             	sub    $0x2c,%esp
 804951b:	8b 44 24 40          	mov    0x40(%esp),%eax
 804951f:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 8049523:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
 8049527:	8b 6c 24 48          	mov    0x48(%esp),%ebp
 804952b:	89 44 24 10          	mov    %eax,0x10(%esp)
 804952f:	89 da                	mov    %ebx,%edx
 8049531:	85 ff                	test   %edi,%edi
 8049533:	75 3b                	jne    8049570 <__udivmoddi4+0x60>
 8049535:	39 dd                	cmp    %ebx,%ebp
 8049537:	0f 86 a3 00 00 00    	jbe    80495e0 <__udivmoddi4+0xd0>
 804953d:	31 f6                	xor    %esi,%esi
 804953f:	f7 f5                	div    %ebp
 8049541:	8b 7c 24 50          	mov    0x50(%esp),%edi
 8049545:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049549:	85 ff                	test   %edi,%edi
 804954b:	74 0d                	je     804955a <__udivmoddi4+0x4a>
 804954d:	8b 44 24 50          	mov    0x50(%esp),%eax
 8049551:	89 10                	mov    %edx,(%eax)
 8049553:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 804955a:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804955e:	89 f2                	mov    %esi,%edx
 8049560:	83 c4 2c             	add    $0x2c,%esp
 8049563:	5b                   	pop    %ebx
 8049564:	5e                   	pop    %esi
 8049565:	5f                   	pop    %edi
 8049566:	5d                   	pop    %ebp
 8049567:	c3                   	ret    
 8049568:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804956f:	90                   	nop
 8049570:	39 df                	cmp    %ebx,%edi
 8049572:	76 34                	jbe    80495a8 <__udivmoddi4+0x98>
 8049574:	8b 74 24 50          	mov    0x50(%esp),%esi
 8049578:	85 f6                	test   %esi,%esi
 804957a:	0f 84 40 01 00 00    	je     80496c0 <__udivmoddi4+0x1b0>
 8049580:	8b 44 24 50          	mov    0x50(%esp),%eax
 8049584:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049588:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 804958f:	00 
 8049590:	89 30                	mov    %esi,(%eax)
 8049592:	31 f6                	xor    %esi,%esi
 8049594:	89 58 04             	mov    %ebx,0x4(%eax)
 8049597:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804959b:	89 f2                	mov    %esi,%edx
 804959d:	83 c4 2c             	add    $0x2c,%esp
 80495a0:	5b                   	pop    %ebx
 80495a1:	5e                   	pop    %esi
 80495a2:	5f                   	pop    %edi
 80495a3:	5d                   	pop    %ebp
 80495a4:	c3                   	ret    
 80495a5:	8d 76 00             	lea    0x0(%esi),%esi
 80495a8:	0f bd f7             	bsr    %edi,%esi
 80495ab:	83 f6 1f             	xor    $0x1f,%esi
 80495ae:	75 60                	jne    8049610 <__udivmoddi4+0x100>
 80495b0:	39 df                	cmp    %ebx,%edi
 80495b2:	0f 82 18 01 00 00    	jb     80496d0 <__udivmoddi4+0x1c0>
 80495b8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 80495bf:	00 
 80495c0:	3b 6c 24 10          	cmp    0x10(%esp),%ebp
 80495c4:	0f 86 06 01 00 00    	jbe    80496d0 <__udivmoddi4+0x1c0>
 80495ca:	8b 4c 24 50          	mov    0x50(%esp),%ecx
 80495ce:	85 c9                	test   %ecx,%ecx
 80495d0:	74 88                	je     804955a <__udivmoddi4+0x4a>
 80495d2:	8b 7c 24 50          	mov    0x50(%esp),%edi
 80495d6:	89 07                	mov    %eax,(%edi)
 80495d8:	89 57 04             	mov    %edx,0x4(%edi)
 80495db:	e9 7a ff ff ff       	jmp    804955a <__udivmoddi4+0x4a>
 80495e0:	89 e9                	mov    %ebp,%ecx
 80495e2:	85 ed                	test   %ebp,%ebp
 80495e4:	75 0b                	jne    80495f1 <__udivmoddi4+0xe1>
 80495e6:	b8 01 00 00 00       	mov    $0x1,%eax
 80495eb:	31 d2                	xor    %edx,%edx
 80495ed:	f7 f5                	div    %ebp
 80495ef:	89 c1                	mov    %eax,%ecx
 80495f1:	89 d8                	mov    %ebx,%eax
 80495f3:	31 d2                	xor    %edx,%edx
 80495f5:	f7 f1                	div    %ecx
 80495f7:	89 c3                	mov    %eax,%ebx
 80495f9:	8b 44 24 10          	mov    0x10(%esp),%eax
 80495fd:	89 de                	mov    %ebx,%esi
 80495ff:	f7 f1                	div    %ecx
 8049601:	e9 3b ff ff ff       	jmp    8049541 <__udivmoddi4+0x31>
 8049606:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804960d:	8d 76 00             	lea    0x0(%esi),%esi
 8049610:	ba 20 00 00 00       	mov    $0x20,%edx
 8049615:	89 f1                	mov    %esi,%ecx
 8049617:	89 e8                	mov    %ebp,%eax
 8049619:	29 f2                	sub    %esi,%edx
 804961b:	d3 e7                	shl    %cl,%edi
 804961d:	89 d1                	mov    %edx,%ecx
 804961f:	89 54 24 1c          	mov    %edx,0x1c(%esp)
 8049623:	d3 e8                	shr    %cl,%eax
 8049625:	89 f1                	mov    %esi,%ecx
 8049627:	d3 e5                	shl    %cl,%ebp
 8049629:	89 d1                	mov    %edx,%ecx
 804962b:	09 c7                	or     %eax,%edi
 804962d:	89 d0                	mov    %edx,%eax
 804962f:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 8049633:	89 dd                	mov    %ebx,%ebp
 8049635:	d3 ed                	shr    %cl,%ebp
 8049637:	89 f1                	mov    %esi,%ecx
 8049639:	89 ea                	mov    %ebp,%edx
 804963b:	8b 6c 24 10          	mov    0x10(%esp),%ebp
 804963f:	d3 e3                	shl    %cl,%ebx
 8049641:	89 c1                	mov    %eax,%ecx
 8049643:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049647:	d3 ed                	shr    %cl,%ebp
 8049649:	89 f1                	mov    %esi,%ecx
 804964b:	09 dd                	or     %ebx,%ebp
 804964d:	d3 e0                	shl    %cl,%eax
 804964f:	89 44 24 18          	mov    %eax,0x18(%esp)
 8049653:	89 e8                	mov    %ebp,%eax
 8049655:	f7 f7                	div    %edi
 8049657:	89 d3                	mov    %edx,%ebx
 8049659:	89 c1                	mov    %eax,%ecx
 804965b:	89 c5                	mov    %eax,%ebp
 804965d:	f7 64 24 0c          	mull   0xc(%esp)
 8049661:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049665:	89 54 24 14          	mov    %edx,0x14(%esp)
 8049669:	39 d3                	cmp    %edx,%ebx
 804966b:	72 08                	jb     8049675 <__udivmoddi4+0x165>
 804966d:	75 17                	jne    8049686 <__udivmoddi4+0x176>
 804966f:	39 44 24 18          	cmp    %eax,0x18(%esp)
 8049673:	73 11                	jae    8049686 <__udivmoddi4+0x176>
 8049675:	2b 44 24 0c          	sub    0xc(%esp),%eax
 8049679:	19 fa                	sbb    %edi,%edx
 804967b:	89 54 24 14          	mov    %edx,0x14(%esp)
 804967f:	8d 69 ff             	lea    -0x1(%ecx),%ebp
 8049682:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049686:	8b 44 24 50          	mov    0x50(%esp),%eax
 804968a:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 804968e:	85 c0                	test   %eax,%eax
 8049690:	74 5e                	je     80496f0 <__udivmoddi4+0x1e0>
 8049692:	0f b6 4c 24 1c       	movzbl 0x1c(%esp),%ecx
 8049697:	8b 44 24 18          	mov    0x18(%esp),%eax
 804969b:	2b 44 24 10          	sub    0x10(%esp),%eax
 804969f:	1b 5c 24 14          	sbb    0x14(%esp),%ebx
 80496a3:	89 da                	mov    %ebx,%edx
 80496a5:	d3 e2                	shl    %cl,%edx
 80496a7:	89 f1                	mov    %esi,%ecx
 80496a9:	31 f6                	xor    %esi,%esi
 80496ab:	d3 e8                	shr    %cl,%eax
 80496ad:	d3 eb                	shr    %cl,%ebx
 80496af:	09 c2                	or     %eax,%edx
 80496b1:	8b 44 24 50          	mov    0x50(%esp),%eax
 80496b5:	89 10                	mov    %edx,(%eax)
 80496b7:	89 58 04             	mov    %ebx,0x4(%eax)
 80496ba:	e9 9b fe ff ff       	jmp    804955a <__udivmoddi4+0x4a>
 80496bf:	90                   	nop
 80496c0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 80496c7:	00 
 80496c8:	31 f6                	xor    %esi,%esi
 80496ca:	e9 8b fe ff ff       	jmp    804955a <__udivmoddi4+0x4a>
 80496cf:	90                   	nop
 80496d0:	8b 44 24 10          	mov    0x10(%esp),%eax
 80496d4:	89 da                	mov    %ebx,%edx
 80496d6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 80496dd:	00 
 80496de:	29 e8                	sub    %ebp,%eax
 80496e0:	19 fa                	sbb    %edi,%edx
 80496e2:	e9 e3 fe ff ff       	jmp    80495ca <__udivmoddi4+0xba>
 80496e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80496ee:	66 90                	xchg   %ax,%ax
 80496f0:	31 f6                	xor    %esi,%esi
 80496f2:	e9 63 fe ff ff       	jmp    804955a <__udivmoddi4+0x4a>

080496f7 <__x86.get_pc_thunk.dx>:
 80496f7:	8b 14 24             	mov    (%esp),%edx
 80496fa:	c3                   	ret    

080496fb <_OffsetAbsSyms>:
#include <zephyr/kernel.h>
#include <kernel_arch_data.h>
#include <gen_offset.h>
#include <kernel_offsets.h>

GEN_ABS_SYM_END
 80496fb:	c3                   	ret    

080496fc <thread2>:
        k_msgq_put(&msgq, &interval, K_FOREVER); //send message to thread2 
    }
}

void thread2(void)
{
 80496fc:	55                   	push   %ebp
 80496fd:	89 e5                	mov    %esp,%ebp
 80496ff:	83 ec 18             	sub    $0x18,%esp
 8049702:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049708:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804970b:	31 c0                	xor    %eax,%eax
    char buffer[10];
    k_msgq_init(&msgq, buffer, sizeof(buffer), 1);
 804970d:	8d 45 ea             	lea    -0x16(%ebp),%eax
 8049710:	6a 01                	push   $0x1
 8049712:	6a 0a                	push   $0xa
 8049714:	50                   	push   %eax
 8049715:	68 60 13 05 08       	push   $0x8051360
 804971a:	e8 61 30 00 00       	call   804c780 <k_msgq_init>
 804971f:	83 c4 10             	add    $0x10,%esp
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm2 = { .val = timeout };
		return (int) arch_syscall_invoke4(parm0.x, parm1.x, parm2.split.lo, parm2.split.hi, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
 8049722:	6a ff                	push   $0xffffffff
 8049724:	6a ff                	push   $0xffffffff
 8049726:	68 b4 11 05 08       	push   $0x80511b4
 804972b:	68 60 13 05 08       	push   $0x8051360
 8049730:	e8 53 31 00 00       	call   804c888 <z_impl_k_msgq_get>
    while (1) {
        k_msgq_get(&msgq, &interval, K_FOREVER); //read incoming message drom thread1
	//k_msleep(1000); // to wait 1s after thread1
        printk("thread 2\n");
 8049735:	c7 04 24 2c e1 04 08 	movl   $0x804e12c,(%esp)
 804973c:	e8 91 00 00 00       	call   80497d2 <printk>
 8049741:	eb dc                	jmp    804971f <thread2+0x23>

08049743 <thread1>:
{
 8049743:	55                   	push   %ebp
 8049744:	89 e5                	mov    %esp,%ebp
 8049746:	53                   	push   %ebx
    int count = 0;
 8049747:	31 db                	xor    %ebx,%ebx
{
 8049749:	52                   	push   %edx
	return z_impl_k_sleep(timeout);
 804974a:	50                   	push   %eax
        if (++count >= 10) //condition to check the overflow
 804974b:	43                   	inc    %ebx
 804974c:	50                   	push   %eax
 804974d:	6a 00                	push   $0x0
 804974f:	6a 64                	push   $0x64
 8049751:	e8 44 39 00 00       	call   804d09a <z_impl_k_sleep>
        printk("thread 1\n");
 8049756:	c7 04 24 36 e1 04 08 	movl   $0x804e136,(%esp)
 804975d:	e8 70 00 00 00       	call   80497d2 <printk>
 8049762:	83 c4 10             	add    $0x10,%esp
        if (++count >= 10) //condition to check the overflow
 8049765:	83 fb 0a             	cmp    $0xa,%ebx
 8049768:	74 0c                	je     8049776 <thread1+0x33>
            interval += 1000; // Increment interval by 1 second
 804976a:	a1 b4 11 05 08       	mov    0x80511b4,%eax
 804976f:	05 e8 03 00 00       	add    $0x3e8,%eax
 8049774:	eb 0a                	jmp    8049780 <thread1+0x3d>
            interval = 1000; // Reset interval to 1 second
 8049776:	b8 e8 03 00 00       	mov    $0x3e8,%eax
            count = 1;
 804977b:	bb 01 00 00 00       	mov    $0x1,%ebx
 8049780:	a3 b4 11 05 08       	mov    %eax,0x80511b4
	return z_impl_k_msgq_put(msgq, data, timeout);
 8049785:	6a ff                	push   $0xffffffff
 8049787:	6a ff                	push   $0xffffffff
 8049789:	68 b4 11 05 08       	push   $0x80511b4
 804978e:	68 60 13 05 08       	push   $0x8051360
 8049793:	e8 22 30 00 00       	call   804c7ba <z_impl_k_msgq_put>
 8049798:	83 c4 10             	add    $0x10,%esp
    {
 804979b:	eb ad                	jmp    804974a <thread1+0x7>

0804979d <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
 804979d:	31 c0                	xor    %eax,%eax
 804979f:	c3                   	ret    

080497a0 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
 80497a0:	ff 25 b8 11 05 08    	jmp    *0x80511b8

080497a6 <__printk_hook_install>:
{
 80497a6:	55                   	push   %ebp
 80497a7:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
 80497a9:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80497ac:	5d                   	pop    %ebp
	_char_out = fn;
 80497ad:	a3 b8 11 05 08       	mov    %eax,0x80511b8
}
 80497b2:	c3                   	ret    

080497b3 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
 80497b3:	55                   	push   %ebp
 80497b4:	89 e5                	mov    %esp,%ebp
 80497b6:	83 ec 14             	sub    $0x14,%esp
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
 80497b9:	6a 00                	push   $0x0
 80497bb:	ff 75 0c             	push   0xc(%ebp)
 80497be:	ff 75 08             	push   0x8(%ebp)
 80497c1:	6a 00                	push   $0x0
 80497c3:	68 a0 97 04 08       	push   $0x80497a0
 80497c8:	e8 0e 03 00 00       	call   8049adb <z_cbvprintf_impl>
 80497cd:	83 c4 20             	add    $0x20,%esp

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
 80497d0:	c9                   	leave  
 80497d1:	c3                   	ret    

080497d2 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
 80497d2:	55                   	push   %ebp
 80497d3:	89 e5                	mov    %esp,%ebp
 80497d5:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 80497d8:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 80497db:	50                   	push   %eax
 80497dc:	ff 75 08             	push   0x8(%ebp)
 80497df:	e8 cf ff ff ff       	call   80497b3 <vprintk>
 80497e4:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 80497e7:	c9                   	leave  
 80497e8:	c3                   	ret    

080497e9 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 80497e9:	55                   	push   %ebp
 80497ea:	89 e5                	mov    %esp,%ebp
 80497ec:	83 ec 0c             	sub    $0xc,%esp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
 80497ef:	ff 75 14             	push   0x14(%ebp)
 80497f2:	ff 75 10             	push   0x10(%ebp)
 80497f5:	ff 75 0c             	push   0xc(%ebp)
 80497f8:	ff 55 08             	call   *0x8(%ebp)
 80497fb:	83 c4 10             	add    $0x10,%esp
	return z_impl_z_current_get();
 80497fe:	e8 cd 38 00 00       	call   804d0d0 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
 8049803:	83 ec 0c             	sub    $0xc,%esp
 8049806:	50                   	push   %eax
 8049807:	e8 f6 0e 00 00       	call   804a702 <z_impl_k_thread_abort>
 804980c:	83 c4 0c             	add    $0xc,%esp
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804980f:	6a 2d                	push   $0x2d
 8049811:	68 67 e1 04 08       	push   $0x804e167
 8049816:	68 90 e1 04 08       	push   $0x804e190
 804981b:	e8 c4 20 00 00       	call   804b8e4 <posix_print_error_and_exit>
 8049820:	83 c4 10             	add    $0x10,%esp

08049823 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
 8049823:	0f b7 44 d0 02       	movzwl 0x2(%eax,%edx,8),%eax
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 8049828:	d1 e8                	shr    %eax
}
 804982a:	c3                   	ret    

0804982b <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
 804982b:	55                   	push   %ebp
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
 804982c:	8d 04 d0             	lea    (%eax,%edx,8),%eax
{
 804982f:	89 e5                	mov    %esp,%ebp
 8049831:	53                   	push   %ebx
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 8049832:	66 8b 58 02          	mov    0x2(%eax),%bx
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 8049836:	89 da                	mov    %ebx,%edx
 8049838:	83 e2 fe             	and    $0xfffffffe,%edx
		if (used) {
 804983b:	84 c9                	test   %cl,%cl
 804983d:	74 05                	je     8049844 <set_chunk_used+0x19>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 804983f:	83 cb 01             	or     $0x1,%ebx
 8049842:	89 da                	mov    %ebx,%edx
 8049844:	66 89 50 02          	mov    %dx,0x2(%eax)
		}
	}
}
 8049848:	5b                   	pop    %ebx
 8049849:	5d                   	pop    %ebp
 804984a:	c3                   	ret    

0804984b <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
 804984b:	55                   	push   %ebp
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
 804984c:	b9 1f 00 00 00       	mov    $0x1f,%ecx
 8049851:	89 e5                	mov    %esp,%ebp
 8049853:	57                   	push   %edi
 8049854:	56                   	push   %esi
	void *cmem = &buf[c];
 8049855:	8d 34 d5 00 00 00 00 	lea    0x0(,%edx,8),%esi
 804985c:	53                   	push   %ebx
 804985d:	89 c3                	mov    %eax,%ebx
		((uint16_t *)cmem)[f] = val;
 804985f:	8d 7c 33 04          	lea    0x4(%ebx,%esi,1),%edi
 8049863:	8d 74 33 06          	lea    0x6(%ebx,%esi,1),%esi
 8049867:	83 ec 1c             	sub    $0x1c,%esp
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
 804986a:	e8 b4 ff ff ff       	call   8049823 <chunk_size>
 804986f:	89 7d e0             	mov    %edi,-0x20(%ebp)
	return 31 - __builtin_clz(usable_sz);
 8049872:	0f bd c0             	bsr    %eax,%eax
		((uint16_t *)cmem)[f] = val;
 8049875:	89 75 dc             	mov    %esi,-0x24(%ebp)
	return 31 - __builtin_clz(usable_sz);
 8049878:	83 f0 1f             	xor    $0x1f,%eax
 804987b:	29 c1                	sub    %eax,%ecx
	if (b->next == 0U) {
 804987d:	89 c8                	mov    %ecx,%eax
 804987f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 8049882:	83 c0 04             	add    $0x4,%eax
 8049885:	8b 0c 83             	mov    (%ebx,%eax,4),%ecx
 8049888:	85 c9                	test   %ecx,%ecx
 804988a:	75 1b                	jne    80498a7 <free_list_add+0x5c>
		h->avail_buckets |= BIT(bidx);
 804988c:	8a 4d e4             	mov    -0x1c(%ebp),%cl
 804988f:	bf 01 00 00 00       	mov    $0x1,%edi
 8049894:	d3 e7                	shl    %cl,%edi
 8049896:	09 7b 0c             	or     %edi,0xc(%ebx)
		b->next = c;
 8049899:	89 14 83             	mov    %edx,(%ebx,%eax,4)
		((uint16_t *)cmem)[f] = val;
 804989c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804989f:	66 89 10             	mov    %dx,(%eax)
 80498a2:	66 89 16             	mov    %dx,(%esi)
}
 80498a5:	eb 1b                	jmp    80498c2 <free_list_add+0x77>
		return ((uint16_t *)cmem)[f];
 80498a7:	8d 7c cb 04          	lea    0x4(%ebx,%ecx,8),%edi
		((uint16_t *)cmem)[f] = val;
 80498ab:	8b 75 e0             	mov    -0x20(%ebp),%esi
		return ((uint16_t *)cmem)[f];
 80498ae:	0f b7 07             	movzwl (%edi),%eax
		((uint16_t *)cmem)[f] = val;
 80498b1:	66 89 06             	mov    %ax,(%esi)
 80498b4:	8b 75 dc             	mov    -0x24(%ebp),%esi
 80498b7:	66 89 0e             	mov    %cx,(%esi)
 80498ba:	66 89 54 c3 06       	mov    %dx,0x6(%ebx,%eax,8)
 80498bf:	66 89 17             	mov    %dx,(%edi)
		free_list_add_bidx(h, c, bidx);
	}
}
 80498c2:	83 c4 1c             	add    $0x1c,%esp
 80498c5:	5b                   	pop    %ebx
 80498c6:	5e                   	pop    %esi
 80498c7:	5f                   	pop    %edi
 80498c8:	5d                   	pop    %ebp
 80498c9:	c3                   	ret    

080498ca <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
 80498ca:	55                   	push   %ebp
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 80498cb:	b9 20 00 00 00       	mov    $0x20,%ecx
{
 80498d0:	89 e5                	mov    %esp,%ebp
 80498d2:	57                   	push   %edi
 80498d3:	56                   	push   %esi
 80498d4:	53                   	push   %ebx
 80498d5:	83 ec 1c             	sub    $0x1c,%esp
 80498d8:	8b 45 0c             	mov    0xc(%ebp),%eax
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 80498db:	8b 55 10             	mov    0x10(%ebp),%edx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 80498de:	8d 58 07             	lea    0x7(%eax),%ebx
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 80498e1:	8d 44 10 fc          	lea    -0x4(%eax,%edx,1),%eax
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 80498e5:	ba 24 00 00 00       	mov    $0x24,%edx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 80498ea:	83 e3 f8             	and    $0xfffffff8,%ebx
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 80498ed:	83 e0 f8             	and    $0xfffffff8,%eax
 80498f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 80498f3:	29 d8                	sub    %ebx,%eax
 80498f5:	c1 e8 03             	shr    $0x3,%eax
 80498f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	heap->heap = h;
 80498fb:	8b 45 08             	mov    0x8(%ebp),%eax
 80498fe:	89 18                	mov    %ebx,(%eax)
	h->end_chunk = heap_sz;
 8049900:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	h->avail_buckets = 0;
 8049903:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	h->end_chunk = heap_sz;
 804990a:	89 43 08             	mov    %eax,0x8(%ebx)
	return 31 - __builtin_clz(usable_sz);
 804990d:	0f bd c0             	bsr    %eax,%eax
 8049910:	83 f0 1f             	xor    $0x1f,%eax
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 8049913:	29 c2                	sub    %eax,%edx
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 8049915:	29 c1                	sub    %eax,%ecx
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
 8049917:	31 c0                	xor    %eax,%eax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 8049919:	8d 34 95 07 00 00 00 	lea    0x7(,%edx,4),%esi
 8049920:	8d 53 10             	lea    0x10(%ebx),%edx
 8049923:	c1 e1 02             	shl    $0x2,%ecx
 8049926:	89 d7                	mov    %edx,%edi
 8049928:	c1 ee 03             	shr    $0x3,%esi
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
 804992b:	31 d2                	xor    %edx,%edx
		h->buckets[i].next = 0;
 804992d:	f3 aa                	rep stos %al,%es:(%edi)
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 804992f:	8d 04 36             	lea    (%esi,%esi,1),%eax
		((uint16_t *)cmem)[f] = val;
 8049932:	66 c7 03 00 00       	movw   $0x0,(%ebx)
	set_chunk_used(h, 0, true);
 8049937:	b9 01 00 00 00       	mov    $0x1,%ecx
 804993c:	66 89 43 02          	mov    %ax,0x2(%ebx)
 8049940:	89 d8                	mov    %ebx,%eax
 8049942:	e8 e4 fe ff ff       	call   804982b <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 8049947:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804994a:	8b 7d e0             	mov    -0x20(%ebp),%edi
 804994d:	66 89 34 f3          	mov    %si,(%ebx,%esi,8)
 8049951:	29 f0                	sub    %esi,%eax
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 8049953:	8d 14 00             	lea    (%eax,%eax,1),%edx
		((uint16_t *)cmem)[f] = val;
 8049956:	66 89 54 f3 02       	mov    %dx,0x2(%ebx,%esi,8)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
 804995b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804995e:	66 89 07             	mov    %ax,(%edi)
 8049961:	89 d8                	mov    %ebx,%eax
 8049963:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
 8049969:	e8 bd fe ff ff       	call   804982b <set_chunk_used>

	free_list_add(h, chunk0_size);
}
 804996e:	83 c4 1c             	add    $0x1c,%esp
	free_list_add(h, chunk0_size);
 8049971:	89 f2                	mov    %esi,%edx
 8049973:	89 d8                	mov    %ebx,%eax
}
 8049975:	5b                   	pop    %ebx
 8049976:	5e                   	pop    %esi
 8049977:	5f                   	pop    %edi
 8049978:	5d                   	pop    %ebp
	free_list_add(h, chunk0_size);
 8049979:	e9 cd fe ff ff       	jmp    804984b <free_list_add>

0804997e <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
 804997e:	55                   	push   %ebp
 804997f:	89 e5                	mov    %esp,%ebp
 8049981:	57                   	push   %edi
 8049982:	89 cf                	mov    %ecx,%edi
 8049984:	56                   	push   %esi
 8049985:	89 c6                	mov    %eax,%esi
 8049987:	53                   	push   %ebx
	size_t count = 0;
 8049988:	31 db                	xor    %ebx,%ebx
{
 804998a:	83 ec 1c             	sub    $0x1c,%esp

	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804998d:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
 8049990:	39 45 08             	cmp    %eax,0x8(%ebp)
 8049993:	76 1a                	jbe    80499af <outs+0x31>
		int rc = out((int)*sp++, ctx);
 8049995:	50                   	push   %eax
 8049996:	50                   	push   %eax
 8049997:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
 804999b:	52                   	push   %edx
 804999c:	50                   	push   %eax
 804999d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 80499a0:	ff d6                	call   *%esi
 80499a2:	83 c4 10             	add    $0x10,%esp

		if (rc < 0) {
 80499a5:	85 c0                	test   %eax,%eax
 80499a7:	78 18                	js     80499c1 <outs+0x43>
			return rc;
		}
		++count;
 80499a9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80499ac:	43                   	inc    %ebx
 80499ad:	eb de                	jmp    804998d <outs+0xf>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 80499af:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80499b3:	74 04                	je     80499b9 <outs+0x3b>
	}

	return (int)count;
 80499b5:	89 d8                	mov    %ebx,%eax
 80499b7:	eb 08                	jmp    80499c1 <outs+0x43>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 80499b9:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
 80499bd:	75 d6                	jne    8049995 <outs+0x17>
 80499bf:	eb f4                	jmp    80499b5 <outs+0x37>
}
 80499c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80499c4:	5b                   	pop    %ebx
 80499c5:	5e                   	pop    %esi
 80499c6:	5f                   	pop    %edi
 80499c7:	5d                   	pop    %ebp
 80499c8:	c3                   	ret    

080499c9 <extract_decimal>:
{
 80499c9:	55                   	push   %ebp
 80499ca:	89 e5                	mov    %esp,%ebp
 80499cc:	57                   	push   %edi
 80499cd:	56                   	push   %esi
 80499ce:	53                   	push   %ebx
 80499cf:	89 c3                	mov    %eax,%ebx
 80499d1:	83 ec 0c             	sub    $0xc,%esp
	const char *sp = *str;
 80499d4:	8b 30                	mov    (%eax),%esi
	while (isdigit((int)(unsigned char)*sp) != 0) {
 80499d6:	e8 45 f7 ff ff       	call   8049120 <__ctype_b_loc@plt>
 80499db:	8b 08                	mov    (%eax),%ecx
	size_t val = 0;
 80499dd:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp) != 0) {
 80499df:	0f be 16             	movsbl (%esi),%edx
 80499e2:	0f b6 fa             	movzbl %dl,%edi
 80499e5:	f6 44 79 01 08       	testb  $0x8,0x1(%ecx,%edi,2)
 80499ea:	74 0a                	je     80499f6 <extract_decimal+0x2d>
		val = 10U * val + *sp++ - '0';
 80499ec:	6b c0 0a             	imul   $0xa,%eax,%eax
 80499ef:	46                   	inc    %esi
 80499f0:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 80499f4:	eb e9                	jmp    80499df <extract_decimal+0x16>
	*str = sp;
 80499f6:	89 33                	mov    %esi,(%ebx)
}
 80499f8:	83 c4 0c             	add    $0xc,%esp
 80499fb:	5b                   	pop    %ebx
 80499fc:	5e                   	pop    %esi
 80499fd:	5f                   	pop    %edi
 80499fe:	5d                   	pop    %ebp
 80499ff:	c3                   	ret    

08049a00 <encode_uint>:
{
 8049a00:	55                   	push   %ebp
 8049a01:	89 e5                	mov    %esp,%ebp
 8049a03:	57                   	push   %edi
 8049a04:	56                   	push   %esi
 8049a05:	89 ce                	mov    %ecx,%esi
 8049a07:	53                   	push   %ebx
	switch (specifier) {
 8049a08:	bb 08 00 00 00       	mov    $0x8,%ebx
{
 8049a0d:	83 ec 3c             	sub    $0x3c,%esp
 8049a10:	89 55 dc             	mov    %edx,-0x24(%ebp)
 8049a13:	89 45 d8             	mov    %eax,-0x28(%ebp)
	bool upcase = isupper((int)conv->specifier) != 0;
 8049a16:	e8 05 f7 ff ff       	call   8049120 <__ctype_b_loc@plt>
 8049a1b:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
 8049a1f:	8b 10                	mov    (%eax),%edx
 8049a21:	66 8b 14 4a          	mov    (%edx,%ecx,2),%dx
 8049a25:	66 81 e2 00 01       	and    $0x100,%dx
 8049a2a:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
	switch (specifier) {
 8049a2e:	80 f9 6f             	cmp    $0x6f,%cl
 8049a31:	74 1b                	je     8049a4e <encode_uint+0x4e>
 8049a33:	89 c8                	mov    %ecx,%eax
 8049a35:	77 05                	ja     8049a3c <encode_uint+0x3c>
		return 16;
 8049a37:	80 f9 58             	cmp    $0x58,%cl
 8049a3a:	eb 05                	jmp    8049a41 <encode_uint+0x41>
	switch (specifier) {
 8049a3c:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
 8049a3f:	3c 70                	cmp    $0x70,%al
 8049a41:	bb 0a 00 00 00       	mov    $0xa,%ebx
 8049a46:	b8 10 00 00 00       	mov    $0x10,%eax
 8049a4b:	0f 44 d8             	cmove  %eax,%ebx
		unsigned int lsv = (unsigned int)(value % radix);
 8049a4e:	89 5d d0             	mov    %ebx,-0x30(%ebp)
	char *bp = bps + (bpe - bps);
 8049a51:	8b 7d 0c             	mov    0xc(%ebp),%edi
		unsigned int lsv = (unsigned int)(value % radix);
 8049a54:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 8049a5b:	83 ec 0c             	sub    $0xc,%esp
 8049a5e:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8049a61:	50                   	push   %eax
 8049a62:	ff 75 d4             	push   -0x2c(%ebp)
 8049a65:	ff 75 d0             	push   -0x30(%ebp)
 8049a68:	ff 75 dc             	push   -0x24(%ebp)
 8049a6b:	ff 75 d8             	push   -0x28(%ebp)
 8049a6e:	e8 9d fa ff ff       	call   8049510 <__udivmoddi4>
 8049a73:	83 c4 20             	add    $0x20,%esp
 8049a76:	89 45 c0             	mov    %eax,-0x40(%ebp)
 8049a79:	8b 45 e0             	mov    -0x20(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049a7c:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 8049a7f:	8d 50 30             	lea    0x30(%eax),%edx
 8049a82:	83 f8 09             	cmp    $0x9,%eax
 8049a85:	76 0d                	jbe    8049a94 <encode_uint+0x94>
 8049a87:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 8049a8c:	8d 50 57             	lea    0x57(%eax),%edx
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049a8f:	74 03                	je     8049a94 <encode_uint+0x94>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 8049a91:	8d 50 37             	lea    0x37(%eax),%edx
	} while ((value != 0) && (bps < bp));
 8049a94:	8b 45 d0             	mov    -0x30(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049a97:	4f                   	dec    %edi
	} while ((value != 0) && (bps < bp));
 8049a98:	39 45 d8             	cmp    %eax,-0x28(%ebp)
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049a9b:	88 17                	mov    %dl,(%edi)
	} while ((value != 0) && (bps < bp));
 8049a9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049aa0:	1b 45 d4             	sbb    -0x2c(%ebp),%eax
 8049aa3:	72 13                	jb     8049ab8 <encode_uint+0xb8>
 8049aa5:	3b 7d 08             	cmp    0x8(%ebp),%edi
 8049aa8:	76 0e                	jbe    8049ab8 <encode_uint+0xb8>
		value /= radix;
 8049aaa:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049aad:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 8049ab0:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049ab3:	89 55 dc             	mov    %edx,-0x24(%ebp)
 8049ab6:	eb a3                	jmp    8049a5b <encode_uint+0x5b>
	if (conv->flag_hash) {
 8049ab8:	f6 06 20             	testb  $0x20,(%esi)
 8049abb:	74 14                	je     8049ad1 <encode_uint+0xd1>
		if (radix == 8) {
 8049abd:	83 fb 08             	cmp    $0x8,%ebx
 8049ac0:	75 06                	jne    8049ac8 <encode_uint+0xc8>
			conv->altform_0 = true;
 8049ac2:	80 4e 02 08          	orb    $0x8,0x2(%esi)
 8049ac6:	eb 09                	jmp    8049ad1 <encode_uint+0xd1>
		} else if (radix == 16) {
 8049ac8:	83 fb 10             	cmp    $0x10,%ebx
 8049acb:	75 04                	jne    8049ad1 <encode_uint+0xd1>
			conv->altform_0c = true;
 8049acd:	80 4e 02 10          	orb    $0x10,0x2(%esi)
}
 8049ad1:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8049ad4:	89 f8                	mov    %edi,%eax
 8049ad6:	5b                   	pop    %ebx
 8049ad7:	5e                   	pop    %esi
 8049ad8:	5f                   	pop    %edi
 8049ad9:	5d                   	pop    %ebp
 8049ada:	c3                   	ret    

08049adb <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
 8049adb:	55                   	push   %ebp
 8049adc:	89 e5                	mov    %esp,%ebp
 8049ade:	57                   	push   %edi
 8049adf:	56                   	push   %esi
 8049ae0:	53                   	push   %ebx
 8049ae1:	83 ec 6c             	sub    $0x6c,%esp
 8049ae4:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ae7:	8b 75 14             	mov    0x14(%ebp),%esi
 8049aea:	89 45 9c             	mov    %eax,-0x64(%ebp)
 8049aed:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049af0:	89 45 98             	mov    %eax,-0x68(%ebp)
 8049af3:	8b 45 10             	mov    0x10(%ebp),%eax
 8049af6:	89 45 8c             	mov    %eax,-0x74(%ebp)
 8049af9:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049aff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8049b02:	31 c0                	xor    %eax,%eax
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 8049b04:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 8049b0b:	8b 45 8c             	mov    -0x74(%ebp),%eax
 8049b0e:	0f be 00             	movsbl (%eax),%eax
 8049b11:	84 c0                	test   %al,%al
 8049b13:	0f 84 89 07 00 00    	je     804a2a2 <z_cbvprintf_impl+0x7c7>
		if (*fp != '%') {
			OUTC(*fp++);
 8049b19:	8b 7d 8c             	mov    -0x74(%ebp),%edi
 8049b1c:	47                   	inc    %edi
 8049b1d:	89 7d 94             	mov    %edi,-0x6c(%ebp)
		if (*fp != '%') {
 8049b20:	3c 25                	cmp    $0x25,%al
 8049b22:	74 20                	je     8049b44 <z_cbvprintf_impl+0x69>
			OUTC(*fp++);
 8049b24:	53                   	push   %ebx
 8049b25:	53                   	push   %ebx
 8049b26:	ff 75 98             	push   -0x68(%ebp)
 8049b29:	50                   	push   %eax
 8049b2a:	8b 45 9c             	mov    -0x64(%ebp),%eax
 8049b2d:	ff d0                	call   *%eax
 8049b2f:	83 c4 10             	add    $0x10,%esp
 8049b32:	85 c0                	test   %eax,%eax
 8049b34:	0f 88 7a 07 00 00    	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 8049b3a:	ff 45 a4             	incl   -0x5c(%ebp)
			continue;
 8049b3d:	89 f3                	mov    %esi,%ebx
 8049b3f:	e9 51 07 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
 8049b44:	31 c0                	xor    %eax,%eax
 8049b46:	8d 7d b4             	lea    -0x4c(%ebp),%edi
 8049b49:	b9 06 00 00 00       	mov    $0x6,%ecx
 8049b4e:	f3 ab                	rep stos %eax,%es:(%edi)
	if (*sp == '%') {
 8049b50:	8b 45 8c             	mov    -0x74(%ebp),%eax
 8049b53:	80 78 01 25          	cmpb   $0x25,0x1(%eax)
 8049b57:	75 1c                	jne    8049b75 <z_cbvprintf_impl+0x9a>
		conv->specifier = *sp++;
 8049b59:	83 c0 02             	add    $0x2,%eax
 8049b5c:	c6 45 c3 25          	movb   $0x25,-0x3d(%ebp)
 8049b60:	89 45 94             	mov    %eax,-0x6c(%ebp)
		return sp;
 8049b63:	e9 5c 02 00 00       	jmp    8049dc4 <z_cbvprintf_impl+0x2e9>
		switch (*sp) {
 8049b68:	7e 16                	jle    8049b80 <z_cbvprintf_impl+0xa5>
 8049b6a:	3c 2d                	cmp    $0x2d,%al
 8049b6c:	75 1c                	jne    8049b8a <z_cbvprintf_impl+0xaf>
			conv->flag_dash = true;
 8049b6e:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
			++sp;
 8049b72:	ff 45 94             	incl   -0x6c(%ebp)
		switch (*sp) {
 8049b75:	8b 45 94             	mov    -0x6c(%ebp),%eax
 8049b78:	8a 00                	mov    (%eax),%al
 8049b7a:	3c 2b                	cmp    $0x2b,%al
 8049b7c:	75 ea                	jne    8049b68 <z_cbvprintf_impl+0x8d>
 8049b7e:	eb 23                	jmp    8049ba3 <z_cbvprintf_impl+0xc8>
 8049b80:	3c 20                	cmp    $0x20,%al
 8049b82:	74 25                	je     8049ba9 <z_cbvprintf_impl+0xce>
 8049b84:	3c 23                	cmp    $0x23,%al
 8049b86:	74 27                	je     8049baf <z_cbvprintf_impl+0xd4>
 8049b88:	eb 04                	jmp    8049b8e <z_cbvprintf_impl+0xb3>
 8049b8a:	3c 30                	cmp    $0x30,%al
 8049b8c:	74 27                	je     8049bb5 <z_cbvprintf_impl+0xda>
	if (conv->flag_zero && conv->flag_dash) {
 8049b8e:	8a 45 c0             	mov    -0x40(%ebp),%al
 8049b91:	89 c2                	mov    %eax,%edx
 8049b93:	83 e2 44             	and    $0x44,%edx
 8049b96:	80 fa 44             	cmp    $0x44,%dl
 8049b99:	75 20                	jne    8049bbb <z_cbvprintf_impl+0xe0>
		conv->flag_zero = false;
 8049b9b:	83 e0 bf             	and    $0xffffffbf,%eax
 8049b9e:	88 45 c0             	mov    %al,-0x40(%ebp)
 8049ba1:	eb 18                	jmp    8049bbb <z_cbvprintf_impl+0xe0>
			conv->flag_plus = true;
 8049ba3:	80 4d c0 08          	orb    $0x8,-0x40(%ebp)
			break;
 8049ba7:	eb c9                	jmp    8049b72 <z_cbvprintf_impl+0x97>
			conv->flag_space = true;
 8049ba9:	80 4d c0 10          	orb    $0x10,-0x40(%ebp)
			break;
 8049bad:	eb c3                	jmp    8049b72 <z_cbvprintf_impl+0x97>
			conv->flag_hash = true;
 8049baf:	80 4d c0 20          	orb    $0x20,-0x40(%ebp)
			break;
 8049bb3:	eb bd                	jmp    8049b72 <z_cbvprintf_impl+0x97>
			conv->flag_zero = true;
 8049bb5:	80 4d c0 40          	orb    $0x40,-0x40(%ebp)
			break;
 8049bb9:	eb b7                	jmp    8049b72 <z_cbvprintf_impl+0x97>
	sp = extract_width(conv, sp);
 8049bbb:	8b 45 94             	mov    -0x6c(%ebp),%eax
	conv->width_present = true;
 8049bbe:	80 4d c0 80          	orb    $0x80,-0x40(%ebp)
 8049bc2:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
 8049bc5:	80 38 2a             	cmpb   $0x2a,(%eax)
 8049bc8:	75 09                	jne    8049bd3 <z_cbvprintf_impl+0xf8>
		return ++sp;
 8049bca:	89 c2                	mov    %eax,%edx
		conv->width_star = true;
 8049bcc:	80 4d c1 01          	orb    $0x1,-0x3f(%ebp)
		return ++sp;
 8049bd0:	42                   	inc    %edx
 8049bd1:	eb 23                	jmp    8049bf6 <z_cbvprintf_impl+0x11b>
	size_t width = extract_decimal(&sp);
 8049bd3:	8d 45 b0             	lea    -0x50(%ebp),%eax
 8049bd6:	e8 ee fd ff ff       	call   80499c9 <extract_decimal>
	if (sp != wp) {
 8049bdb:	8b 55 b0             	mov    -0x50(%ebp),%edx
 8049bde:	3b 55 94             	cmp    -0x6c(%ebp),%edx
 8049be1:	74 13                	je     8049bf6 <z_cbvprintf_impl+0x11b>
		conv->unsupported |= ((conv->width_value < 0)
 8049be3:	8a 4d c0             	mov    -0x40(%ebp),%cl
		conv->width_value = width;
 8049be6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		conv->unsupported |= ((conv->width_value < 0)
 8049be9:	c1 e8 1f             	shr    $0x1f,%eax
 8049bec:	01 c0                	add    %eax,%eax
 8049bee:	83 e1 fd             	and    $0xfffffffd,%ecx
 8049bf1:	09 c1                	or     %eax,%ecx
 8049bf3:	88 4d c0             	mov    %cl,-0x40(%ebp)
	sp = extract_prec(conv, sp);
 8049bf6:	89 55 b0             	mov    %edx,-0x50(%ebp)
	conv->prec_present = (*sp == '.');
 8049bf9:	8a 02                	mov    (%edx),%al
 8049bfb:	8a 4d c1             	mov    -0x3f(%ebp),%cl
 8049bfe:	3c 2e                	cmp    $0x2e,%al
 8049c00:	0f 94 c3             	sete   %bl
 8049c03:	83 e1 fd             	and    $0xfffffffd,%ecx
 8049c06:	01 db                	add    %ebx,%ebx
 8049c08:	09 d9                	or     %ebx,%ecx
 8049c0a:	88 4d c1             	mov    %cl,-0x3f(%ebp)
	if (!conv->prec_present) {
 8049c0d:	3c 2e                	cmp    $0x2e,%al
 8049c0f:	75 40                	jne    8049c51 <z_cbvprintf_impl+0x176>
	++sp;
 8049c11:	8d 42 01             	lea    0x1(%edx),%eax
 8049c14:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
 8049c17:	80 7a 01 2a          	cmpb   $0x2a,0x1(%edx)
 8049c1b:	75 0b                	jne    8049c28 <z_cbvprintf_impl+0x14d>
		conv->prec_star = true;
 8049c1d:	83 c9 04             	or     $0x4,%ecx
		return ++sp;
 8049c20:	83 c2 02             	add    $0x2,%edx
		conv->prec_star = true;
 8049c23:	88 4d c1             	mov    %cl,-0x3f(%ebp)
		return ++sp;
 8049c26:	eb 29                	jmp    8049c51 <z_cbvprintf_impl+0x176>
	size_t prec = extract_decimal(&sp);
 8049c28:	8d 45 b0             	lea    -0x50(%ebp),%eax
 8049c2b:	e8 99 fd ff ff       	call   80499c9 <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
 8049c30:	8a 4d c0             	mov    -0x40(%ebp),%cl
	size_t prec = extract_decimal(&sp);
 8049c33:	89 c2                	mov    %eax,%edx
	conv->prec_value = prec;
 8049c35:	89 45 c8             	mov    %eax,-0x38(%ebp)
	conv->unsupported |= ((conv->prec_value < 0)
 8049c38:	89 c8                	mov    %ecx,%eax
			      || (prec != (size_t)conv->prec_value));
 8049c3a:	c1 ea 1f             	shr    $0x1f,%edx
	conv->unsupported |= ((conv->prec_value < 0)
 8049c3d:	83 e1 fd             	and    $0xfffffffd,%ecx
 8049c40:	d0 e8                	shr    %al
 8049c42:	83 e0 01             	and    $0x1,%eax
 8049c45:	09 d0                	or     %edx,%eax
	return sp;
 8049c47:	8b 55 b0             	mov    -0x50(%ebp),%edx
	conv->unsupported |= ((conv->prec_value < 0)
 8049c4a:	01 c0                	add    %eax,%eax
 8049c4c:	09 c1                	or     %eax,%ecx
 8049c4e:	88 4d c0             	mov    %cl,-0x40(%ebp)
	switch (*sp) {
 8049c51:	8a 02                	mov    (%edx),%al
		if (*++sp == 'h') {
 8049c53:	8d 4a 01             	lea    0x1(%edx),%ecx
	switch (*sp) {
 8049c56:	3c 6c                	cmp    $0x6c,%al
 8049c58:	74 35                	je     8049c8f <z_cbvprintf_impl+0x1b4>
 8049c5a:	7f 0e                	jg     8049c6a <z_cbvprintf_impl+0x18f>
 8049c5c:	3c 68                	cmp    $0x68,%al
 8049c5e:	74 16                	je     8049c76 <z_cbvprintf_impl+0x19b>
 8049c60:	3c 6a                	cmp    $0x6a,%al
 8049c62:	74 4a                	je     8049cae <z_cbvprintf_impl+0x1d3>
 8049c64:	3c 4c                	cmp    $0x4c,%al
 8049c66:	74 6a                	je     8049cd2 <z_cbvprintf_impl+0x1f7>
 8049c68:	eb 08                	jmp    8049c72 <z_cbvprintf_impl+0x197>
 8049c6a:	3c 74                	cmp    $0x74,%al
 8049c6c:	74 56                	je     8049cc4 <z_cbvprintf_impl+0x1e9>
 8049c6e:	3c 7a                	cmp    $0x7a,%al
 8049c70:	74 47                	je     8049cb9 <z_cbvprintf_impl+0x1de>
 8049c72:	89 d1                	mov    %edx,%ecx
 8049c74:	eb 6b                	jmp    8049ce1 <z_cbvprintf_impl+0x206>
		if (*++sp == 'h') {
 8049c76:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
 8049c7a:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049c7d:	75 08                	jne    8049c87 <z_cbvprintf_impl+0x1ac>
			conv->length_mod = LENGTH_HH;
 8049c7f:	83 e0 87             	and    $0xffffff87,%eax
 8049c82:	83 c8 08             	or     $0x8,%eax
 8049c85:	eb 17                	jmp    8049c9e <z_cbvprintf_impl+0x1c3>
			conv->length_mod = LENGTH_H;
 8049c87:	83 e0 87             	and    $0xffffff87,%eax
 8049c8a:	83 c8 10             	or     $0x10,%eax
 8049c8d:	eb 3e                	jmp    8049ccd <z_cbvprintf_impl+0x1f2>
		if (*++sp == 'l') {
 8049c8f:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
 8049c93:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049c96:	75 0e                	jne    8049ca6 <z_cbvprintf_impl+0x1cb>
			conv->length_mod = LENGTH_LL;
 8049c98:	83 e0 87             	and    $0xffffff87,%eax
 8049c9b:	83 c8 20             	or     $0x20,%eax
 8049c9e:	88 45 c1             	mov    %al,-0x3f(%ebp)
			++sp;
 8049ca1:	8d 4a 02             	lea    0x2(%edx),%ecx
 8049ca4:	eb 3b                	jmp    8049ce1 <z_cbvprintf_impl+0x206>
			conv->length_mod = LENGTH_L;
 8049ca6:	83 e0 87             	and    $0xffffff87,%eax
 8049ca9:	83 c8 18             	or     $0x18,%eax
 8049cac:	eb 1f                	jmp    8049ccd <z_cbvprintf_impl+0x1f2>
		conv->length_mod = LENGTH_J;
 8049cae:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049cb1:	83 e0 87             	and    $0xffffff87,%eax
 8049cb4:	83 c8 28             	or     $0x28,%eax
 8049cb7:	eb 14                	jmp    8049ccd <z_cbvprintf_impl+0x1f2>
		conv->length_mod = LENGTH_Z;
 8049cb9:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049cbc:	83 e0 87             	and    $0xffffff87,%eax
 8049cbf:	83 c8 30             	or     $0x30,%eax
 8049cc2:	eb 09                	jmp    8049ccd <z_cbvprintf_impl+0x1f2>
		conv->length_mod = LENGTH_T;
 8049cc4:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049cc7:	83 e0 87             	and    $0xffffff87,%eax
 8049cca:	83 c8 38             	or     $0x38,%eax
 8049ccd:	88 45 c1             	mov    %al,-0x3f(%ebp)
		break;
 8049cd0:	eb 0f                	jmp    8049ce1 <z_cbvprintf_impl+0x206>
		conv->unsupported = true;
 8049cd2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049cd5:	66 25 fd 87          	and    $0x87fd,%ax
 8049cd9:	66 0d 02 40          	or     $0x4002,%ax
 8049cdd:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
	conv->specifier = *sp++;
 8049ce1:	8d 41 01             	lea    0x1(%ecx),%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049ce4:	8a 55 c1             	mov    -0x3f(%ebp),%dl
	conv->specifier = *sp++;
 8049ce7:	89 45 94             	mov    %eax,-0x6c(%ebp)
 8049cea:	8a 01                	mov    (%ecx),%al
 8049cec:	88 45 c3             	mov    %al,-0x3d(%ebp)
	switch (conv->specifier) {
 8049cef:	3c 78                	cmp    $0x78,%al
 8049cf1:	0f 8f b1 00 00 00    	jg     8049da8 <z_cbvprintf_impl+0x2cd>
 8049cf7:	3c 6d                	cmp    $0x6d,%al
 8049cf9:	7f 1d                	jg     8049d18 <z_cbvprintf_impl+0x23d>
 8049cfb:	3c 69                	cmp    $0x69,%al
 8049cfd:	0f 8f a5 00 00 00    	jg     8049da8 <z_cbvprintf_impl+0x2cd>
 8049d03:	3c 57                	cmp    $0x57,%al
 8049d05:	7f 44                	jg     8049d4b <z_cbvprintf_impl+0x270>
 8049d07:	3c 41                	cmp    $0x41,%al
 8049d09:	74 79                	je     8049d84 <z_cbvprintf_impl+0x2a9>
 8049d0b:	83 e8 45             	sub    $0x45,%eax
 8049d0e:	3c 02                	cmp    $0x2,%al
 8049d10:	0f 87 92 00 00 00    	ja     8049da8 <z_cbvprintf_impl+0x2cd>
 8049d16:	eb 6c                	jmp    8049d84 <z_cbvprintf_impl+0x2a9>
 8049d18:	8d 48 92             	lea    -0x6e(%eax),%ecx
 8049d1b:	bb 01 00 00 00       	mov    $0x1,%ebx
 8049d20:	d3 e3                	shl    %cl,%ebx
 8049d22:	f7 c3 82 04 00 00    	test   $0x482,%ebx
 8049d28:	75 37                	jne    8049d61 <z_cbvprintf_impl+0x286>
 8049d2a:	f6 c3 24             	test   $0x24,%bl
 8049d2d:	75 65                	jne    8049d94 <z_cbvprintf_impl+0x2b9>
 8049d2f:	80 e3 01             	and    $0x1,%bl
 8049d32:	74 74                	je     8049da8 <z_cbvprintf_impl+0x2cd>
		conv->specifier_cat = SPECIFIER_PTR;
 8049d34:	8a 45 c2             	mov    -0x3e(%ebp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049d37:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
 8049d3a:	83 e0 f8             	and    $0xfffffff8,%eax
 8049d3d:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049d40:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 8049d43:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049d46:	0f 94 c1             	sete   %cl
 8049d49:	eb 63                	jmp    8049dae <z_cbvprintf_impl+0x2d3>
	switch (conv->specifier) {
 8049d4b:	8d 48 a8             	lea    -0x58(%eax),%ecx
 8049d4e:	80 f9 11             	cmp    $0x11,%cl
 8049d51:	77 55                	ja     8049da8 <z_cbvprintf_impl+0x2cd>
 8049d53:	0f b6 c9             	movzbl %cl,%ecx
 8049d56:	ff 24 8d 04 e0 04 08 	jmp    *0x804e004(,%ecx,4)
 8049d5d:	b3 01                	mov    $0x1,%bl
 8049d5f:	eb 02                	jmp    8049d63 <z_cbvprintf_impl+0x288>
 8049d61:	b3 02                	mov    $0x2,%bl
		conv->specifier_cat = SPECIFIER_SINT;
 8049d63:	8a 4d c2             	mov    -0x3e(%ebp),%cl
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049d66:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_SINT;
 8049d69:	83 e1 f8             	and    $0xfffffff8,%ecx
 8049d6c:	09 d9                	or     %ebx,%ecx
 8049d6e:	88 4d c2             	mov    %cl,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049d71:	80 fa 40             	cmp    $0x40,%dl
 8049d74:	75 04                	jne    8049d7a <z_cbvprintf_impl+0x29f>
			conv->invalid = true;
 8049d76:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 8049d7a:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
 8049d7c:	3c 63                	cmp    $0x63,%al
 8049d7e:	75 2e                	jne    8049dae <z_cbvprintf_impl+0x2d3>
			unsupported = (conv->length_mod != LENGTH_NONE);
 8049d80:	84 d2                	test   %dl,%dl
 8049d82:	eb 1f                	jmp    8049da3 <z_cbvprintf_impl+0x2c8>
		conv->specifier_cat = SPECIFIER_FP;
 8049d84:	8a 45 c2             	mov    -0x3e(%ebp),%al
			unsupported = true;
 8049d87:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
 8049d89:	83 e0 f8             	and    $0xfffffff8,%eax
 8049d8c:	83 c8 04             	or     $0x4,%eax
 8049d8f:	88 45 c2             	mov    %al,-0x3e(%ebp)
			break;
 8049d92:	eb 1a                	jmp    8049dae <z_cbvprintf_impl+0x2d3>
		conv->specifier_cat = SPECIFIER_PTR;
 8049d94:	8a 45 c2             	mov    -0x3e(%ebp),%al
 8049d97:	83 e0 f8             	and    $0xfffffff8,%eax
 8049d9a:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
 8049d9d:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 8049da0:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod != LENGTH_NONE) {
 8049da3:	0f 95 c1             	setne  %cl
 8049da6:	eb 06                	jmp    8049dae <z_cbvprintf_impl+0x2d3>
		conv->invalid = true;
 8049da8:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 8049dac:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
 8049dae:	8a 55 c0             	mov    -0x40(%ebp),%dl
 8049db1:	89 d0                	mov    %edx,%eax
 8049db3:	83 e2 fd             	and    $0xfffffffd,%edx
 8049db6:	d0 e8                	shr    %al
 8049db8:	83 e0 01             	and    $0x1,%eax
 8049dbb:	09 c8                	or     %ecx,%eax
 8049dbd:	01 c0                	add    %eax,%eax
 8049dbf:	09 c2                	or     %eax,%edx
 8049dc1:	88 55 c0             	mov    %dl,-0x40(%ebp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
 8049dc4:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049dc7:	a8 01                	test   $0x1,%al
 8049dc9:	74 11                	je     8049ddc <z_cbvprintf_impl+0x301>
			width = va_arg(ap, int);
 8049dcb:	8b 3e                	mov    (%esi),%edi
 8049dcd:	83 c6 04             	add    $0x4,%esi

			if (width < 0) {
 8049dd0:	85 ff                	test   %edi,%edi
 8049dd2:	79 14                	jns    8049de8 <z_cbvprintf_impl+0x30d>
				conv->flag_dash = true;
 8049dd4:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
				width = -width;
 8049dd8:	f7 df                	neg    %edi
 8049dda:	eb 0c                	jmp    8049de8 <z_cbvprintf_impl+0x30d>
		int width = -1;
 8049ddc:	83 cf ff             	or     $0xffffffff,%edi
			}
		} else if (conv->width_present) {
 8049ddf:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
 8049de3:	79 03                	jns    8049de8 <z_cbvprintf_impl+0x30d>
			width = conv->width_value;
 8049de5:	8b 7d c4             	mov    -0x3c(%ebp),%edi

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
 8049de8:	a8 04                	test   $0x4,%al
 8049dea:	74 12                	je     8049dfe <z_cbvprintf_impl+0x323>
			int arg = va_arg(ap, int);
 8049dec:	8b 06                	mov    (%esi),%eax
 8049dee:	8d 5e 04             	lea    0x4(%esi),%ebx
 8049df1:	89 45 90             	mov    %eax,-0x70(%ebp)

			if (arg < 0) {
 8049df4:	85 c0                	test   %eax,%eax
 8049df6:	79 1d                	jns    8049e15 <z_cbvprintf_impl+0x33a>
				conv->prec_present = false;
 8049df8:	80 65 c1 fd          	andb   $0xfd,-0x3f(%ebp)
 8049dfc:	eb 10                	jmp    8049e0e <z_cbvprintf_impl+0x333>
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
 8049dfe:	a8 02                	test   $0x2,%al
 8049e00:	74 0a                	je     8049e0c <z_cbvprintf_impl+0x331>
			precision = conv->prec_value;
 8049e02:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8049e05:	89 f3                	mov    %esi,%ebx
 8049e07:	89 45 90             	mov    %eax,-0x70(%ebp)
 8049e0a:	eb 09                	jmp    8049e15 <z_cbvprintf_impl+0x33a>
 8049e0c:	89 f3                	mov    %esi,%ebx
		int precision = -1;
 8049e0e:	c7 45 90 ff ff ff ff 	movl   $0xffffffff,-0x70(%ebp)
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
 8049e15:	8a 45 c2             	mov    -0x3e(%ebp),%al
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
 8049e18:	8a 55 c1             	mov    -0x3f(%ebp),%dl
		conv->pad0_value = 0;
 8049e1b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		conv->pad0_pre_exp = 0;
 8049e22:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			= (enum length_mod_enum)conv->length_mod;
 8049e29:	c0 ea 03             	shr    $0x3,%dl
		enum specifier_cat_enum specifier_cat
 8049e2c:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
 8049e2f:	88 55 a0             	mov    %dl,-0x60(%ebp)
 8049e32:	80 65 a0 0f          	andb   $0xf,-0x60(%ebp)
		enum length_mod_enum length_mod
 8049e36:	0f b6 4d a0          	movzbl -0x60(%ebp),%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
 8049e3a:	83 f8 01             	cmp    $0x1,%eax
 8049e3d:	75 4f                	jne    8049e8e <z_cbvprintf_impl+0x3b3>
			switch (length_mod) {
 8049e3f:	80 7d a0 05          	cmpb   $0x5,-0x60(%ebp)
 8049e43:	74 70                	je     8049eb5 <z_cbvprintf_impl+0x3da>
 8049e45:	77 19                	ja     8049e60 <z_cbvprintf_impl+0x385>
 8049e47:	80 7d a0 03          	cmpb   $0x3,-0x60(%ebp)
 8049e4b:	74 08                	je     8049e55 <z_cbvprintf_impl+0x37a>
 8049e4d:	80 7d a0 04          	cmpb   $0x4,-0x60(%ebp)
 8049e51:	74 62                	je     8049eb5 <z_cbvprintf_impl+0x3da>
 8049e53:	eb 0b                	jmp    8049e60 <z_cbvprintf_impl+0x385>
				if (WCHAR_IS_SIGNED
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->sint = va_arg(ap, long);
 8049e55:	8b 03                	mov    (%ebx),%eax
				value->sint = va_arg(ap, int);
 8049e57:	8d 4b 04             	lea    0x4(%ebx),%ecx
					value->sint = va_arg(ap, long);
 8049e5a:	99                   	cltd   
 8049e5b:	e9 47 04 00 00       	jmp    804a2a7 <z_cbvprintf_impl+0x7cc>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
 8049e60:	8b 03                	mov    (%ebx),%eax
 8049e62:	83 c3 04             	add    $0x4,%ebx
 8049e65:	99                   	cltd   
				value->sint = va_arg(ap, int);
 8049e66:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8049e69:	89 55 b8             	mov    %edx,-0x48(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
 8049e6c:	83 f9 01             	cmp    $0x1,%ecx
 8049e6f:	75 05                	jne    8049e76 <z_cbvprintf_impl+0x39b>
				value->sint = (signed char)value->sint;
 8049e71:	0f be c0             	movsbl %al,%eax
 8049e74:	eb 0a                	jmp    8049e80 <z_cbvprintf_impl+0x3a5>
			} else if (length_mod == LENGTH_H) {
 8049e76:	83 f9 02             	cmp    $0x2,%ecx
 8049e79:	0f 85 9d 00 00 00    	jne    8049f1c <z_cbvprintf_impl+0x441>
				value->sint = (short)value->sint;
 8049e7f:	98                   	cwtl   
 8049e80:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8049e83:	c1 f8 1f             	sar    $0x1f,%eax
 8049e86:	89 45 b8             	mov    %eax,-0x48(%ebp)
 8049e89:	e9 8e 00 00 00       	jmp    8049f1c <z_cbvprintf_impl+0x441>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
 8049e8e:	83 f8 02             	cmp    $0x2,%eax
 8049e91:	75 5e                	jne    8049ef1 <z_cbvprintf_impl+0x416>
			switch (length_mod) {
 8049e93:	80 7d a0 05          	cmpb   $0x5,-0x60(%ebp)
 8049e97:	74 1c                	je     8049eb5 <z_cbvprintf_impl+0x3da>
 8049e99:	77 27                	ja     8049ec2 <z_cbvprintf_impl+0x3e7>
 8049e9b:	80 7d a0 03          	cmpb   $0x3,-0x60(%ebp)
 8049e9f:	74 08                	je     8049ea9 <z_cbvprintf_impl+0x3ce>
 8049ea1:	80 7d a0 04          	cmpb   $0x4,-0x60(%ebp)
 8049ea5:	74 0e                	je     8049eb5 <z_cbvprintf_impl+0x3da>
 8049ea7:	eb 19                	jmp    8049ec2 <z_cbvprintf_impl+0x3e7>
				if ((!WCHAR_IS_SIGNED)
				    && (conv->specifier == 'c')) {
					value->uint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->uint = va_arg(ap, unsigned long);
 8049ea9:	8b 03                	mov    (%ebx),%eax
 8049eab:	8d 4b 04             	lea    0x4(%ebx),%ecx
 8049eae:	31 d2                	xor    %edx,%edx
				}
				break;
 8049eb0:	e9 f2 03 00 00       	jmp    804a2a7 <z_cbvprintf_impl+0x7cc>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
 8049eb5:	8b 03                	mov    (%ebx),%eax
 8049eb7:	8b 53 04             	mov    0x4(%ebx),%edx
 8049eba:	8d 4b 08             	lea    0x8(%ebx),%ecx
								uintmax_t);
				break;
 8049ebd:	e9 e5 03 00 00       	jmp    804a2a7 <z_cbvprintf_impl+0x7cc>
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
 8049ec2:	8b 03                	mov    (%ebx),%eax
 8049ec4:	31 d2                	xor    %edx,%edx
 8049ec6:	83 c3 04             	add    $0x4,%ebx
				value->uint = va_arg(ap, unsigned int);
 8049ec9:	89 55 b8             	mov    %edx,-0x48(%ebp)
 8049ecc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
 8049ecf:	83 f9 01             	cmp    $0x1,%ecx
 8049ed2:	75 07                	jne    8049edb <z_cbvprintf_impl+0x400>
				value->uint = (unsigned char)value->uint;
 8049ed4:	25 ff 00 00 00       	and    $0xff,%eax
 8049ed9:	eb 0a                	jmp    8049ee5 <z_cbvprintf_impl+0x40a>
			} else if (length_mod == LENGTH_H) {
 8049edb:	83 f9 02             	cmp    $0x2,%ecx
 8049ede:	75 3c                	jne    8049f1c <z_cbvprintf_impl+0x441>
				value->uint = (unsigned short)value->uint;
 8049ee0:	25 ff ff 00 00       	and    $0xffff,%eax
 8049ee5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8049ee8:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049eef:	eb 2b                	jmp    8049f1c <z_cbvprintf_impl+0x441>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
 8049ef1:	83 f8 04             	cmp    $0x4,%eax
 8049ef4:	75 19                	jne    8049f0f <z_cbvprintf_impl+0x434>
			if (length_mod == LENGTH_UPPER_L) {
 8049ef6:	83 f9 08             	cmp    $0x8,%ecx
 8049ef9:	75 0a                	jne    8049f05 <z_cbvprintf_impl+0x42a>
				value->ldbl = va_arg(ap, long double);
 8049efb:	db 2b                	fldt   (%ebx)
 8049efd:	83 c3 0c             	add    $0xc,%ebx
 8049f00:	db 7d b4             	fstpt  -0x4c(%ebp)
 8049f03:	eb 17                	jmp    8049f1c <z_cbvprintf_impl+0x441>
			} else {
				value->dbl = va_arg(ap, double);
 8049f05:	dd 03                	fldl   (%ebx)
 8049f07:	83 c3 08             	add    $0x8,%ebx
 8049f0a:	dd 5d b4             	fstpl  -0x4c(%ebp)
 8049f0d:	eb 0d                	jmp    8049f1c <z_cbvprintf_impl+0x441>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
 8049f0f:	83 f8 03             	cmp    $0x3,%eax
 8049f12:	75 08                	jne    8049f1c <z_cbvprintf_impl+0x441>
			value->ptr = va_arg(ap, void *);
 8049f14:	8b 03                	mov    (%ebx),%eax
 8049f16:	83 c3 04             	add    $0x4,%ebx
 8049f19:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
 8049f1c:	8a 45 c0             	mov    -0x40(%ebp),%al
 8049f1f:	a8 03                	test   $0x3,%al
 8049f21:	74 27                	je     8049f4a <z_cbvprintf_impl+0x46f>
			OUTS(sp, fp);
 8049f23:	83 ec 0c             	sub    $0xc,%esp
 8049f26:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
 8049f29:	8b 55 98             	mov    -0x68(%ebp),%edx
 8049f2c:	ff 75 94             	push   -0x6c(%ebp)
 8049f2f:	8b 45 9c             	mov    -0x64(%ebp),%eax
 8049f32:	e8 47 fa ff ff       	call   804997e <outs>
 8049f37:	83 c4 10             	add    $0x10,%esp
 8049f3a:	85 c0                	test   %eax,%eax
 8049f3c:	0f 88 72 03 00 00    	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 8049f42:	01 45 a4             	add    %eax,-0x5c(%ebp)
			continue;
 8049f45:	e9 4b 03 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
 8049f4a:	8a 55 c3             	mov    -0x3d(%ebp),%dl
 8049f4d:	80 fa 78             	cmp    $0x78,%dl
 8049f50:	0f 87 3f 03 00 00    	ja     804a295 <z_cbvprintf_impl+0x7ba>
 8049f56:	80 fa 62             	cmp    $0x62,%dl
 8049f59:	77 13                	ja     8049f6e <z_cbvprintf_impl+0x493>
 8049f5b:	80 fa 25             	cmp    $0x25,%dl
 8049f5e:	74 24                	je     8049f84 <z_cbvprintf_impl+0x4a9>
 8049f60:	80 fa 58             	cmp    $0x58,%dl
 8049f63:	0f 84 b3 00 00 00    	je     804a01c <z_cbvprintf_impl+0x541>
 8049f69:	e9 27 03 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
 8049f6e:	83 ea 63             	sub    $0x63,%edx
 8049f71:	80 fa 15             	cmp    $0x15,%dl
 8049f74:	0f 87 1b 03 00 00    	ja     804a295 <z_cbvprintf_impl+0x7ba>
 8049f7a:	0f b6 d2             	movzbl %dl,%edx
 8049f7d:	ff 24 95 4c e0 04 08 	jmp    *0x804e04c(,%edx,4)
		case '%':
			OUTC('%');
 8049f84:	51                   	push   %ecx
 8049f85:	8b 45 9c             	mov    -0x64(%ebp),%eax
 8049f88:	51                   	push   %ecx
 8049f89:	ff 75 98             	push   -0x68(%ebp)
 8049f8c:	6a 25                	push   $0x25
 8049f8e:	ff d0                	call   *%eax
 8049f90:	83 c4 10             	add    $0x10,%esp
 8049f93:	85 c0                	test   %eax,%eax
 8049f95:	0f 88 19 03 00 00    	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 8049f9b:	ff 45 a4             	incl   -0x5c(%ebp)
			break;
 8049f9e:	e9 f2 02 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
		case 's': {
			bps = (const char *)value->ptr;
 8049fa3:	8b 45 b4             	mov    -0x4c(%ebp),%eax

			size_t len;

			if (precision >= 0) {
 8049fa6:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
			bps = (const char *)value->ptr;
 8049faa:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if (precision >= 0) {
 8049fad:	78 0d                	js     8049fbc <z_cbvprintf_impl+0x4e1>
				len = strnlen(bps, precision);
 8049faf:	52                   	push   %edx
 8049fb0:	52                   	push   %edx
 8049fb1:	ff 75 90             	push   -0x70(%ebp)
 8049fb4:	50                   	push   %eax
 8049fb5:	e8 26 f2 ff ff       	call   80491e0 <strnlen@plt>
 8049fba:	eb 0b                	jmp    8049fc7 <z_cbvprintf_impl+0x4ec>
			} else {
				len = strlen(bps);
 8049fbc:	83 ec 0c             	sub    $0xc,%esp
 8049fbf:	ff 75 a0             	push   -0x60(%ebp)
 8049fc2:	e8 a9 f1 ff ff       	call   8049170 <strlen@plt>
			}

			bpe = bps + len;
 8049fc7:	03 45 a0             	add    -0x60(%ebp),%eax
				len = strlen(bps);
 8049fca:	83 c4 10             	add    $0x10,%esp
		char sign = 0;
 8049fcd:	31 f6                	xor    %esi,%esi
			bpe = bps + len;
 8049fcf:	89 45 8c             	mov    %eax,-0x74(%ebp)
			precision = -1;

			break;
 8049fd2:	e9 17 01 00 00       	jmp    804a0ee <z_cbvprintf_impl+0x613>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 8049fd7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049fda:	88 45 ce             	mov    %al,-0x32(%ebp)
			bps = buf;
 8049fdd:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049fe0:	89 45 a0             	mov    %eax,-0x60(%ebp)
			bpe = buf + 1;
 8049fe3:	8d 45 cf             	lea    -0x31(%ebp),%eax
 8049fe6:	89 45 8c             	mov    %eax,-0x74(%ebp)
 8049fe9:	e9 19 01 00 00       	jmp    804a107 <z_cbvprintf_impl+0x62c>
			break;
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
 8049fee:	be 2b 00 00 00       	mov    $0x2b,%esi
			if (conv->flag_plus) {
 8049ff3:	a8 08                	test   $0x8,%al
 8049ff5:	75 07                	jne    8049ffe <z_cbvprintf_impl+0x523>
			} else if (conv->flag_space) {
 8049ff7:	01 c0                	add    %eax,%eax
 8049ff9:	83 e0 20             	and    $0x20,%eax
 8049ffc:	89 c6                	mov    %eax,%esi

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
 8049ffe:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804a001:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			if (sint < 0) {
 804a004:	85 d2                	test   %edx,%edx
 804a006:	79 16                	jns    804a01e <z_cbvprintf_impl+0x543>
				sign = '-';
				value->uint = (uint_value_type)-sint;
 804a008:	f7 d8                	neg    %eax
				sign = '-';
 804a00a:	be 2d 00 00 00       	mov    $0x2d,%esi
				value->uint = (uint_value_type)-sint;
 804a00f:	83 d2 00             	adc    $0x0,%edx
 804a012:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804a015:	f7 da                	neg    %edx
 804a017:	89 55 b8             	mov    %edx,-0x48(%ebp)
 804a01a:	eb 02                	jmp    804a01e <z_cbvprintf_impl+0x543>
		switch (conv->specifier) {
 804a01c:	31 f6                	xor    %esi,%esi
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
 804a01e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 804a021:	50                   	push   %eax
 804a022:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 804a025:	50                   	push   %eax
 804a026:	8d 45 ce             	lea    -0x32(%ebp),%eax
 804a029:	52                   	push   %edx
 804a02a:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804a02d:	50                   	push   %eax
 804a02e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804a031:	e8 ca f9 ff ff       	call   8049a00 <encode_uint>
 804a036:	83 c4 10             	add    $0x10,%esp
 804a039:	89 45 a0             	mov    %eax,-0x60(%ebp)
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
 804a03c:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
 804a040:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804a043:	0f 88 a2 00 00 00    	js     804a0eb <z_cbvprintf_impl+0x610>
				size_t len = bpe - bps;
 804a049:	89 c2                	mov    %eax,%edx

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
 804a04b:	80 65 c0 bf          	andb   $0xbf,-0x40(%ebp)
				size_t len = bpe - bps;
 804a04f:	2b 55 a0             	sub    -0x60(%ebp),%edx
		const char *bpe = buf + sizeof(buf);
 804a052:	89 45 8c             	mov    %eax,-0x74(%ebp)

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
 804a055:	39 55 90             	cmp    %edx,-0x70(%ebp)
 804a058:	0f 86 90 00 00 00    	jbe    804a0ee <z_cbvprintf_impl+0x613>
					conv->pad0_value = precision - (int)len;
 804a05e:	8b 4d 90             	mov    -0x70(%ebp),%ecx
 804a061:	29 d1                	sub    %edx,%ecx
 804a063:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
 804a066:	e9 83 00 00 00       	jmp    804a0ee <z_cbvprintf_impl+0x613>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
 804a06b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804a06e:	85 c0                	test   %eax,%eax
 804a070:	0f 84 83 00 00 00    	je     804a0f9 <z_cbvprintf_impl+0x61e>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 804a076:	8d 75 e4             	lea    -0x1c(%ebp),%esi
 804a079:	51                   	push   %ecx
 804a07a:	31 d2                	xor    %edx,%edx
 804a07c:	51                   	push   %ecx
 804a07d:	8d 4d ce             	lea    -0x32(%ebp),%ecx
 804a080:	56                   	push   %esi
		char sign = 0;
 804a081:	31 f6                	xor    %esi,%esi
				bps = encode_uint((uintptr_t)value->ptr, conv,
 804a083:	51                   	push   %ecx
 804a084:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 804a087:	e8 74 f9 ff ff       	call   8049a00 <encode_uint>
 804a08c:	83 c4 10             	add    $0x10,%esp
 804a08f:	89 45 a0             	mov    %eax,-0x60(%ebp)
						  buf, bpe);

				/* Use 0x prefix */
				conv->altform_0c = true;
 804a092:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
 804a096:	66 25 ef 00          	and    $0xef,%ax
 804a09a:	66 0d 10 78          	or     $0x7810,%ax
 804a09e:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
				conv->specifier = 'x';

				goto prec_int_pad0;
 804a0a2:	eb 98                	jmp    804a03c <z_cbvprintf_impl+0x561>
	switch ((enum length_mod_enum)conv->length_mod) {
 804a0a4:	80 7d a0 07          	cmpb   $0x7,-0x60(%ebp)
			bpe = bps + 5;

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
 804a0a8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	switch ((enum length_mod_enum)conv->length_mod) {
 804a0ab:	0f 87 e4 01 00 00    	ja     804a295 <z_cbvprintf_impl+0x7ba>
 804a0b1:	0f b6 55 a0          	movzbl -0x60(%ebp),%edx
 804a0b5:	ff 24 95 a4 e0 04 08 	jmp    *0x804e0a4(,%edx,4)
		*(signed char *)dp = (signed char)count;
 804a0bc:	8a 55 a4             	mov    -0x5c(%ebp),%dl
 804a0bf:	88 10                	mov    %dl,(%eax)
		break;
 804a0c1:	e9 cf 01 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
		*(short *)dp = (short)count;
 804a0c6:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804a0c9:	66 89 38             	mov    %di,(%eax)
		break;
 804a0cc:	e9 c4 01 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
		*(intmax_t *)dp = (intmax_t)count;
 804a0d1:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804a0d4:	89 38                	mov    %edi,(%eax)
 804a0d6:	c1 ff 1f             	sar    $0x1f,%edi
 804a0d9:	89 78 04             	mov    %edi,0x4(%eax)
		break;
 804a0dc:	e9 b4 01 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 804a0e1:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804a0e4:	89 38                	mov    %edi,(%eax)
		break;
 804a0e6:	e9 aa 01 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
		const char *bpe = buf + sizeof(buf);
 804a0eb:	89 45 8c             	mov    %eax,-0x74(%ebp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
 804a0ee:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 804a0f2:	75 15                	jne    804a109 <z_cbvprintf_impl+0x62e>
 804a0f4:	e9 9c 01 00 00       	jmp    804a295 <z_cbvprintf_impl+0x7ba>
			bps = "(nil)";
 804a0f9:	c7 45 a0 b5 e1 04 08 	movl   $0x804e1b5,-0x60(%ebp)
			bpe = bps + 5;
 804a100:	c7 45 8c ba e1 04 08 	movl   $0x804e1ba,-0x74(%ebp)
 804a107:	31 f6                	xor    %esi,%esi
		 */
		size_t nj_len = (bpe - bps);
		int pad_len = 0;

		if (sign != 0) {
			nj_len += 1U;
 804a109:	89 f1                	mov    %esi,%ecx
		}

		if (conv->altform_0c) {
 804a10b:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		size_t nj_len = (bpe - bps);
 804a10e:	8b 45 8c             	mov    -0x74(%ebp),%eax
 804a111:	2b 45 a0             	sub    -0x60(%ebp),%eax
			nj_len += 1U;
 804a114:	80 f9 01             	cmp    $0x1,%cl
 804a117:	83 d8 ff             	sbb    $0xffffffff,%eax
		if (conv->altform_0c) {
 804a11a:	f6 c2 10             	test   $0x10,%dl
 804a11d:	74 05                	je     804a124 <z_cbvprintf_impl+0x649>
			nj_len += 2U;
 804a11f:	83 c0 02             	add    $0x2,%eax
 804a122:	eb 0b                	jmp    804a12f <z_cbvprintf_impl+0x654>
		} else if (conv->altform_0) {
 804a124:	89 d1                	mov    %edx,%ecx
 804a126:	83 e1 08             	and    $0x8,%ecx
			nj_len += 1U;
 804a129:	80 f9 01             	cmp    $0x1,%cl
 804a12c:	83 d8 ff             	sbb    $0xffffffff,%eax
		}

		nj_len += conv->pad0_value;
 804a12f:	03 45 c4             	add    -0x3c(%ebp),%eax
		if (conv->pad_fp) {
 804a132:	80 e2 40             	and    $0x40,%dl
 804a135:	74 03                	je     804a13a <z_cbvprintf_impl+0x65f>
			nj_len += conv->pad0_pre_exp;
 804a137:	03 45 c8             	add    -0x38(%ebp),%eax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
 804a13a:	85 ff                	test   %edi,%edi
 804a13c:	7e 7e                	jle    804a1bc <z_cbvprintf_impl+0x6e1>
			width -= (int)nj_len;
 804a13e:	29 c7                	sub    %eax,%edi

			if (!conv->flag_dash) {
 804a140:	8a 45 c0             	mov    -0x40(%ebp),%al
			width -= (int)nj_len;
 804a143:	89 7d 90             	mov    %edi,-0x70(%ebp)
			if (!conv->flag_dash) {
 804a146:	a8 04                	test   $0x4,%al
 804a148:	75 6f                	jne    804a1b9 <z_cbvprintf_impl+0x6de>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
 804a14a:	a8 40                	test   $0x40,%al
 804a14c:	74 2b                	je     804a179 <z_cbvprintf_impl+0x69e>
					if (sign != 0) {
 804a14e:	89 f0                	mov    %esi,%eax
 804a150:	84 c0                	test   %al,%al
 804a152:	74 2c                	je     804a180 <z_cbvprintf_impl+0x6a5>
						OUTC(sign);
 804a154:	56                   	push   %esi
 804a155:	56                   	push   %esi
 804a156:	0f be f0             	movsbl %al,%esi
 804a159:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a15c:	ff 75 98             	push   -0x68(%ebp)
 804a15f:	56                   	push   %esi
 804a160:	ff d0                	call   *%eax
 804a162:	83 c4 10             	add    $0x10,%esp
 804a165:	85 c0                	test   %eax,%eax
 804a167:	0f 88 47 01 00 00    	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 804a16d:	ff 45 a4             	incl   -0x5c(%ebp)
						sign = 0;
					}
					pad = '0';
 804a170:	ba 30 00 00 00       	mov    $0x30,%edx
						OUTC(sign);
 804a175:	31 f6                	xor    %esi,%esi
 804a177:	eb 0c                	jmp    804a185 <z_cbvprintf_impl+0x6aa>
				char pad = ' ';
 804a179:	ba 20 00 00 00       	mov    $0x20,%edx
 804a17e:	eb 05                	jmp    804a185 <z_cbvprintf_impl+0x6aa>
					pad = '0';
 804a180:	ba 30 00 00 00       	mov    $0x30,%edx
 804a185:	8b 7d 90             	mov    -0x70(%ebp),%edi
 804a188:	8b 45 90             	mov    -0x70(%ebp),%eax
 804a18b:	89 f9                	mov    %edi,%ecx
 804a18d:	03 45 a4             	add    -0x5c(%ebp),%eax
 804a190:	29 f8                	sub    %edi,%eax
				}

				while (width-- > 0) {
 804a192:	4f                   	dec    %edi
 804a193:	85 c9                	test   %ecx,%ecx
 804a195:	7e 1d                	jle    804a1b4 <z_cbvprintf_impl+0x6d9>
					OUTC(pad);
 804a197:	51                   	push   %ecx
 804a198:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a19b:	51                   	push   %ecx
 804a19c:	ff 75 98             	push   -0x68(%ebp)
 804a19f:	52                   	push   %edx
 804a1a0:	89 55 88             	mov    %edx,-0x78(%ebp)
 804a1a3:	ff d0                	call   *%eax
 804a1a5:	8b 55 88             	mov    -0x78(%ebp),%edx
 804a1a8:	83 c4 10             	add    $0x10,%esp
 804a1ab:	85 c0                	test   %eax,%eax
 804a1ad:	79 d9                	jns    804a188 <z_cbvprintf_impl+0x6ad>
 804a1af:	e9 00 01 00 00       	jmp    804a2b4 <z_cbvprintf_impl+0x7d9>
 804a1b4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804a1b7:	eb 03                	jmp    804a1bc <z_cbvprintf_impl+0x6e1>
			width -= (int)nj_len;
 804a1b9:	8b 7d 90             	mov    -0x70(%ebp),%edi
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
 804a1bc:	89 f0                	mov    %esi,%eax
 804a1be:	84 c0                	test   %al,%al
 804a1c0:	74 1c                	je     804a1de <z_cbvprintf_impl+0x703>
			OUTC(sign);
 804a1c2:	0f be f0             	movsbl %al,%esi
 804a1c5:	52                   	push   %edx
 804a1c6:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a1c9:	52                   	push   %edx
 804a1ca:	ff 75 98             	push   -0x68(%ebp)
 804a1cd:	56                   	push   %esi
 804a1ce:	ff d0                	call   *%eax
 804a1d0:	83 c4 10             	add    $0x10,%esp
 804a1d3:	85 c0                	test   %eax,%eax
 804a1d5:	0f 88 d9 00 00 00    	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 804a1db:	ff 45 a4             	incl   -0x5c(%ebp)
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
 804a1de:	8a 45 c2             	mov    -0x3e(%ebp),%al
 804a1e1:	a8 10                	test   $0x10,%al
 804a1e3:	75 04                	jne    804a1e9 <z_cbvprintf_impl+0x70e>
 804a1e5:	a8 08                	test   $0x8,%al
 804a1e7:	74 1a                	je     804a203 <z_cbvprintf_impl+0x728>
				OUTC('0');
 804a1e9:	56                   	push   %esi
 804a1ea:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a1ed:	56                   	push   %esi
 804a1ee:	ff 75 98             	push   -0x68(%ebp)
 804a1f1:	6a 30                	push   $0x30
 804a1f3:	ff d0                	call   *%eax
 804a1f5:	83 c4 10             	add    $0x10,%esp
 804a1f8:	85 c0                	test   %eax,%eax
 804a1fa:	0f 88 b4 00 00 00    	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 804a200:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			if (conv->altform_0c) {
 804a203:	f6 45 c2 10          	testb  $0x10,-0x3e(%ebp)
 804a207:	74 1d                	je     804a226 <z_cbvprintf_impl+0x74b>
				OUTC(conv->specifier);
 804a209:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
 804a20d:	51                   	push   %ecx
 804a20e:	51                   	push   %ecx
 804a20f:	ff 75 98             	push   -0x68(%ebp)
 804a212:	50                   	push   %eax
 804a213:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a216:	ff d0                	call   *%eax
 804a218:	83 c4 10             	add    $0x10,%esp
 804a21b:	85 c0                	test   %eax,%eax
 804a21d:	0f 88 91 00 00 00    	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 804a223:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			pad_len = conv->pad0_value;
 804a226:	8b 55 c4             	mov    -0x3c(%ebp),%edx
			while (pad_len-- > 0) {
 804a229:	8b 75 a4             	mov    -0x5c(%ebp),%esi
 804a22c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a22f:	01 d0                	add    %edx,%eax
 804a231:	29 f0                	sub    %esi,%eax
 804a233:	85 c0                	test   %eax,%eax
 804a235:	7e 1c                	jle    804a253 <z_cbvprintf_impl+0x778>
 804a237:	89 55 90             	mov    %edx,-0x70(%ebp)
				OUTC('0');
 804a23a:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a23d:	52                   	push   %edx
 804a23e:	52                   	push   %edx
 804a23f:	ff 75 98             	push   -0x68(%ebp)
 804a242:	6a 30                	push   $0x30
 804a244:	ff d0                	call   *%eax
 804a246:	83 c4 10             	add    $0x10,%esp
 804a249:	85 c0                	test   %eax,%eax
 804a24b:	78 67                	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 804a24d:	8b 55 90             	mov    -0x70(%ebp),%edx
 804a250:	46                   	inc    %esi
 804a251:	eb d9                	jmp    804a22c <z_cbvprintf_impl+0x751>
			}

			OUTS(bps, bpe);
 804a253:	83 ec 0c             	sub    $0xc,%esp
 804a256:	8b 4d a0             	mov    -0x60(%ebp),%ecx
 804a259:	8b 55 98             	mov    -0x68(%ebp),%edx
 804a25c:	ff 75 8c             	push   -0x74(%ebp)
 804a25f:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a262:	e8 17 f7 ff ff       	call   804997e <outs>
 804a267:	83 c4 10             	add    $0x10,%esp
 804a26a:	85 c0                	test   %eax,%eax
 804a26c:	78 46                	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 804a26e:	01 c6                	add    %eax,%esi
 804a270:	89 75 a4             	mov    %esi,-0x5c(%ebp)
		}

		/* Finish left justification */
		while (width > 0) {
 804a273:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804a276:	2b 45 a4             	sub    -0x5c(%ebp),%eax
 804a279:	85 c0                	test   %eax,%eax
 804a27b:	7e 18                	jle    804a295 <z_cbvprintf_impl+0x7ba>
			OUTC(' ');
 804a27d:	50                   	push   %eax
 804a27e:	50                   	push   %eax
 804a27f:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a282:	ff 75 98             	push   -0x68(%ebp)
 804a285:	6a 20                	push   $0x20
 804a287:	ff d0                	call   *%eax
 804a289:	83 c4 10             	add    $0x10,%esp
 804a28c:	85 c0                	test   %eax,%eax
 804a28e:	78 24                	js     804a2b4 <z_cbvprintf_impl+0x7d9>
 804a290:	ff 45 a4             	incl   -0x5c(%ebp)
 804a293:	eb de                	jmp    804a273 <z_cbvprintf_impl+0x798>
 804a295:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804a298:	89 de                	mov    %ebx,%esi
 804a29a:	89 45 8c             	mov    %eax,-0x74(%ebp)
 804a29d:	e9 69 f8 ff ff       	jmp    8049b0b <z_cbvprintf_impl+0x30>
			--width;
		}
	}

	return count;
 804a2a2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a2a5:	eb 0d                	jmp    804a2b4 <z_cbvprintf_impl+0x7d9>
					value->uint = va_arg(ap, unsigned long);
 804a2a7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804a2aa:	89 cb                	mov    %ecx,%ebx
 804a2ac:	89 55 b8             	mov    %edx,-0x48(%ebp)
			} else if (length_mod == LENGTH_H) {
 804a2af:	e9 68 fc ff ff       	jmp    8049f1c <z_cbvprintf_impl+0x441>
#undef OUTS
#undef OUTC
}
 804a2b4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a2b7:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 804a2be:	74 05                	je     804a2c5 <z_cbvprintf_impl+0x7ea>
 804a2c0:	e8 0b ef ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804a2c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a2c8:	5b                   	pop    %ebx
 804a2c9:	5e                   	pop    %esi
 804a2ca:	5f                   	pop    %edi
 804a2cb:	5d                   	pop    %ebp
 804a2cc:	c3                   	ret    

0804a2cd <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
 804a2cd:	55                   	push   %ebp
 804a2ce:	89 e5                	mov    %esp,%ebp
 804a2d0:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 804a2d3:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 804a2d6:	50                   	push   %eax
 804a2d7:	ff 75 08             	push   0x8(%ebp)
 804a2da:	e8 d4 f4 ff ff       	call   80497b3 <vprintk>
 804a2df:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 804a2e2:	c9                   	leave  
 804a2e3:	c3                   	ret    

0804a2e4 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
 804a2e4:	c3                   	ret    

0804a2e5 <sys_trace_isr_enter>:
 *
 * SPDX-License-Identifier: Apache-2.0
 */


void sys_trace_isr_enter(void) {}
 804a2e5:	c3                   	ret    

0804a2e6 <sys_trace_isr_exit>:
 804a2e6:	c3                   	ret    

0804a2e7 <sys_trace_idle>:
 804a2e7:	c3                   	ret    

0804a2e8 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
 804a2e8:	55                   	push   %ebp
 804a2e9:	89 e5                	mov    %esp,%ebp
 804a2eb:	83 ec 08             	sub    $0x8,%esp
	sys_trace_idle();
 804a2ee:	e8 f4 ff ff ff       	call   804a2e7 <sys_trace_idle>
	posix_irq_full_unlock();
 804a2f3:	e8 7e 11 00 00       	call   804b476 <posix_irq_full_unlock>
	posix_halt_cpu();
}
 804a2f8:	c9                   	leave  
	posix_halt_cpu();
 804a2f9:	e9 45 06 00 00       	jmp    804a943 <posix_halt_cpu>

0804a2fe <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
 804a2fe:	55                   	push   %ebp
 804a2ff:	89 e5                	mov    %esp,%ebp
 804a301:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
 804a304:	68 bb e1 04 08       	push   $0x804e1bb
 804a309:	e8 d6 15 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804a30e:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804a311:	6a 15                	push   $0x15
 804a313:	68 d7 e1 04 08       	push   $0x804e1d7
 804a318:	68 90 e1 04 08       	push   $0x804e190
 804a31d:	e8 c2 15 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804a322:	83 c4 10             	add    $0x10,%esp

0804a325 <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
 804a325:	e9 5e 11 00 00       	jmp    804b488 <posix_irq_enable>

0804a32a <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
 804a32a:	85 c0                	test   %eax,%eax
 804a32c:	74 16                	je     804a344 <pc_safe_call+0x1a>
{
 804a32e:	55                   	push   %ebp
 804a32f:	89 e5                	mov    %esp,%ebp
 804a331:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a334:	52                   	push   %edx
 804a335:	68 02 e2 04 08       	push   $0x804e202
 804a33a:	e8 a5 15 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804a33f:	83 c4 10             	add    $0x10,%esp
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
 804a342:	c9                   	leave  
 804a343:	c3                   	ret    
 804a344:	c3                   	ret    

0804a345 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
 804a345:	55                   	push   %ebp
 804a346:	89 e5                	mov    %esp,%ebp
 804a348:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804a34b:	68 e4 18 05 08       	push   $0x80518e4
 804a350:	e8 db ed ff ff       	call   8049130 <pthread_mutex_unlock@plt>
 804a355:	83 c4 10             	add    $0x10,%esp
 804a358:	ba 1c e2 04 08       	mov    $0x804e21c,%edx
 804a35d:	e8 c8 ff ff ff       	call   804a32a <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804a362:	e8 39 ef ff ff       	call   80492a0 <pthread_self@plt>
 804a367:	83 ec 0c             	sub    $0xc,%esp
 804a36a:	50                   	push   %eax
 804a36b:	e8 10 ee ff ff       	call   8049180 <pthread_detach@plt>
 804a370:	83 c4 10             	add    $0x10,%esp
}
 804a373:	c9                   	leave  
 804a374:	c3                   	ret    

0804a375 <abort_tail>:
{
 804a375:	55                   	push   %ebp
	threads_table[this_th_nbr].running = false;
 804a376:	6b c0 14             	imul   $0x14,%eax,%eax
{
 804a379:	89 e5                	mov    %esp,%ebp
 804a37b:	83 ec 08             	sub    $0x8,%esp
	threads_table[this_th_nbr].running = false;
 804a37e:	03 05 00 19 05 08    	add    0x8051900,%eax
 804a384:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	threads_table[this_th_nbr].state = ABORTED;
 804a388:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	posix_preexit_cleanup();
 804a38e:	e8 b2 ff ff ff       	call   804a345 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804a393:	83 ec 0c             	sub    $0xc,%esp
 804a396:	6a 00                	push   $0x0
 804a398:	e8 b3 ec ff ff       	call   8049050 <pthread_exit@plt>

0804a39d <posix_wait_until_allowed>:
{
 804a39d:	55                   	push   %ebp
 804a39e:	89 e5                	mov    %esp,%ebp
 804a3a0:	56                   	push   %esi
	threads_table[this_th_nbr].running = false;
 804a3a1:	6b f0 14             	imul   $0x14,%eax,%esi
{
 804a3a4:	53                   	push   %ebx
 804a3a5:	89 c3                	mov    %eax,%ebx
	threads_table[this_th_nbr].running = false;
 804a3a7:	a1 00 19 05 08       	mov    0x8051900,%eax
 804a3ac:	c6 44 30 04 00       	movb   $0x0,0x4(%eax,%esi,1)
	while (this_th_nbr != currently_allowed_thread) {
 804a3b1:	39 1d e0 18 05 08    	cmp    %ebx,0x80518e0
 804a3b7:	74 2a                	je     804a3e3 <posix_wait_until_allowed+0x46>
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804a3b9:	50                   	push   %eax
 804a3ba:	50                   	push   %eax
 804a3bb:	68 e4 18 05 08       	push   $0x80518e4
 804a3c0:	68 a0 13 05 08       	push   $0x80513a0
 804a3c5:	e8 36 ee ff ff       	call   8049200 <pthread_cond_wait@plt>
		if (threads_table &&
 804a3ca:	a1 00 19 05 08       	mov    0x8051900,%eax
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804a3cf:	83 c4 10             	add    $0x10,%esp
		if (threads_table &&
 804a3d2:	85 c0                	test   %eax,%eax
 804a3d4:	74 db                	je     804a3b1 <posix_wait_until_allowed+0x14>
 804a3d6:	83 3c 30 02          	cmpl   $0x2,(%eax,%esi,1)
 804a3da:	75 d5                	jne    804a3b1 <posix_wait_until_allowed+0x14>
			abort_tail(this_th_nbr);
 804a3dc:	89 d8                	mov    %ebx,%eax
 804a3de:	e8 92 ff ff ff       	call   804a375 <abort_tail>
	threads_table[this_th_nbr].running = true;
 804a3e3:	a1 00 19 05 08       	mov    0x8051900,%eax
 804a3e8:	c6 44 30 04 01       	movb   $0x1,0x4(%eax,%esi,1)
}
 804a3ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804a3f0:	5b                   	pop    %ebx
 804a3f1:	5e                   	pop    %esi
 804a3f2:	5d                   	pop    %ebp
 804a3f3:	c3                   	ret    

0804a3f4 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
 804a3f4:	80 3d 71 19 05 08 00 	cmpb   $0x0,0x8051971
 804a3fb:	74 2b                	je     804a428 <posix_cleanup_handler+0x34>
{
 804a3fd:	55                   	push   %ebp
 804a3fe:	89 e5                	mov    %esp,%ebp
 804a400:	83 ec 14             	sub    $0x14,%esp
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804a403:	68 e4 18 05 08       	push   $0x80518e4
 804a408:	e8 23 ed ff ff       	call   8049130 <pthread_mutex_unlock@plt>
 804a40d:	83 c4 10             	add    $0x10,%esp
 804a410:	ba 1c e2 04 08       	mov    $0x804e21c,%edx
 804a415:	e8 10 ff ff ff       	call   804a32a <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804a41a:	e8 81 ee ff ff       	call   80492a0 <pthread_self@plt>
 804a41f:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a422:	c9                   	leave  
	pthread_detach(pthread_self());
 804a423:	e9 58 ed ff ff       	jmp    8049180 <pthread_detach@plt>
 804a428:	c3                   	ret    

0804a429 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
 804a429:	55                   	push   %ebp
 804a42a:	89 e5                	mov    %esp,%ebp
 804a42c:	83 ec 54             	sub    $0x54,%esp
 804a42f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a432:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 804a435:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a43b:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a43e:	31 c0                	xor    %eax,%eax

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a440:	68 e4 18 05 08       	push   $0x80518e4
 804a445:	e8 76 ed ff ff       	call   80491c0 <pthread_mutex_lock@plt>
 804a44a:	83 c4 10             	add    $0x10,%esp
 804a44d:	ba 3f e2 04 08       	mov    $0x804e23f,%edx
 804a452:	e8 d3 fe ff ff       	call   804a32a <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
 804a457:	83 3d 00 19 05 08 00 	cmpl   $0x0,0x8051900
 804a45e:	75 17                	jne    804a477 <posix_thread_starter+0x4e>
		posix_cleanup_handler(arg);
 804a460:	83 ec 0c             	sub    $0xc,%esp
 804a463:	ff 75 c4             	push   -0x3c(%ebp)
 804a466:	e8 89 ff ff ff       	call   804a3f4 <posix_cleanup_handler>
		pthread_exit(NULL);
 804a46b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a472:	e8 d9 eb ff ff       	call   8049050 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
 804a477:	50                   	push   %eax
 804a478:	50                   	push   %eax
 804a479:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a47c:	6a 00                	push   $0x0
 804a47e:	50                   	push   %eax
 804a47f:	e8 fc ed ff ff       	call   8049280 <__sigsetjmp@plt>
 804a484:	83 c4 10             	add    $0x10,%esp
 804a487:	85 c0                	test   %eax,%eax
 804a489:	74 16                	je     804a4a1 <posix_thread_starter+0x78>
 804a48b:	83 ec 0c             	sub    $0xc,%esp
 804a48e:	ff 75 c4             	push   -0x3c(%ebp)
 804a491:	e8 5e ff ff ff       	call   804a3f4 <posix_cleanup_handler>
 804a496:	83 c4 10             	add    $0x10,%esp
 804a499:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a49c:	e8 7f ed ff ff       	call   8049220 <__pthread_unwind_next@plt>
 804a4a1:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a4a4:	e8 97 ed ff ff       	call   8049240 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
 804a4a9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a4ac:	e8 ec fe ff ff       	call   804a39d <posix_wait_until_allowed>

	posix_new_thread_pre_start();
 804a4b1:	e8 76 03 00 00       	call   804a82c <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
 804a4b6:	6b 45 c4 14          	imul   $0x14,-0x3c(%ebp),%eax
 804a4ba:	03 05 00 19 05 08    	add    0x8051900,%eax
 804a4c0:	8b 40 10             	mov    0x10(%eax),%eax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
 804a4c3:	ff 70 0c             	push   0xc(%eax)
 804a4c6:	ff 70 08             	push   0x8(%eax)
 804a4c9:	ff 70 04             	push   0x4(%eax)
 804a4cc:	ff 30                	push   (%eax)
 804a4ce:	e8 16 f3 ff ff       	call   80497e9 <z_thread_entry>

0804a4d3 <posix_swap>:
{
 804a4d3:	55                   	push   %ebp
 804a4d4:	89 e5                	mov    %esp,%ebp
 804a4d6:	53                   	push   %ebx
 804a4d7:	83 ec 10             	sub    $0x10,%esp
	currently_allowed_thread = next_allowed_th;
 804a4da:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804a4dd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a4e0:	68 a0 13 05 08       	push   $0x80513a0
	currently_allowed_thread = next_allowed_th;
 804a4e5:	a3 e0 18 05 08       	mov    %eax,0x80518e0
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a4ea:	e8 71 ed ff ff       	call   8049260 <pthread_cond_broadcast@plt>
 804a4ef:	83 c4 10             	add    $0x10,%esp
 804a4f2:	ba 60 e2 04 08       	mov    $0x804e260,%edx
 804a4f7:	e8 2e fe ff ff       	call   804a32a <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
 804a4fc:	6b c3 14             	imul   $0x14,%ebx,%eax
 804a4ff:	03 05 00 19 05 08    	add    0x8051900,%eax
 804a505:	83 38 02             	cmpl   $0x2,(%eax)
		abort_tail(this_th_nbr);
 804a508:	89 d8                	mov    %ebx,%eax
	if (threads_table[this_th_nbr].state == ABORTING) {
 804a50a:	75 05                	jne    804a511 <posix_swap+0x3e>
		abort_tail(this_th_nbr);
 804a50c:	e8 64 fe ff ff       	call   804a375 <abort_tail>
}
 804a511:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804a514:	c9                   	leave  
		posix_wait_until_allowed(this_th_nbr);
 804a515:	e9 83 fe ff ff       	jmp    804a39d <posix_wait_until_allowed>

0804a51a <posix_main_thread_start>:
{
 804a51a:	55                   	push   %ebp
 804a51b:	89 e5                	mov    %esp,%ebp
 804a51d:	83 ec 14             	sub    $0x14,%esp
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a520:	68 a0 13 05 08       	push   $0x80513a0
	currently_allowed_thread = next_allowed_th;
 804a525:	8b 45 08             	mov    0x8(%ebp),%eax
 804a528:	a3 e0 18 05 08       	mov    %eax,0x80518e0
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a52d:	e8 2e ed ff ff       	call   8049260 <pthread_cond_broadcast@plt>
 804a532:	83 c4 10             	add    $0x10,%esp
 804a535:	ba 60 e2 04 08       	mov    $0x804e260,%edx
 804a53a:	e8 eb fd ff ff       	call   804a32a <pc_safe_call>
	posix_preexit_cleanup();
 804a53f:	e8 01 fe ff ff       	call   804a345 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804a544:	83 ec 0c             	sub    $0xc,%esp
 804a547:	6a 00                	push   $0x0
 804a549:	e8 02 eb ff ff       	call   8049050 <pthread_exit@plt>

0804a54e <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
 804a54e:	55                   	push   %ebp
	for (int i = 0; i < threads_table_size; i++) {
 804a54f:	31 d2                	xor    %edx,%edx
{
 804a551:	89 e5                	mov    %esp,%ebp
 804a553:	57                   	push   %edi
 804a554:	56                   	push   %esi
 804a555:	53                   	push   %ebx
 804a556:	83 ec 0c             	sub    $0xc,%esp
 804a559:	8b 75 08             	mov    0x8(%ebp),%esi
	for (int i = 0; i < threads_table_size; i++) {
 804a55c:	a1 04 19 05 08       	mov    0x8051904,%eax
		if ((threads_table[i].state == NOTUSED)
 804a561:	8b 0d 00 19 05 08    	mov    0x8051900,%ecx
	for (int i = 0; i < threads_table_size; i++) {
 804a567:	39 c2                	cmp    %eax,%edx
 804a569:	7d 0c                	jge    804a577 <posix_new_thread+0x29>
		if ((threads_table[i].state == NOTUSED)
 804a56b:	6b da 14             	imul   $0x14,%edx,%ebx
 804a56e:	83 3c 19 00          	cmpl   $0x0,(%ecx,%ebx,1)
 804a572:	74 50                	je     804a5c4 <posix_new_thread+0x76>
	for (int i = 0; i < threads_table_size; i++) {
 804a574:	42                   	inc    %edx
 804a575:	eb f0                	jmp    804a567 <posix_new_thread+0x19>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
 804a577:	83 c0 40             	add    $0x40,%eax
	threads_table = realloc(threads_table,
 804a57a:	52                   	push   %edx
 804a57b:	6b c0 14             	imul   $0x14,%eax,%eax
 804a57e:	52                   	push   %edx
 804a57f:	50                   	push   %eax
 804a580:	51                   	push   %ecx
 804a581:	e8 fa ea ff ff       	call   8049080 <realloc@plt>
 804a586:	83 c4 10             	add    $0x10,%esp
 804a589:	a3 00 19 05 08       	mov    %eax,0x8051900
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804a58e:	85 c0                	test   %eax,%eax
 804a590:	75 10                	jne    804a5a2 <posix_new_thread+0x54>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804a592:	83 ec 0c             	sub    $0xc,%esp
 804a595:	68 86 e2 04 08       	push   $0x804e286
 804a59a:	e8 45 13 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804a59f:	83 c4 10             	add    $0x10,%esp
	(void)memset(&threads_table[threads_table_size], 0,
 804a5a2:	8b 15 04 19 05 08    	mov    0x8051904,%edx
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  */
__fortify_function void *
__NTH (memset (void *__dest, int __ch, size_t __len))
{
  return __builtin___memset_chk (__dest, __ch, __len,
 804a5a8:	31 c0                	xor    %eax,%eax
 804a5aa:	b9 40 01 00 00       	mov    $0x140,%ecx
 804a5af:	6b da 14             	imul   $0x14,%edx,%ebx
 804a5b2:	03 1d 00 19 05 08    	add    0x8051900,%ebx
 804a5b8:	89 df                	mov    %ebx,%edi
 804a5ba:	f3 ab                	rep stos %eax,%es:(%edi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
 804a5bc:	8d 42 40             	lea    0x40(%edx),%eax
 804a5bf:	a3 04 19 05 08       	mov    %eax,0x8051904
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a5c4:	8b 0d fc 18 05 08    	mov    0x80518fc,%ecx
	threads_table[t_slot].state = USED;
 804a5ca:	6b c2 14             	imul   $0x14,%edx,%eax
 804a5cd:	03 05 00 19 05 08    	add    0x8051900,%eax
	threads_table[t_slot].t_status = ptr;
 804a5d3:	89 70 10             	mov    %esi,0x10(%eax)
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a5d6:	83 c0 08             	add    $0x8,%eax
	threads_table[t_slot].state = USED;
 804a5d9:	c7 40 f8 01 00 00 00 	movl   $0x1,-0x8(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a5e0:	8d 59 01             	lea    0x1(%ecx),%ebx
	threads_table[t_slot].running = false;
 804a5e3:	c6 40 fc 00          	movb   $0x0,-0x4(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a5e7:	89 48 04             	mov    %ecx,0x4(%eax)
	ptr->thread_idx = t_slot;
 804a5ea:	89 56 10             	mov    %edx,0x10(%esi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a5ed:	52                   	push   %edx
 804a5ee:	68 29 a4 04 08       	push   $0x804a429
 804a5f3:	6a 00                	push   $0x0
 804a5f5:	50                   	push   %eax
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a5f6:	89 1d fc 18 05 08    	mov    %ebx,0x80518fc
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a5fc:	e8 cf ea ff ff       	call   80490d0 <pthread_create@plt>
 804a601:	83 c4 10             	add    $0x10,%esp
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
 804a604:	8d 65 f4             	lea    -0xc(%ebp),%esp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a607:	ba ae e2 04 08       	mov    $0x804e2ae,%edx
}
 804a60c:	5b                   	pop    %ebx
 804a60d:	5e                   	pop    %esi
 804a60e:	5f                   	pop    %edi
 804a60f:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a610:	e9 15 fd ff ff       	jmp    804a32a <pc_safe_call>

0804a615 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
 804a615:	55                   	push   %ebp
 804a616:	89 e5                	mov    %esp,%ebp
 804a618:	83 ec 10             	sub    $0x10,%esp
	thread_create_count = 0;
 804a61b:	c7 05 fc 18 05 08 00 	movl   $0x0,0x80518fc
 804a622:	00 00 00 

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804a625:	6a 14                	push   $0x14
 804a627:	6a 40                	push   $0x40
	currently_allowed_thread = -1;
 804a629:	c7 05 e0 18 05 08 ff 	movl   $0xffffffff,0x80518e0
 804a630:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804a633:	e8 68 ea ff ff       	call   80490a0 <calloc@plt>
 804a638:	83 c4 10             	add    $0x10,%esp
 804a63b:	a3 00 19 05 08       	mov    %eax,0x8051900
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804a640:	85 c0                	test   %eax,%eax
 804a642:	75 10                	jne    804a654 <posix_init_multithreading+0x3f>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804a644:	83 ec 0c             	sub    $0xc,%esp
 804a647:	68 86 e2 04 08       	push   $0x804e286
 804a64c:	e8 93 12 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804a651:	83 c4 10             	add    $0x10,%esp
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
 804a654:	c7 05 04 19 05 08 40 	movl   $0x40,0x8051904
 804a65b:	00 00 00 


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a65e:	83 ec 0c             	sub    $0xc,%esp
 804a661:	68 e4 18 05 08       	push   $0x80518e4
 804a666:	e8 55 eb ff ff       	call   80491c0 <pthread_mutex_lock@plt>
 804a66b:	83 c4 10             	add    $0x10,%esp
 804a66e:	ba 3f e2 04 08       	mov    $0x804e23f,%edx
}
 804a673:	c9                   	leave  
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a674:	e9 b1 fc ff ff       	jmp    804a32a <pc_safe_call>

0804a679 <posix_core_clean_up>:
 *
 */
void posix_core_clean_up(void)
{

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
 804a679:	83 3d 00 19 05 08 00 	cmpl   $0x0,0x8051900
 804a680:	74 65                	je     804a6e7 <posix_core_clean_up+0x6e>
{
 804a682:	55                   	push   %ebp
 804a683:	89 e5                	mov    %esp,%ebp
 804a685:	53                   	push   %ebx
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;

	for (int i = 0; i < threads_table_size; i++) {
 804a686:	31 db                	xor    %ebx,%ebx
{
 804a688:	52                   	push   %edx
	terminate = true;
 804a689:	c6 05 71 19 05 08 01 	movb   $0x1,0x8051971
		if (threads_table[i].state != USED) {
 804a690:	a1 00 19 05 08       	mov    0x8051900,%eax
	for (int i = 0; i < threads_table_size; i++) {
 804a695:	39 1d 04 19 05 08    	cmp    %ebx,0x8051904
 804a69b:	7e 2f                	jle    804a6cc <posix_core_clean_up+0x53>
		if (threads_table[i].state != USED) {
 804a69d:	6b d3 14             	imul   $0x14,%ebx,%edx
 804a6a0:	01 d0                	add    %edx,%eax
 804a6a2:	83 38 01             	cmpl   $0x1,(%eax)
 804a6a5:	75 22                	jne    804a6c9 <posix_core_clean_up+0x50>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
 804a6a7:	83 ec 0c             	sub    $0xc,%esp
 804a6aa:	ff 70 08             	push   0x8(%eax)
 804a6ad:	e8 de ea ff ff       	call   8049190 <pthread_cancel@plt>
 804a6b2:	83 c4 10             	add    $0x10,%esp
 804a6b5:	85 c0                	test   %eax,%eax
 804a6b7:	74 10                	je     804a6c9 <posix_core_clean_up+0x50>
			posix_print_warning(
 804a6b9:	50                   	push   %eax
 804a6ba:	50                   	push   %eax
 804a6bb:	53                   	push   %ebx
 804a6bc:	68 12 e3 04 08       	push   $0x804e312
 804a6c1:	e8 49 12 00 00       	call   804b90f <posix_print_warning>
 804a6c6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < threads_table_size; i++) {
 804a6c9:	43                   	inc    %ebx
 804a6ca:	eb c4                	jmp    804a690 <posix_core_clean_up+0x17>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
 804a6cc:	83 ec 0c             	sub    $0xc,%esp
 804a6cf:	50                   	push   %eax
 804a6d0:	e8 0b ea ff ff       	call   80490e0 <free@plt>
	threads_table = NULL;
}
 804a6d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	free(threads_table);
 804a6d8:	83 c4 10             	add    $0x10,%esp
	threads_table = NULL;
 804a6db:	c7 05 00 19 05 08 00 	movl   $0x0,0x8051900
 804a6e2:	00 00 00 
}
 804a6e5:	c9                   	leave  
 804a6e6:	c3                   	ret    
 804a6e7:	c3                   	ret    

0804a6e8 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
 804a6e8:	55                   	push   %ebp
 804a6e9:	89 e5                	mov    %esp,%ebp
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
 804a6eb:	6b 45 08 14          	imul   $0x14,0x8(%ebp),%eax
 804a6ef:	03 05 00 19 05 08    	add    0x8051900,%eax
 804a6f5:	83 38 01             	cmpl   $0x1,(%eax)
 804a6f8:	75 06                	jne    804a700 <posix_abort_thread+0x18>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
 804a6fa:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
 804a700:	5d                   	pop    %ebp
 804a701:	c3                   	ret    

0804a702 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
 804a702:	55                   	push   %ebp
 804a703:	89 e5                	mov    %esp,%ebp
 804a705:	57                   	push   %edi
 804a706:	56                   	push   %esi
 804a707:	53                   	push   %ebx
 804a708:	83 ec 1c             	sub    $0x1c,%esp
 804a70b:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
 804a70e:	8b 5e 34             	mov    0x34(%esi),%ebx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
 804a711:	8b 7b 10             	mov    0x10(%ebx),%edi
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
 804a714:	e8 46 0d 00 00       	call   804b45f <posix_irq_lock>
 804a719:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	key = irq_lock();

	if (_current == thread) {
 804a71c:	39 35 28 18 05 08    	cmp    %esi,0x8051828
 804a722:	75 2e                	jne    804a752 <z_impl_k_thread_abort+0x50>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
 804a724:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804a728:	75 09                	jne    804a733 <z_impl_k_thread_abort+0x31>
			tstatus->aborted = 1;
 804a72a:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
 804a731:	eb 10                	jmp    804a743 <z_impl_k_thread_abort+0x41>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
 804a733:	50                   	push   %eax
 804a734:	50                   	push   %eax
 804a735:	57                   	push   %edi
 804a736:	68 46 e3 04 08       	push   $0x804e346
 804a73b:	e8 cf 11 00 00       	call   804b90f <posix_print_warning>
 804a740:	83 c4 10             	add    $0x10,%esp
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
 804a743:	6b c7 14             	imul   $0x14,%edi,%eax
 804a746:	03 05 00 19 05 08    	add    0x8051900,%eax
 804a74c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
 804a752:	83 ec 0c             	sub    $0xc,%esp
 804a755:	56                   	push   %esi
 804a756:	e8 7b 29 00 00       	call   804d0d6 <z_thread_abort>
 804a75b:	83 c4 10             	add    $0x10,%esp

	if (tstatus->aborted == 0) {
 804a75e:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804a762:	75 13                	jne    804a777 <z_impl_k_thread_abort+0x75>
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
		posix_abort_thread(thread_idx);
 804a764:	83 ec 0c             	sub    $0xc,%esp
		tstatus->aborted = 1;
 804a767:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		posix_abort_thread(thread_idx);
 804a76e:	57                   	push   %edi
 804a76f:	e8 74 ff ff ff       	call   804a6e8 <posix_abort_thread>
 804a774:	83 c4 10             	add    $0x10,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 804a777:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a77a:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a77d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a780:	5b                   	pop    %ebx
 804a781:	5e                   	pop    %esi
 804a782:	5f                   	pop    %edi
 804a783:	5d                   	pop    %ebp
	z_reschedule_irqlock(key);
 804a784:	e9 f6 22 00 00       	jmp    804ca7f <z_reschedule_irqlock>

0804a789 <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
 804a789:	55                   	push   %ebp
 804a78a:	89 e5                	mov    %esp,%ebp
 804a78c:	83 ec 10             	sub    $0x10,%esp
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
 804a78f:	a1 28 18 05 08       	mov    0x8051828,%eax
 804a794:	8b 55 08             	mov    0x8(%ebp),%edx
	_current->callee_saved.retval = -EAGAIN;
 804a797:	c7 40 30 f5 ff ff ff 	movl   $0xfffffff5,0x30(%eax)
	_current->callee_saved.key = key;
 804a79e:	89 50 2c             	mov    %edx,0x2c(%eax)
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
 804a7a1:	8b 15 34 18 05 08    	mov    0x8051834,%edx

	posix_thread_status_t *this_thread_ptr  =
 804a7a7:	8b 40 34             	mov    0x34(%eax),%eax
	posix_thread_status_t *ready_thread_ptr =
 804a7aa:	8b 4a 34             	mov    0x34(%edx),%ecx
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
 804a7ad:	89 15 28 18 05 08    	mov    %edx,0x8051828
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
 804a7b3:	ff 70 10             	push   0x10(%eax)
 804a7b6:	ff 71 10             	push   0x10(%ecx)
 804a7b9:	e8 15 fd ff ff       	call   804a4d3 <posix_swap>
 804a7be:	58                   	pop    %eax
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
 804a7bf:	a1 28 18 05 08       	mov    0x8051828,%eax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
 804a7c4:	ff 70 2c             	push   0x2c(%eax)
 804a7c7:	e8 a5 0c 00 00       	call   804b471 <posix_irq_unlock>

	return _current->callee_saved.retval;
 804a7cc:	a1 28 18 05 08       	mov    0x8051828,%eax
 804a7d1:	83 c4 10             	add    $0x10,%esp
 804a7d4:	8b 40 30             	mov    0x30(%eax),%eax
}
 804a7d7:	c9                   	leave  
 804a7d8:	c3                   	ret    

0804a7d9 <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
 804a7d9:	a1 34 18 05 08       	mov    0x8051834,%eax
{
 804a7de:	55                   	push   %ebp
	posix_thread_status_t *ready_thread_ptr =
 804a7df:	8b 50 34             	mov    0x34(%eax),%edx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
 804a7e2:	a3 28 18 05 08       	mov    %eax,0x8051828
{
 804a7e7:	89 e5                	mov    %esp,%ebp

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804a7e9:	8b 42 10             	mov    0x10(%edx),%eax
 804a7ec:	89 45 08             	mov    %eax,0x8(%ebp)
} /* LCOV_EXCL_LINE */
 804a7ef:	5d                   	pop    %ebp
	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804a7f0:	e9 25 fd ff ff       	jmp    804a51a <posix_main_thread_start>

0804a7f5 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
 804a7f5:	55                   	push   %ebp
 804a7f6:	89 e5                	mov    %esp,%ebp
 804a7f8:	8b 45 10             	mov    0x10(%ebp),%eax
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
 804a7fb:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804a7fe:	89 48 e8             	mov    %ecx,-0x18(%eax)
	thread_status->arg1 = p1;
 804a801:	8b 4d 18             	mov    0x18(%ebp),%ecx
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
 804a804:	8d 50 e8             	lea    -0x18(%eax),%edx
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
 804a807:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	thread_status->arg1 = p1;
 804a80e:	89 48 ec             	mov    %ecx,-0x14(%eax)
	thread_status->arg2 = p2;
 804a811:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
 804a814:	89 48 f0             	mov    %ecx,-0x10(%eax)
	thread_status->arg3 = p3;
 804a817:	8b 4d 20             	mov    0x20(%ebp),%ecx
 804a81a:	89 48 f4             	mov    %ecx,-0xc(%eax)
#endif

	thread->callee_saved.thread_status = thread_status;
 804a81d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a820:	89 50 34             	mov    %edx,0x34(%eax)

	posix_new_thread(thread_status);
 804a823:	89 55 08             	mov    %edx,0x8(%ebp)
}
 804a826:	5d                   	pop    %ebp
	posix_new_thread(thread_status);
 804a827:	e9 22 fd ff ff       	jmp    804a54e <posix_new_thread>

0804a82c <posix_new_thread_pre_start>:

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
 804a82c:	e9 45 0c 00 00       	jmp    804b476 <posix_irq_full_unlock>

0804a831 <pc_safe_call>:
	if (unlikely(test)) {
 804a831:	85 c0                	test   %eax,%eax
 804a833:	74 16                	je     804a84b <pc_safe_call+0x1a>
{
 804a835:	55                   	push   %ebp
 804a836:	89 e5                	mov    %esp,%ebp
 804a838:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a83b:	52                   	push   %edx
 804a83c:	68 02 e2 04 08       	push   $0x804e202
 804a841:	e8 9e 10 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804a846:	83 c4 10             	add    $0x10,%esp
}
 804a849:	c9                   	leave  
 804a84a:	c3                   	ret    
 804a84b:	c3                   	ret    

0804a84c <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
 804a84c:	55                   	push   %ebp
 804a84d:	89 e5                	mov    %esp,%ebp
 804a84f:	83 ec 14             	sub    $0x14,%esp
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a852:	68 08 19 05 08       	push   $0x8051908
 804a857:	e8 64 e9 ff ff       	call   80491c0 <pthread_mutex_lock@plt>
 804a85c:	ba c2 e3 04 08       	mov    $0x804e3c2,%edx
 804a861:	83 c4 10             	add    $0x10,%esp
 804a864:	e8 c8 ff ff ff       	call   804a831 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a869:	83 ec 0c             	sub    $0xc,%esp
 804a86c:	68 08 19 05 08       	push   $0x8051908
 804a871:	e8 ba e8 ff ff       	call   8049130 <pthread_mutex_unlock@plt>
 804a876:	83 c4 10             	add    $0x10,%esp
 804a879:	ba df e3 04 08       	mov    $0x804e3df,%edx
 804a87e:	e8 ae ff ff ff       	call   804a831 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
 804a883:	e8 8d fd ff ff       	call   804a615 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
 804a888:	e8 e8 1c 00 00       	call   804c575 <z_cstart>

0804a88d <posix_is_cpu_running>:
	return !cpu_halted;
 804a88d:	a0 d8 11 05 08       	mov    0x80511d8,%al
 804a892:	83 f0 01             	xor    $0x1,%eax
 804a895:	0f b6 c0             	movzbl %al,%eax
}
 804a898:	c3                   	ret    

0804a899 <posix_change_cpu_state_and_wait>:
{
 804a899:	55                   	push   %ebp
 804a89a:	89 e5                	mov    %esp,%ebp
 804a89c:	56                   	push   %esi
 804a89d:	53                   	push   %ebx
 804a89e:	8b 75 08             	mov    0x8(%ebp),%esi
 804a8a1:	89 f3                	mov    %esi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a8a3:	83 ec 0c             	sub    $0xc,%esp
 804a8a6:	68 08 19 05 08       	push   $0x8051908
 804a8ab:	e8 10 e9 ff ff       	call   80491c0 <pthread_mutex_lock@plt>
 804a8b0:	ba c2 e3 04 08       	mov    $0x804e3c2,%edx
 804a8b5:	83 c4 10             	add    $0x10,%esp
 804a8b8:	e8 74 ff ff ff       	call   804a831 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a8bd:	83 ec 0c             	sub    $0xc,%esp
	cpu_halted = halted;
 804a8c0:	88 1d d8 11 05 08    	mov    %bl,0x80511d8
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a8c6:	68 e0 13 05 08       	push   $0x80513e0
 804a8cb:	e8 90 e9 ff ff       	call   8049260 <pthread_cond_broadcast@plt>
 804a8d0:	83 c4 10             	add    $0x10,%esp
 804a8d3:	ba fe e3 04 08       	mov    $0x804e3fe,%edx
 804a8d8:	e8 54 ff ff ff       	call   804a831 <pc_safe_call>
	while (cpu_halted == halted) {
 804a8dd:	38 1d d8 11 05 08    	cmp    %bl,0x80511d8
 804a8e3:	75 16                	jne    804a8fb <posix_change_cpu_state_and_wait+0x62>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804a8e5:	50                   	push   %eax
 804a8e6:	50                   	push   %eax
 804a8e7:	68 08 19 05 08       	push   $0x8051908
 804a8ec:	68 e0 13 05 08       	push   $0x80513e0
 804a8f1:	e8 0a e9 ff ff       	call   8049200 <pthread_cond_wait@plt>
 804a8f6:	83 c4 10             	add    $0x10,%esp
 804a8f9:	eb e2                	jmp    804a8dd <posix_change_cpu_state_and_wait+0x44>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a8fb:	83 ec 0c             	sub    $0xc,%esp
 804a8fe:	68 08 19 05 08       	push   $0x8051908
 804a903:	e8 28 e8 ff ff       	call   8049130 <pthread_mutex_unlock@plt>
 804a908:	83 c4 10             	add    $0x10,%esp
}
 804a90b:	8d 65 f8             	lea    -0x8(%ebp),%esp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a90e:	ba df e3 04 08       	mov    $0x804e3df,%edx
}
 804a913:	5b                   	pop    %ebx
 804a914:	5e                   	pop    %esi
 804a915:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a916:	e9 16 ff ff ff       	jmp    804a831 <pc_safe_call>

0804a91b <posix_interrupt_raised>:
{
 804a91b:	55                   	push   %ebp
 804a91c:	89 e5                	mov    %esp,%ebp
 804a91e:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(false);
 804a921:	6a 00                	push   $0x0
 804a923:	e8 71 ff ff ff       	call   804a899 <posix_change_cpu_state_and_wait>
 804a928:	83 c4 10             	add    $0x10,%esp
	if (soc_terminate) {
 804a92b:	80 3d 72 19 05 08 00 	cmpb   $0x0,0x8051972
 804a932:	74 0d                	je     804a941 <posix_interrupt_raised+0x26>
		posix_exit(0);
 804a934:	83 ec 0c             	sub    $0xc,%esp
 804a937:	6a 00                	push   $0x0
 804a939:	e8 4c 0e 00 00       	call   804b78a <posix_exit>
 804a93e:	83 c4 10             	add    $0x10,%esp
}
 804a941:	c9                   	leave  
 804a942:	c3                   	ret    

0804a943 <posix_halt_cpu>:
{
 804a943:	55                   	push   %ebp
 804a944:	89 e5                	mov    %esp,%ebp
 804a946:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(true);
 804a949:	6a 01                	push   $0x1
 804a94b:	e8 49 ff ff ff       	call   804a899 <posix_change_cpu_state_and_wait>
 804a950:	83 c4 10             	add    $0x10,%esp
}
 804a953:	c9                   	leave  
	posix_irq_handler();
 804a954:	e9 bc 09 00 00       	jmp    804b315 <posix_irq_handler>

0804a959 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
 804a959:	55                   	push   %ebp
 804a95a:	89 e5                	mov    %esp,%ebp
 804a95c:	83 ec 24             	sub    $0x24,%esp
 804a95f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a965:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a968:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a96a:	68 08 19 05 08       	push   $0x8051908
 804a96f:	e8 4c e8 ff ff       	call   80491c0 <pthread_mutex_lock@plt>
 804a974:	83 c4 10             	add    $0x10,%esp
 804a977:	ba c2 e3 04 08       	mov    $0x804e3c2,%edx
 804a97c:	e8 b0 fe ff ff       	call   804a831 <pc_safe_call>
	cpu_halted = false;

	pthread_t zephyr_thread;

	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804a981:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804a984:	6a 00                	push   $0x0
 804a986:	68 4c a8 04 08       	push   $0x804a84c
 804a98b:	6a 00                	push   $0x0
 804a98d:	50                   	push   %eax
	cpu_halted = false;
 804a98e:	c6 05 d8 11 05 08 00 	movb   $0x0,0x80511d8
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804a995:	e8 36 e7 ff ff       	call   80490d0 <pthread_create@plt>
 804a99a:	83 c4 10             	add    $0x10,%esp
 804a99d:	ba 20 e4 04 08       	mov    $0x804e420,%edx
 804a9a2:	e8 8a fe ff ff       	call   804a831 <pc_safe_call>

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
 804a9a7:	80 3d d8 11 05 08 00 	cmpb   $0x0,0x80511d8
 804a9ae:	75 16                	jne    804a9c6 <posix_boot_cpu+0x6d>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804a9b0:	50                   	push   %eax
 804a9b1:	50                   	push   %eax
 804a9b2:	68 08 19 05 08       	push   $0x8051908
 804a9b7:	68 e0 13 05 08       	push   $0x80513e0
 804a9bc:	e8 3f e8 ff ff       	call   8049200 <pthread_cond_wait@plt>
 804a9c1:	83 c4 10             	add    $0x10,%esp
 804a9c4:	eb e1                	jmp    804a9a7 <posix_boot_cpu+0x4e>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a9c6:	83 ec 0c             	sub    $0xc,%esp
 804a9c9:	68 08 19 05 08       	push   $0x8051908
 804a9ce:	e8 5d e7 ff ff       	call   8049130 <pthread_mutex_unlock@plt>
 804a9d3:	83 c4 10             	add    $0x10,%esp
 804a9d6:	ba df e3 04 08       	mov    $0x804e3df,%edx
 804a9db:	e8 51 fe ff ff       	call   804a831 <pc_safe_call>

	if (soc_terminate) {
 804a9e0:	80 3d 72 19 05 08 00 	cmpb   $0x0,0x8051972
 804a9e7:	74 0d                	je     804a9f6 <posix_boot_cpu+0x9d>
		posix_exit(0);
 804a9e9:	83 ec 0c             	sub    $0xc,%esp
 804a9ec:	6a 00                	push   $0x0
 804a9ee:	e8 97 0d 00 00       	call   804b78a <posix_exit>
 804a9f3:	83 c4 10             	add    $0x10,%esp
	}
}
 804a9f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a9f9:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804aa00:	74 05                	je     804aa07 <posix_boot_cpu+0xae>
 804aa02:	e8 c9 e7 ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804aa07:	c9                   	leave  
 804aa08:	c3                   	ret    

0804aa09 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
 804aa09:	55                   	push   %ebp
 804aa0a:	89 e5                	mov    %esp,%ebp
 804aa0c:	56                   	push   %esi
 804aa0d:	8b 75 08             	mov    0x8(%ebp),%esi
 804aa10:	53                   	push   %ebx
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
 804aa11:	8b 1c b5 c4 e0 04 08 	mov    0x804e0c4(,%esi,4),%ebx
 804aa18:	39 1c b5 c8 e0 04 08 	cmp    %ebx,0x804e0c8(,%esi,4)
 804aa1f:	76 0d                	jbe    804aa2e <run_native_tasks+0x25>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
 804aa21:	8b 03                	mov    (%ebx),%eax
 804aa23:	85 c0                	test   %eax,%eax
 804aa25:	74 02                	je     804aa29 <run_native_tasks+0x20>
			(*fptr)();
 804aa27:	ff d0                	call   *%eax
		fptr++) {
 804aa29:	83 c3 04             	add    $0x4,%ebx
 804aa2c:	eb ea                	jmp    804aa18 <run_native_tasks+0xf>
		}
	}
}
 804aa2e:	5b                   	pop    %ebx
 804aa2f:	5e                   	pop    %esi
 804aa30:	5d                   	pop    %ebp
 804aa31:	c3                   	ret    

0804aa32 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
 804aa32:	55                   	push   %ebp
 804aa33:	89 e5                	mov    %esp,%ebp
 804aa35:	83 ec 08             	sub    $0x8,%esp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
 804aa38:	80 3d d8 11 05 08 00 	cmpb   $0x0,0x80511d8
 804aa3f:	74 14                	je     804aa55 <posix_soc_clean_up+0x23>

		posix_core_clean_up();
 804aa41:	e8 33 fc ff ff       	call   804a679 <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
 804aa46:	83 ec 0c             	sub    $0xc,%esp
 804aa49:	6a 04                	push   $0x4
 804aa4b:	e8 b9 ff ff ff       	call   804aa09 <run_native_tasks>
 804aa50:	83 c4 10             	add    $0x10,%esp
 804aa53:	eb 74                	jmp    804aac9 <posix_soc_clean_up+0x97>

	} else if (soc_terminate == false) {
 804aa55:	80 3d 72 19 05 08 00 	cmpb   $0x0,0x8051972
 804aa5c:	75 6b                	jne    804aac9 <posix_soc_clean_up+0x97>

		soc_terminate = true;

		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804aa5e:	83 ec 0c             	sub    $0xc,%esp
		soc_terminate = true;
 804aa61:	c6 05 72 19 05 08 01 	movb   $0x1,0x8051972
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804aa68:	68 08 19 05 08       	push   $0x8051908
 804aa6d:	e8 4e e7 ff ff       	call   80491c0 <pthread_mutex_lock@plt>
 804aa72:	ba c2 e3 04 08       	mov    $0x804e3c2,%edx
 804aa77:	83 c4 10             	add    $0x10,%esp
 804aa7a:	e8 b2 fd ff ff       	call   804a831 <pc_safe_call>

		cpu_halted = true;

		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804aa7f:	83 ec 0c             	sub    $0xc,%esp
		cpu_halted = true;
 804aa82:	c6 05 d8 11 05 08 01 	movb   $0x1,0x80511d8
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804aa89:	68 e0 13 05 08       	push   $0x80513e0
 804aa8e:	e8 cd e7 ff ff       	call   8049260 <pthread_cond_broadcast@plt>
 804aa93:	ba fe e3 04 08       	mov    $0x804e3fe,%edx
 804aa98:	83 c4 10             	add    $0x10,%esp
 804aa9b:	e8 91 fd ff ff       	call   804a831 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804aaa0:	83 ec 0c             	sub    $0xc,%esp
 804aaa3:	68 08 19 05 08       	push   $0x8051908
 804aaa8:	e8 83 e6 ff ff       	call   8049130 <pthread_mutex_unlock@plt>
 804aaad:	83 c4 10             	add    $0x10,%esp
 804aab0:	ba df e3 04 08       	mov    $0x804e3df,%edx
 804aab5:	e8 77 fd ff ff       	call   804a831 <pc_safe_call>

		while (1) {
			sleep(1);
 804aaba:	83 ec 0c             	sub    $0xc,%esp
 804aabd:	6a 01                	push   $0x1
 804aabf:	e8 2c e7 ff ff       	call   80491f0 <sleep@plt>
 804aac4:	83 c4 10             	add    $0x10,%esp
		while (1) {
 804aac7:	eb f1                	jmp    804aaba <posix_soc_clean_up+0x88>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
 804aac9:	c9                   	leave  
 804aaca:	c3                   	ret    

0804aacb <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
 804aacb:	c7 05 20 19 05 08 01 	movl   $0x1,0x8051920
 804aad2:	00 00 00 
}
 804aad5:	c3                   	ret    

0804aad6 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
 804aad6:	55                   	push   %ebp
 804aad7:	89 e5                	mov    %esp,%ebp
 804aad9:	53                   	push   %ebx
 804aada:	81 ec a0 00 00 00    	sub    $0xa0,%esp
 804aae0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804aae6:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804aae9:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804aaeb:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
	act.sa_handler = hwm_signal_end_handler;
 804aaf1:	c7 85 68 ff ff ff cb 	movl   $0x804aacb,-0x98(%ebp)
 804aaf8:	aa 04 08 
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804aafb:	50                   	push   %eax
 804aafc:	e8 3f e5 ff ff       	call   8049040 <sigemptyset@plt>
 804ab01:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804ab04:	85 c0                	test   %eax,%eax
 804ab06:	74 14                	je     804ab1c <hwm_set_sig_handler+0x46>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804ab08:	50                   	push   %eax
 804ab09:	50                   	push   %eax
 804ab0a:	68 5b e4 04 08       	push   $0x804e45b
 804ab0f:	68 02 e2 04 08       	push   $0x804e202
 804ab14:	e8 cb 0d 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804ab19:	83 c4 10             	add    $0x10,%esp

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804ab1c:	53                   	push   %ebx
 804ab1d:	8d 9d 68 ff ff ff    	lea    -0x98(%ebp),%ebx
 804ab23:	6a 00                	push   $0x0
 804ab25:	53                   	push   %ebx
 804ab26:	6a 0f                	push   $0xf
	act.sa_flags = SA_RESETHAND;
 804ab28:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804ab2f:	e8 cc e5 ff ff       	call   8049100 <sigaction@plt>
 804ab34:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804ab37:	85 c0                	test   %eax,%eax
 804ab39:	74 14                	je     804ab4f <hwm_set_sig_handler+0x79>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804ab3b:	51                   	push   %ecx
 804ab3c:	51                   	push   %ecx
 804ab3d:	68 75 e4 04 08       	push   $0x804e475
 804ab42:	68 02 e2 04 08       	push   $0x804e202
 804ab47:	e8 98 0d 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804ab4c:	83 c4 10             	add    $0x10,%esp
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
 804ab4f:	52                   	push   %edx
 804ab50:	6a 00                	push   $0x0
 804ab52:	53                   	push   %ebx
 804ab53:	6a 02                	push   $0x2
 804ab55:	e8 a6 e5 ff ff       	call   8049100 <sigaction@plt>
 804ab5a:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804ab5d:	85 c0                	test   %eax,%eax
 804ab5f:	74 14                	je     804ab75 <hwm_set_sig_handler+0x9f>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804ab61:	50                   	push   %eax
 804ab62:	50                   	push   %eax
 804ab63:	68 94 e4 04 08       	push   $0x804e494
 804ab68:	68 02 e2 04 08       	push   $0x804e202
 804ab6d:	e8 72 0d 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804ab72:	83 c4 10             	add    $0x10,%esp
}
 804ab75:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ab78:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804ab7f:	74 05                	je     804ab86 <hwm_set_sig_handler+0xb0>
 804ab81:	e8 4a e6 ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804ab86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ab89:	c9                   	leave  
 804ab8a:	c3                   	ret    

0804ab8b <hwm_find_next_timer>:
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
 804ab8b:	8b 15 a8 11 05 08    	mov    0x80511a8,%edx
 804ab91:	a1 ac 11 05 08       	mov    0x80511ac,%eax
{
 804ab96:	55                   	push   %ebp
	next_timer_time  = *Timer_list[0];
 804ab97:	8b 0d 8c 18 05 08    	mov    0x805188c,%ecx
	next_timer_index = 0;
 804ab9d:	c7 05 bc 11 05 08 00 	movl   $0x0,0x80511bc
 804aba4:	00 00 00 
{
 804aba7:	89 e5                	mov    %esp,%ebp
 804aba9:	53                   	push   %ebx
	next_timer_time  = *Timer_list[0];
 804abaa:	8b 1d 88 18 05 08    	mov    0x8051888,%ebx
 804abb0:	89 0d 44 18 05 08    	mov    %ecx,0x8051844
		if (next_timer_time > *Timer_list[i]) {
 804abb6:	39 da                	cmp    %ebx,%edx
	next_timer_time  = *Timer_list[0];
 804abb8:	89 1d 40 18 05 08    	mov    %ebx,0x8051840
		if (next_timer_time > *Timer_list[i]) {
 804abbe:	89 c3                	mov    %eax,%ebx
 804abc0:	19 cb                	sbb    %ecx,%ebx
 804abc2:	73 15                	jae    804abd9 <hwm_find_next_timer+0x4e>
			next_timer_index = i;
 804abc4:	c7 05 bc 11 05 08 01 	movl   $0x1,0x80511bc
 804abcb:	00 00 00 
			next_timer_time = *Timer_list[i];
 804abce:	89 15 40 18 05 08    	mov    %edx,0x8051840
 804abd4:	a3 44 18 05 08       	mov    %eax,0x8051844
		if (next_timer_time > *Timer_list[i]) {
 804abd9:	a1 c4 18 05 08       	mov    0x80518c4,%eax
 804abde:	8b 15 c0 18 05 08    	mov    0x80518c0,%edx
 804abe4:	3b 15 40 18 05 08    	cmp    0x8051840,%edx
 804abea:	89 c1                	mov    %eax,%ecx
 804abec:	1b 0d 44 18 05 08    	sbb    0x8051844,%ecx
 804abf2:	73 15                	jae    804ac09 <hwm_find_next_timer+0x7e>
			next_timer_index = i;
 804abf4:	c7 05 bc 11 05 08 02 	movl   $0x2,0x80511bc
 804abfb:	00 00 00 
			next_timer_time = *Timer_list[i];
 804abfe:	89 15 40 18 05 08    	mov    %edx,0x8051840
 804ac04:	a3 44 18 05 08       	mov    %eax,0x8051844
		}
	}
}
 804ac09:	5b                   	pop    %ebx
 804ac0a:	5d                   	pop    %ebp
 804ac0b:	c3                   	ret    

0804ac0c <hwm_one_event>:

/**
 * Execute the next scheduled HW event/timer
 */
void hwm_one_event(void)
{
 804ac0c:	55                   	push   %ebp
 804ac0d:	89 e5                	mov    %esp,%ebp
 804ac0f:	56                   	push   %esi
 804ac10:	53                   	push   %ebx
 804ac11:	83 ec 10             	sub    $0x10,%esp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
 804ac14:	a1 40 18 05 08       	mov    0x8051840,%eax
 804ac19:	8b 15 44 18 05 08    	mov    0x8051844,%edx
 804ac1f:	8b 0d 48 18 05 08    	mov    0x8051848,%ecx
 804ac25:	8b 1d 4c 18 05 08    	mov    0x805184c,%ebx
 804ac2b:	89 d6                	mov    %edx,%esi
 804ac2d:	39 c8                	cmp    %ecx,%eax
 804ac2f:	19 de                	sbb    %ebx,%esi
 804ac31:	72 0d                	jb     804ac40 <hwm_one_event+0x34>
		simu_time = next_timer_time;
 804ac33:	a3 48 18 05 08       	mov    %eax,0x8051848
 804ac38:	89 15 4c 18 05 08    	mov    %edx,0x805184c
 804ac3e:	eb 19                	jmp    804ac59 <hwm_one_event+0x4d>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
 804ac40:	56                   	push   %esi
 804ac41:	56                   	push   %esi
 804ac42:	ff 35 bc 11 05 08    	push   0x80511bc
 804ac48:	53                   	push   %ebx
 804ac49:	51                   	push   %ecx
 804ac4a:	52                   	push   %edx
 804ac4b:	50                   	push   %eax
 804ac4c:	68 b2 e4 04 08       	push   $0x804e4b2
 804ac51:	e8 b9 0c 00 00       	call   804b90f <posix_print_warning>
 804ac56:	83 c4 20             	add    $0x20,%esp
	if (signaled_end || (simu_time > end_of_time)) {
 804ac59:	8b 0d 20 19 05 08    	mov    0x8051920,%ecx
 804ac5f:	a1 48 18 05 08       	mov    0x8051848,%eax
 804ac64:	8b 15 4c 18 05 08    	mov    0x805184c,%edx
 804ac6a:	85 c9                	test   %ecx,%ecx
 804ac6c:	75 10                	jne    804ac7e <hwm_one_event+0x72>
 804ac6e:	8b 0d 9c 11 05 08    	mov    0x805119c,%ecx
 804ac74:	39 05 98 11 05 08    	cmp    %eax,0x8051198
 804ac7a:	19 d1                	sbb    %edx,%ecx
 804ac7c:	73 38                	jae    804acb6 <hwm_one_event+0xaa>
				((long double)simu_time)/1.0e6L);
 804ac7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ac81:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804ac84:	df 6d f0             	fildll -0x10(%ebp)
 804ac87:	85 d2                	test   %edx,%edx
 804ac89:	79 06                	jns    804ac91 <hwm_one_event+0x85>
 804ac8b:	d8 05 dc e0 04 08    	fadds  0x804e0dc
		posix_print_trace("\nStopped at %.3Lfs\n",
 804ac91:	d8 35 e0 e0 04 08    	fdivs  0x804e0e0
 804ac97:	83 ec 0c             	sub    $0xc,%esp
 804ac9a:	db 3c 24             	fstpt  (%esp)
 804ac9d:	68 e9 e4 04 08       	push   $0x804e4e9
 804aca2:	e8 87 0c 00 00       	call   804b92e <posix_print_trace>
		posix_exit(0);
 804aca7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804acae:	e8 d7 0a 00 00       	call   804b78a <posix_exit>
 804acb3:	83 c4 10             	add    $0x10,%esp
	hwm_sleep_until_next_timer();

	switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
 804acb6:	a1 bc 11 05 08       	mov    0x80511bc,%eax
 804acbb:	83 f8 01             	cmp    $0x1,%eax
 804acbe:	74 10                	je     804acd0 <hwm_one_event+0xc4>
 804acc0:	83 f8 02             	cmp    $0x2,%eax
 804acc3:	74 12                	je     804acd7 <hwm_one_event+0xcb>
 804acc5:	85 c0                	test   %eax,%eax
 804acc7:	75 15                	jne    804acde <hwm_one_event+0xd2>
	case HWTIMER:
		hwtimer_timer_reached();
 804acc9:	e8 53 04 00 00       	call   804b121 <hwtimer_timer_reached>
		break;
 804acce:	eb 1e                	jmp    804acee <hwm_one_event+0xe2>
	case IRQCNT:
		hw_irq_ctrl_timer_triggered();
 804acd0:	e8 9c 0a 00 00       	call   804b771 <hw_irq_ctrl_timer_triggered>
		break;
 804acd5:	eb 17                	jmp    804acee <hwm_one_event+0xe2>
	case HW_COUNTER:
		hw_counter_triggered();
 804acd7:	e8 09 15 00 00       	call   804c1e5 <hw_counter_triggered>
		break;
 804acdc:	eb 10                	jmp    804acee <hwm_one_event+0xe2>
	default:
		/* LCOV_EXCL_START */
		posix_print_error_and_exit(
 804acde:	83 ec 0c             	sub    $0xc,%esp
 804ace1:	68 fd e4 04 08       	push   $0x804e4fd
 804ace6:	e8 f9 0b 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804aceb:	83 c4 10             	add    $0x10,%esp
		break;
		/* LCOV_EXCL_STOP */
	}

	hwm_find_next_timer();
}
 804acee:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804acf1:	5b                   	pop    %ebx
 804acf2:	5e                   	pop    %esi
 804acf3:	5d                   	pop    %ebp
	hwm_find_next_timer();
 804acf4:	e9 92 fe ff ff       	jmp    804ab8b <hwm_find_next_timer>

0804acf9 <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
 804acf9:	55                   	push   %ebp
 804acfa:	89 e5                	mov    %esp,%ebp
	end_of_time = new_end_of_time;
 804acfc:	8b 45 08             	mov    0x8(%ebp),%eax
 804acff:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804ad02:	5d                   	pop    %ebp
	end_of_time = new_end_of_time;
 804ad03:	a3 98 11 05 08       	mov    %eax,0x8051198
 804ad08:	89 15 9c 11 05 08    	mov    %edx,0x805119c
}
 804ad0e:	c3                   	ret    

0804ad0f <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
 804ad0f:	a1 48 18 05 08       	mov    0x8051848,%eax
 804ad14:	8b 15 4c 18 05 08    	mov    0x805184c,%edx
 804ad1a:	c3                   	ret    

0804ad1b <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
 804ad1b:	55                   	push   %ebp
 804ad1c:	89 e5                	mov    %esp,%ebp
 804ad1e:	83 ec 08             	sub    $0x8,%esp
	hwm_set_sig_handler();
 804ad21:	e8 b0 fd ff ff       	call   804aad6 <hwm_set_sig_handler>
	hwtimer_init();
 804ad26:	e8 7c 02 00 00       	call   804afa7 <hwtimer_init>
	hw_counter_init();
 804ad2b:	e8 5d 14 00 00       	call   804c18d <hw_counter_init>
	hw_irq_ctrl_init();
 804ad30:	e8 10 08 00 00       	call   804b545 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
 804ad35:	c9                   	leave  
	hwm_find_next_timer();
 804ad36:	e9 50 fe ff ff       	jmp    804ab8b <hwm_find_next_timer>

0804ad3b <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
 804ad3b:	55                   	push   %ebp
 804ad3c:	89 e5                	mov    %esp,%ebp
 804ad3e:	83 ec 08             	sub    $0x8,%esp
	hwtimer_cleanup();
 804ad41:	e8 9c 03 00 00       	call   804b0e2 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
 804ad46:	c9                   	leave  
	hw_irq_ctrl_cleanup();
 804ad47:	e9 46 08 00 00       	jmp    804b592 <hw_irq_ctrl_cleanup>

0804ad4c <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ad4c:	8b 0d 84 18 05 08    	mov    0x8051884,%ecx
 804ad52:	a1 7c 18 05 08       	mov    0x805187c,%eax
{
 804ad57:	55                   	push   %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ad58:	8b 15 78 18 05 08    	mov    0x8051878,%edx
 804ad5e:	39 15 80 18 05 08    	cmp    %edx,0x8051880
{
 804ad64:	89 e5                	mov    %esp,%ebp
 804ad66:	53                   	push   %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ad67:	89 cb                	mov    %ecx,%ebx
 804ad69:	19 c3                	sbb    %eax,%ebx
 804ad6b:	0f 42 15 80 18 05 08 	cmovb  0x8051880,%edx
}
 804ad72:	5b                   	pop    %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ad73:	0f 42 c1             	cmovb  %ecx,%eax
}
 804ad76:	5d                   	pop    %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ad77:	89 15 88 18 05 08    	mov    %edx,0x8051888
 804ad7d:	a3 8c 18 05 08       	mov    %eax,0x805188c
}
 804ad82:	c3                   	ret    

0804ad83 <cmd_realtime_found>:
	real_time_mode = new_rt;
 804ad83:	c6 05 d9 11 05 08 01 	movb   $0x1,0x80511d9
static void cmd_realtime_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(true);
}
 804ad8a:	c3                   	ret    

0804ad8b <cmd_no_realtime_found>:
	real_time_mode = new_rt;
 804ad8b:	c6 05 d9 11 05 08 00 	movb   $0x0,0x80511d9
static void cmd_no_realtime_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(false);
}
 804ad92:	c3                   	ret    

0804ad93 <cmd_rtcoffset_found>:

static void cmd_rtcoffset_found(char *argv, int offset)
{
 804ad93:	55                   	push   %ebp
 804ad94:	89 e5                	mov    %esp,%ebp
 804ad96:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
 804ad99:	d9 05 e0 e0 04 08    	flds   0x804e0e0
 804ad9f:	d9 7d fe             	fnstcw -0x2(%ebp)
 804ada2:	dc 0d 28 14 05 08    	fmull  0x8051428
 804ada8:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
 804adac:	80 cc 0c             	or     $0xc,%ah
 804adaf:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
 804adb3:	d9 6d fc             	fldcw  -0x4(%ebp)
 804adb6:	df 3d 60 18 05 08    	fistpll 0x8051860
 804adbc:	d9 6d fe             	fldcw  -0x2(%ebp)
}
 804adbf:	c9                   	leave  
 804adc0:	c3                   	ret    

0804adc1 <cmd_rtcreset_found>:
	reset_rtc = true;
 804adc1:	c6 05 73 19 05 08 01 	movb   $0x1,0x8051973
static void cmd_rtcreset_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}
 804adc8:	c3                   	ret    

0804adc9 <native_add_time_options>:

static void native_add_time_options(void)
{
 804adc9:	55                   	push   %ebp
 804adca:	89 e5                	mov    %esp,%ebp
 804adcc:	83 ec 14             	sub    $0x14,%esp
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
 804adcf:	68 00 10 05 08       	push   $0x8051000
 804add4:	e8 52 12 00 00       	call   804c02b <native_add_command_line_opts>
 804add9:	83 c4 10             	add    $0x10,%esp
}
 804addc:	c9                   	leave  
 804addd:	c3                   	ret    

0804adde <cmd_rt_ratio_found>:
	if ((args.rt_ratio <= 0)) {
 804adde:	dd 05 38 14 05 08    	fldl   0x8051438
 804ade4:	d9 ee                	fldz   
 804ade6:	df f1                	fcomip %st(1),%st
 804ade8:	dd d8                	fstp   %st(0)
 804adea:	72 21                	jb     804ae0d <cmd_rt_ratio_found+0x2f>
{
 804adec:	55                   	push   %ebp
 804aded:	89 e5                	mov    %esp,%ebp
 804adef:	83 ec 14             	sub    $0x14,%esp
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804adf2:	68 19 e5 04 08       	push   $0x804e519
 804adf7:	e8 e8 0a 00 00       	call   804b8e4 <posix_print_error_and_exit>
	clock_ratio = ratio;
 804adfc:	dd 05 38 14 05 08    	fldl   0x8051438
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804ae02:	83 c4 10             	add    $0x10,%esp
	clock_ratio = ratio;
 804ae05:	dd 1d a0 11 05 08    	fstpl  0x80511a0
}
 804ae0b:	c9                   	leave  
 804ae0c:	c3                   	ret    
	clock_ratio = ratio;
 804ae0d:	dd 05 38 14 05 08    	fldl   0x8051438
 804ae13:	dd 1d a0 11 05 08    	fstpl  0x80511a0
 804ae19:	c3                   	ret    

0804ae1a <cmd_rt_drift_found>:
{
 804ae1a:	55                   	push   %ebp
	if (!(args.rt_drift > -1)) {
 804ae1b:	d9 e8                	fld1   
 804ae1d:	d9 e0                	fchs   
{
 804ae1f:	89 e5                	mov    %esp,%ebp
 804ae21:	83 ec 18             	sub    $0x18,%esp
	if (!(args.rt_drift > -1)) {
 804ae24:	dd 05 30 14 05 08    	fldl   0x8051430
 804ae2a:	df f1                	fcomip %st(1),%st
 804ae2c:	dd d8                	fstp   %st(0)
 804ae2e:	77 10                	ja     804ae40 <cmd_rt_drift_found+0x26>
		posix_print_error_and_exit("The drift needs to be > -1. "
 804ae30:	83 ec 0c             	sub    $0xc,%esp
 804ae33:	68 55 e5 04 08       	push   $0x804e555
 804ae38:	e8 a7 0a 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804ae3d:	83 c4 10             	add    $0x10,%esp
	args.rt_ratio = args.rt_drift + 1;
 804ae40:	d9 e8                	fld1   
 804ae42:	dc 05 30 14 05 08    	faddl  0x8051430
 804ae48:	dd 5d f0             	fstpl  -0x10(%ebp)
 804ae4b:	dd 45 f0             	fldl   -0x10(%ebp)
 804ae4e:	dd 15 38 14 05 08    	fstl   0x8051438
	clock_ratio = ratio;
 804ae54:	dd 1d a0 11 05 08    	fstpl  0x80511a0
}
 804ae5a:	c9                   	leave  
 804ae5b:	c3                   	ret    

0804ae5c <cmd_stop_at_found>:
{
 804ae5c:	55                   	push   %ebp
	if (args.stop_at < 0) {
 804ae5d:	d9 ee                	fldz   
{
 804ae5f:	89 e5                	mov    %esp,%ebp
 804ae61:	53                   	push   %ebx
 804ae62:	83 ec 14             	sub    $0x14,%esp
	if (args.stop_at < 0) {
 804ae65:	dd 05 20 14 05 08    	fldl   0x8051420
 804ae6b:	d9 c9                	fxch   %st(1)
{
 804ae6d:	8b 45 08             	mov    0x8(%ebp),%eax
	if (args.stop_at < 0) {
 804ae70:	df f1                	fcomip %st(1),%st
 804ae72:	dd d8                	fstp   %st(0)
 804ae74:	76 10                	jbe    804ae86 <cmd_stop_at_found+0x2a>
		posix_print_error_and_exit("Error: stop-at must be positive "
 804ae76:	52                   	push   %edx
 804ae77:	52                   	push   %edx
 804ae78:	50                   	push   %eax
 804ae79:	68 92 e5 04 08       	push   $0x804e592
 804ae7e:	e8 61 0a 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804ae83:	83 c4 10             	add    $0x10,%esp
	hwm_set_end_of_time(args.stop_at*1e6);
 804ae86:	d9 05 e0 e0 04 08    	flds   0x804e0e0
 804ae8c:	dc 0d 20 14 05 08    	fmull  0x8051420
 804ae92:	d9 05 e4 e0 04 08    	flds   0x804e0e4
 804ae98:	d9 c9                	fxch   %st(1)
 804ae9a:	db f1                	fcomi  %st(1),%st
 804ae9c:	73 21                	jae    804aebf <cmd_stop_at_found+0x63>
 804ae9e:	dd d9                	fstp   %st(1)
 804aea0:	d9 7d f6             	fnstcw -0xa(%ebp)
 804aea3:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804aea7:	80 cc 0c             	or     $0xc,%ah
 804aeaa:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804aeae:	d9 6d f4             	fldcw  -0xc(%ebp)
 804aeb1:	df 7d e8             	fistpll -0x18(%ebp)
 804aeb4:	d9 6d f6             	fldcw  -0xa(%ebp)
 804aeb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804aeba:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804aebd:	eb 27                	jmp    804aee6 <cmd_stop_at_found+0x8a>
 804aebf:	d9 7d f6             	fnstcw -0xa(%ebp)
 804aec2:	de e1                	fsubp  %st,%st(1)
 804aec4:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804aec8:	80 cc 0c             	or     $0xc,%ah
 804aecb:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804aecf:	d9 6d f4             	fldcw  -0xc(%ebp)
 804aed2:	df 7d e8             	fistpll -0x18(%ebp)
 804aed5:	d9 6d f6             	fldcw  -0xa(%ebp)
 804aed8:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804aedb:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804aede:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804aee4:	89 ca                	mov    %ecx,%edx
 804aee6:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804aee9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	hwm_set_end_of_time(args.stop_at*1e6);
 804aeec:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 804aeef:	c9                   	leave  
	hwm_set_end_of_time(args.stop_at*1e6);
 804aef0:	e9 04 fe ff ff       	jmp    804acf9 <hwm_set_end_of_time>

0804aef5 <get_host_us_time>:
{
 804aef5:	55                   	push   %ebp
 804aef6:	89 e5                	mov    %esp,%ebp
 804aef8:	53                   	push   %ebx
 804aef9:	83 ec 2c             	sub    $0x2c,%esp
 804aefc:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804af02:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804af05:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804af07:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804af0a:	50                   	push   %eax
 804af0b:	6a 04                	push   $0x4
 804af0d:	e8 4e e1 ff ff       	call   8049060 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804af12:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804af15:	db 45 ec             	fildl  -0x14(%ebp)
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804af18:	83 c4 10             	add    $0x10,%esp
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804af1b:	99                   	cltd   
 804af1c:	85 d2                	test   %edx,%edx
 804af1e:	79 06                	jns    804af26 <get_host_us_time+0x31>
 804af20:	d8 05 dc e0 04 08    	fadds  0x804e0dc
 804af26:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804af29:	d8 0d e0 e0 04 08    	fmuls  0x804e0e0
 804af2f:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804af34:	99                   	cltd   
 804af35:	f7 f9                	idiv   %ecx
 804af37:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804af3a:	da 45 d8             	fiaddl -0x28(%ebp)
 804af3d:	d9 05 e4 e0 04 08    	flds   0x804e0e4
 804af43:	d9 c9                	fxch   %st(1)
 804af45:	db f1                	fcomi  %st(1),%st
 804af47:	73 21                	jae    804af6a <get_host_us_time+0x75>
 804af49:	dd d9                	fstp   %st(1)
 804af4b:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804af4e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804af52:	80 cc 0c             	or     $0xc,%ah
 804af55:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804af59:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804af5c:	df 7d d8             	fistpll -0x28(%ebp)
 804af5f:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804af62:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804af65:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804af68:	eb 27                	jmp    804af91 <get_host_us_time+0x9c>
 804af6a:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804af6d:	de e1                	fsubp  %st,%st(1)
 804af6f:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804af73:	80 cc 0c             	or     $0xc,%ah
 804af76:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804af7a:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804af7d:	df 7d d8             	fistpll -0x28(%ebp)
 804af80:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804af83:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804af86:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804af89:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804af8f:	89 ca                	mov    %ecx,%edx
}
 804af91:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 804af94:	65 2b 0d 14 00 00 00 	sub    %gs:0x14,%ecx
 804af9b:	74 05                	je     804afa2 <get_host_us_time+0xad>
 804af9d:	e8 2e e2 ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804afa2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804afa5:	c9                   	leave  
 804afa6:	c3                   	ret    

0804afa7 <hwtimer_init>:
{
 804afa7:	55                   	push   %ebp
 804afa8:	89 e5                	mov    %esp,%ebp
 804afaa:	53                   	push   %ebx
 804afab:	83 ec 24             	sub    $0x24,%esp
 804afae:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804afb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804afb7:	31 c0                	xor    %eax,%eax
	silent_ticks = 0;
 804afb9:	c7 05 68 18 05 08 00 	movl   $0x0,0x8051868
 804afc0:	00 00 00 
 804afc3:	c7 05 6c 18 05 08 00 	movl   $0x0,0x805186c
 804afca:	00 00 00 
	hw_timer_tick_timer = NEVER;
 804afcd:	c7 05 80 18 05 08 ff 	movl   $0xffffffff,0x8051880
 804afd4:	ff ff ff 
 804afd7:	c7 05 84 18 05 08 ff 	movl   $0xffffffff,0x8051884
 804afde:	ff ff ff 
	hw_timer_awake_timer = NEVER;
 804afe1:	c7 05 78 18 05 08 ff 	movl   $0xffffffff,0x8051878
 804afe8:	ff ff ff 
 804afeb:	c7 05 7c 18 05 08 ff 	movl   $0xffffffff,0x805187c
 804aff2:	ff ff ff 
	hwtimer_update_timer();
 804aff5:	e8 52 fd ff ff       	call   804ad4c <hwtimer_update_timer>
	if (real_time_mode) {
 804affa:	80 3d d9 11 05 08 00 	cmpb   $0x0,0x80511d9
 804b001:	74 24                	je     804b027 <hwtimer_init+0x80>
		boot_time = get_host_us_time();
 804b003:	e8 ed fe ff ff       	call   804aef5 <get_host_us_time>
		last_radj_stime = 0U;
 804b008:	c7 05 50 18 05 08 00 	movl   $0x0,0x8051850
 804b00f:	00 00 00 
		last_radj_rtime = boot_time;
 804b012:	a3 58 18 05 08       	mov    %eax,0x8051858
 804b017:	89 15 5c 18 05 08    	mov    %edx,0x805185c
		last_radj_stime = 0U;
 804b01d:	c7 05 54 18 05 08 00 	movl   $0x0,0x8051854
 804b024:	00 00 00 
	if (!reset_rtc) {
 804b027:	80 3d 73 19 05 08 00 	cmpb   $0x0,0x8051973
 804b02e:	0f 85 98 00 00 00    	jne    804b0cc <hwtimer_init+0x125>
		clock_gettime(CLOCK_REALTIME, &tv);
 804b034:	50                   	push   %eax
 804b035:	50                   	push   %eax
 804b036:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804b039:	50                   	push   %eax
 804b03a:	6a 00                	push   $0x0
 804b03c:	e8 1f e0 ff ff       	call   8049060 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804b041:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b044:	db 45 ec             	fildl  -0x14(%ebp)
		clock_gettime(CLOCK_REALTIME, &tv);
 804b047:	83 c4 10             	add    $0x10,%esp
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804b04a:	99                   	cltd   
 804b04b:	85 d2                	test   %edx,%edx
 804b04d:	79 06                	jns    804b055 <hwtimer_init+0xae>
 804b04f:	d8 05 dc e0 04 08    	fadds  0x804e0dc
 804b055:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b058:	d8 0d e0 e0 04 08    	fmuls  0x804e0e0
 804b05e:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804b063:	99                   	cltd   
 804b064:	f7 f9                	idiv   %ecx
 804b066:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804b069:	da 45 d8             	fiaddl -0x28(%ebp)
 804b06c:	d9 05 e4 e0 04 08    	flds   0x804e0e4
 804b072:	d9 c9                	fxch   %st(1)
 804b074:	db f1                	fcomi  %st(1),%st
 804b076:	73 21                	jae    804b099 <hwtimer_init+0xf2>
 804b078:	dd d9                	fstp   %st(1)
 804b07a:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804b07d:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804b081:	80 cc 0c             	or     $0xc,%ah
 804b084:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804b088:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804b08b:	df 7d d8             	fistpll -0x28(%ebp)
 804b08e:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804b091:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b094:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b097:	eb 27                	jmp    804b0c0 <hwtimer_init+0x119>
 804b099:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804b09c:	de e1                	fsubp  %st,%st(1)
 804b09e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804b0a2:	80 cc 0c             	or     $0xc,%ah
 804b0a5:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804b0a9:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804b0ac:	df 7d d8             	fistpll -0x28(%ebp)
 804b0af:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804b0b2:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b0b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b0b8:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804b0be:	89 ca                	mov    %ecx,%edx
		rtc_offset += realhosttime;
 804b0c0:	01 05 60 18 05 08    	add    %eax,0x8051860
 804b0c6:	11 15 64 18 05 08    	adc    %edx,0x8051864
}
 804b0cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b0cf:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804b0d6:	74 05                	je     804b0dd <hwtimer_init+0x136>
 804b0d8:	e8 f3 e0 ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804b0dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804b0e0:	c9                   	leave  
 804b0e1:	c3                   	ret    

0804b0e2 <hwtimer_cleanup>:
}
 804b0e2:	c3                   	ret    

0804b0e3 <hwtimer_enable>:
{
 804b0e3:	55                   	push   %ebp
 804b0e4:	89 e5                	mov    %esp,%ebp
 804b0e6:	83 ec 08             	sub    $0x8,%esp
	tick_p = period;
 804b0e9:	8b 45 08             	mov    0x8(%ebp),%eax
 804b0ec:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b0ef:	a3 70 18 05 08       	mov    %eax,0x8051870
 804b0f4:	89 15 74 18 05 08    	mov    %edx,0x8051874
	hw_timer_tick_timer = hwm_get_time() + tick_p;
 804b0fa:	e8 10 fc ff ff       	call   804ad0f <hwm_get_time>
 804b0ff:	03 05 70 18 05 08    	add    0x8051870,%eax
 804b105:	13 15 74 18 05 08    	adc    0x8051874,%edx
 804b10b:	a3 80 18 05 08       	mov    %eax,0x8051880
 804b110:	89 15 84 18 05 08    	mov    %edx,0x8051884
	hwtimer_update_timer();
 804b116:	e8 31 fc ff ff       	call   804ad4c <hwtimer_update_timer>
}
 804b11b:	c9                   	leave  
	hwm_find_next_timer();
 804b11c:	e9 6a fa ff ff       	jmp    804ab8b <hwm_find_next_timer>

0804b121 <hwtimer_timer_reached>:
{
 804b121:	55                   	push   %ebp
 804b122:	89 e5                	mov    %esp,%ebp
 804b124:	57                   	push   %edi
 804b125:	56                   	push   %esi
 804b126:	83 ec 30             	sub    $0x30,%esp
	uint64_t Now = hw_timer_timer;
 804b129:	8b 35 88 18 05 08    	mov    0x8051888,%esi
 804b12f:	8b 3d 8c 18 05 08    	mov    0x805188c,%edi
{
 804b135:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804b13b:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b13e:	31 c0                	xor    %eax,%eax
	if (hw_timer_awake_timer == Now) {
 804b140:	39 3d 7c 18 05 08    	cmp    %edi,0x805187c
 804b146:	75 31                	jne    804b179 <hwtimer_timer_reached+0x58>
 804b148:	39 35 78 18 05 08    	cmp    %esi,0x8051878
 804b14e:	75 29                	jne    804b179 <hwtimer_timer_reached+0x58>
	hw_timer_awake_timer = NEVER;
 804b150:	c7 05 78 18 05 08 ff 	movl   $0xffffffff,0x8051878
 804b157:	ff ff ff 
 804b15a:	c7 05 7c 18 05 08 ff 	movl   $0xffffffff,0x805187c
 804b161:	ff ff ff 
	hwtimer_update_timer();
 804b164:	e8 e3 fb ff ff       	call   804ad4c <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
 804b169:	83 ec 0c             	sub    $0xc,%esp
 804b16c:	68 ff ff 00 00       	push   $0xffff
 804b171:	e8 5d 05 00 00       	call   804b6d3 <hw_irq_ctrl_set_irq>
 804b176:	83 c4 10             	add    $0x10,%esp
	if (hw_timer_tick_timer == Now) {
 804b179:	8b 15 84 18 05 08    	mov    0x8051884,%edx
 804b17f:	a1 80 18 05 08       	mov    0x8051880,%eax
 804b184:	39 fa                	cmp    %edi,%edx
 804b186:	0f 85 5b 01 00 00    	jne    804b2e7 <hwtimer_timer_reached+0x1c6>
 804b18c:	39 f0                	cmp    %esi,%eax
 804b18e:	0f 85 53 01 00 00    	jne    804b2e7 <hwtimer_timer_reached+0x1c6>
	if (real_time_mode) {
 804b194:	80 3d d9 11 05 08 00 	cmpb   $0x0,0x80511d9
 804b19b:	0f 84 f7 00 00 00    	je     804b298 <hwtimer_timer_reached+0x177>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804b1a1:	2b 05 50 18 05 08    	sub    0x8051850,%eax
 804b1a7:	1b 15 54 18 05 08    	sbb    0x8051854,%edx
				    / clock_ratio
 804b1ad:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804b1b0:	89 55 cc             	mov    %edx,-0x34(%ebp)
 804b1b3:	df 6d c8             	fildll -0x38(%ebp)
 804b1b6:	85 d2                	test   %edx,%edx
 804b1b8:	79 06                	jns    804b1c0 <hwtimer_timer_reached+0x9f>
 804b1ba:	d8 05 dc e0 04 08    	fadds  0x804e0dc
 804b1c0:	dc 35 a0 11 05 08    	fdivl  0x80511a0
				    + last_radj_rtime;
 804b1c6:	83 3d 5c 18 05 08 00 	cmpl   $0x0,0x805185c
 804b1cd:	df 2d 58 18 05 08    	fildll 0x8051858
 804b1d3:	79 06                	jns    804b1db <hwtimer_timer_reached+0xba>
 804b1d5:	d8 05 dc e0 04 08    	fadds  0x804e0dc
 804b1db:	de c1                	faddp  %st,%st(1)
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804b1dd:	d9 05 e4 e0 04 08    	flds   0x804e0e4
 804b1e3:	d9 c9                	fxch   %st(1)
 804b1e5:	db f1                	fcomi  %st(1),%st
 804b1e7:	73 21                	jae    804b20a <hwtimer_timer_reached+0xe9>
 804b1e9:	dd d9                	fstp   %st(1)
 804b1eb:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b1ee:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b1f2:	80 cc 0c             	or     $0xc,%ah
 804b1f5:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b1f9:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b1fc:	df 7d c8             	fistpll -0x38(%ebp)
 804b1ff:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b202:	8b 75 c8             	mov    -0x38(%ebp),%esi
 804b205:	8b 7d cc             	mov    -0x34(%ebp),%edi
 804b208:	eb 27                	jmp    804b231 <hwtimer_timer_reached+0x110>
 804b20a:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b20d:	de e1                	fsubp  %st,%st(1)
 804b20f:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b213:	80 cc 0c             	or     $0xc,%ah
 804b216:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b21a:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b21d:	df 7d c8             	fistpll -0x38(%ebp)
 804b220:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b223:	8b 7d cc             	mov    -0x34(%ebp),%edi
 804b226:	8b 75 c8             	mov    -0x38(%ebp),%esi
 804b229:	8d 87 00 00 00 80    	lea    -0x80000000(%edi),%eax
 804b22f:	89 c7                	mov    %eax,%edi
		uint64_t real_time = get_host_us_time();
 804b231:	e8 bf fc ff ff       	call   804aef5 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
 804b236:	29 c6                	sub    %eax,%esi
 804b238:	19 d7                	sbb    %edx,%edi
		if (diff > 0) { /* we need to slow down */
 804b23a:	31 c0                	xor    %eax,%eax
 804b23c:	39 f0                	cmp    %esi,%eax
 804b23e:	19 f8                	sbb    %edi,%eax
 804b240:	7d 56                	jge    804b298 <hwtimer_timer_reached+0x177>
			requested_time.tv_sec  = diff / 1e6;
 804b242:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b245:	89 75 c8             	mov    %esi,-0x38(%ebp)
 804b248:	89 7d cc             	mov    %edi,-0x34(%ebp)
 804b24b:	df 6d c8             	fildll -0x38(%ebp)
 804b24e:	d9 05 e0 e0 04 08    	flds   0x804e0e0
 804b254:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b258:	d9 c1                	fld    %st(1)
 804b25a:	80 cc 0c             	or     $0xc,%ah
 804b25d:	d8 f1                	fdiv   %st(1),%st
 804b25f:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b263:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b266:	db 5d c8             	fistpl -0x38(%ebp)
 804b269:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b26c:	8b 45 c8             	mov    -0x38(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804b26f:	da 4d c8             	fimull -0x38(%ebp)
			requested_time.tv_sec  = diff / 1e6;
 804b272:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804b275:	50                   	push   %eax
 804b276:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804b277:	de e9                	fsubrp %st,%st(1)
			(void) nanosleep(&requested_time, &remaining);
 804b279:	8d 45 ec             	lea    -0x14(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804b27c:	d8 0d e8 e0 04 08    	fmuls  0x804e0e8
			(void) nanosleep(&requested_time, &remaining);
 804b282:	50                   	push   %eax
 804b283:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804b286:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804b287:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b28a:	db 5d e8             	fistpl -0x18(%ebp)
 804b28d:	d9 6d d6             	fldcw  -0x2a(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804b290:	e8 bb de ff ff       	call   8049150 <nanosleep@plt>
 804b295:	83 c4 10             	add    $0x10,%esp
	hw_timer_tick_timer += tick_p;
 804b298:	a1 70 18 05 08       	mov    0x8051870,%eax
 804b29d:	8b 15 74 18 05 08    	mov    0x8051874,%edx
 804b2a3:	01 05 80 18 05 08    	add    %eax,0x8051880
 804b2a9:	11 15 84 18 05 08    	adc    %edx,0x8051884
	hwtimer_update_timer();
 804b2af:	e8 98 fa ff ff       	call   804ad4c <hwtimer_update_timer>
	if (silent_ticks > 0) {
 804b2b4:	a1 68 18 05 08       	mov    0x8051868,%eax
 804b2b9:	31 c9                	xor    %ecx,%ecx
 804b2bb:	8b 15 6c 18 05 08    	mov    0x805186c,%edx
 804b2c1:	39 c1                	cmp    %eax,%ecx
 804b2c3:	19 d1                	sbb    %edx,%ecx
 804b2c5:	7d 13                	jge    804b2da <hwtimer_timer_reached+0x1b9>
		silent_ticks -= 1;
 804b2c7:	83 c0 ff             	add    $0xffffffff,%eax
 804b2ca:	83 d2 ff             	adc    $0xffffffff,%edx
 804b2cd:	a3 68 18 05 08       	mov    %eax,0x8051868
 804b2d2:	89 15 6c 18 05 08    	mov    %edx,0x805186c
 804b2d8:	eb 0d                	jmp    804b2e7 <hwtimer_timer_reached+0x1c6>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
 804b2da:	83 ec 0c             	sub    $0xc,%esp
 804b2dd:	6a 00                	push   $0x0
 804b2df:	e8 ef 03 00 00       	call   804b6d3 <hw_irq_ctrl_set_irq>
 804b2e4:	83 c4 10             	add    $0x10,%esp
}
 804b2e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b2ea:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804b2f1:	74 05                	je     804b2f8 <hwtimer_timer_reached+0x1d7>
 804b2f3:	e8 d8 de ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804b2f8:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b2fb:	5e                   	pop    %esi
 804b2fc:	5f                   	pop    %edi
 804b2fd:	5d                   	pop    %ebp
 804b2fe:	c3                   	ret    

0804b2ff <hwtimer_set_silent_ticks>:
{
 804b2ff:	55                   	push   %ebp
 804b300:	89 e5                	mov    %esp,%ebp
	silent_ticks = sys_ticks;
 804b302:	8b 45 08             	mov    0x8(%ebp),%eax
 804b305:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804b308:	5d                   	pop    %ebp
	silent_ticks = sys_ticks;
 804b309:	a3 68 18 05 08       	mov    %eax,0x8051868
 804b30e:	89 15 6c 18 05 08    	mov    %edx,0x805186c
}
 804b314:	c3                   	ret    

0804b315 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
 804b315:	55                   	push   %ebp
 804b316:	89 e5                	mov    %esp,%ebp
 804b318:	57                   	push   %edi
 804b319:	56                   	push   %esi
 804b31a:	53                   	push   %ebx
 804b31b:	83 ec 0c             	sub    $0xc,%esp
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
 804b31e:	e8 36 03 00 00       	call   804b659 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
 804b323:	85 c0                	test   %eax,%eax
 804b325:	0f 85 f9 00 00 00    	jne    804b424 <posix_irq_handler+0x10f>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
 804b32b:	a1 20 18 05 08       	mov    0x8051820,%eax
 804b330:	85 c0                	test   %eax,%eax
 804b332:	75 0a                	jne    804b33e <posix_irq_handler+0x29>
		may_swap = 0;
 804b334:	c7 05 24 19 05 08 00 	movl   $0x0,0x8051924
 804b33b:	00 00 00 
	}

	_kernel.cpus[0].nested++;
 804b33e:	40                   	inc    %eax
 804b33f:	a3 20 18 05 08       	mov    %eax,0x8051820

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
 804b344:	e8 7c 02 00 00       	call   804b5c5 <hw_irq_ctrl_get_highest_prio_irq>
 804b349:	89 c3                	mov    %eax,%ebx
 804b34b:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b34e:	0f 84 9b 00 00 00    	je     804b3ef <posix_irq_handler+0xda>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804b354:	e8 47 02 00 00       	call   804b5a0 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b359:	83 ec 0c             	sub    $0xc,%esp
		int last_running_irq = currently_running_irq;
 804b35c:	8b 3d c0 11 05 08    	mov    0x80511c0,%edi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b362:	53                   	push   %ebx
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804b363:	89 c6                	mov    %eax,%esi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b365:	e8 4d 02 00 00       	call   804b5b7 <hw_irq_ctrl_get_prio>
 804b36a:	0f b6 c0             	movzbl %al,%eax
 804b36d:	89 04 24             	mov    %eax,(%esp)
 804b370:	e8 1e 02 00 00       	call   804b593 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
 804b375:	89 1c 24             	mov    %ebx,(%esp)
 804b378:	e8 19 03 00 00       	call   804b696 <hw_irq_ctrl_clear_irq>
 804b37d:	83 c4 10             	add    $0x10,%esp

		currently_running_irq = irq_nbr;
 804b380:	89 1d c0 11 05 08    	mov    %ebx,0x80511c0
	sys_trace_isr_enter();
 804b386:	e8 5a ef ff ff       	call   804a2e5 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
 804b38b:	89 d8                	mov    %ebx,%eax
 804b38d:	c1 e0 04             	shl    $0x4,%eax
 804b390:	05 40 14 05 08       	add    $0x8051440,%eax
 804b395:	8b 50 08             	mov    0x8(%eax),%edx
 804b398:	85 d2                	test   %edx,%edx
 804b39a:	75 12                	jne    804b3ae <posix_irq_handler+0x99>
		posix_print_error_and_exit("Received irq %i without a "
 804b39c:	50                   	push   %eax
 804b39d:	50                   	push   %eax
 804b39e:	53                   	push   %ebx
 804b39f:	68 91 e9 04 08       	push   $0x804e991
 804b3a4:	e8 3b 05 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804b3a9:	83 c4 10             	add    $0x10,%esp
 804b3ac:	eb 25                	jmp    804b3d3 <posix_irq_handler+0xbe>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
 804b3ae:	f6 40 04 01          	testb  $0x1,0x4(%eax)
 804b3b2:	74 0a                	je     804b3be <posix_irq_handler+0xa9>
			*may_swap |= ((direct_irq_f_ptr)
 804b3b4:	ff d2                	call   *%edx
 804b3b6:	09 05 24 19 05 08    	or     %eax,0x8051924
 804b3bc:	eb 15                	jmp    804b3d3 <posix_irq_handler+0xbe>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804b3be:	83 ec 0c             	sub    $0xc,%esp
 804b3c1:	ff 70 0c             	push   0xc(%eax)
 804b3c4:	ff d2                	call   *%edx
			*may_swap = 1;
 804b3c6:	c7 05 24 19 05 08 01 	movl   $0x1,0x8051924
 804b3cd:	00 00 00 
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804b3d0:	83 c4 10             	add    $0x10,%esp
	sys_trace_isr_exit();
 804b3d3:	e8 0e ef ff ff       	call   804a2e6 <sys_trace_isr_exit>
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804b3d8:	83 ec 0c             	sub    $0xc,%esp
		currently_running_irq = last_running_irq;
 804b3db:	89 3d c0 11 05 08    	mov    %edi,0x80511c0
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804b3e1:	56                   	push   %esi
 804b3e2:	e8 ac 01 00 00       	call   804b593 <hw_irq_ctrl_set_cur_prio>
 804b3e7:	83 c4 10             	add    $0x10,%esp
 804b3ea:	e9 55 ff ff ff       	jmp    804b344 <posix_irq_handler+0x2f>
	}

	_kernel.cpus[0].nested--;
 804b3ef:	ff 0d 20 18 05 08    	decl   0x8051820
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
 804b3f5:	83 3d 24 19 05 08 00 	cmpl   $0x0,0x8051924
 804b3fc:	74 26                	je     804b424 <posix_irq_handler+0x10f>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
 804b3fe:	e8 9d 01 00 00       	call   804b5a0 <hw_irq_ctrl_get_cur_prio>
 804b403:	3d 00 01 00 00       	cmp    $0x100,%eax
 804b408:	75 1a                	jne    804b424 <posix_irq_handler+0x10f>
		&& (_kernel.ready_q.cache != _current)) {
 804b40a:	a1 28 18 05 08       	mov    0x8051828,%eax
 804b40f:	39 05 34 18 05 08    	cmp    %eax,0x8051834
 804b415:	74 0d                	je     804b424 <posix_irq_handler+0x10f>

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
 804b417:	83 ec 0c             	sub    $0xc,%esp
 804b41a:	6a 00                	push   $0x0
 804b41c:	e8 68 f3 ff ff       	call   804a789 <arch_swap>
 804b421:	83 c4 10             	add    $0x10,%esp

		(void)z_swap_irqlock(irq_lock);
	}
}
 804b424:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b427:	5b                   	pop    %ebx
 804b428:	5e                   	pop    %esi
 804b429:	5f                   	pop    %edi
 804b42a:	5d                   	pop    %ebp
 804b42b:	c3                   	ret    

0804b42c <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
 804b42c:	55                   	push   %ebp
 804b42d:	89 e5                	mov    %esp,%ebp
 804b42f:	83 ec 08             	sub    $0x8,%esp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
 804b432:	e8 8e 01 00 00       	call   804b5c5 <hw_irq_ctrl_get_highest_prio_irq>
 804b437:	40                   	inc    %eax
 804b438:	74 23                	je     804b45d <posix_irq_handler_im_from_sw+0x31>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
 804b43a:	e8 4e f4 ff ff       	call   804a88d <posix_is_cpu_running>
 804b43f:	85 c0                	test   %eax,%eax
 804b441:	75 14                	jne    804b457 <posix_irq_handler_im_from_sw+0x2b>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
 804b443:	50                   	push   %eax
 804b444:	50                   	push   %eax
 804b445:	68 f0 e0 04 08       	push   $0x804e0f0
 804b44a:	68 bf e9 04 08       	push   $0x804e9bf
 804b44f:	e8 90 04 00 00       	call   804b8e4 <posix_print_error_and_exit>
 804b454:	83 c4 10             	add    $0x10,%esp
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
 804b457:	c9                   	leave  
		posix_irq_handler();
 804b458:	e9 b8 fe ff ff       	jmp    804b315 <posix_irq_handler>
}
 804b45d:	c9                   	leave  
 804b45e:	c3                   	ret    

0804b45f <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
 804b45f:	55                   	push   %ebp
 804b460:	89 e5                	mov    %esp,%ebp
 804b462:	83 ec 14             	sub    $0x14,%esp
	return hw_irq_ctrl_change_lock(true);
 804b465:	6a 01                	push   $0x1
 804b467:	e8 f5 01 00 00       	call   804b661 <hw_irq_ctrl_change_lock>
 804b46c:	83 c4 10             	add    $0x10,%esp
}
 804b46f:	c9                   	leave  
 804b470:	c3                   	ret    

0804b471 <posix_irq_unlock>:
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
 804b471:	e9 eb 01 00 00       	jmp    804b661 <hw_irq_ctrl_change_lock>

0804b476 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
 804b476:	55                   	push   %ebp
 804b477:	89 e5                	mov    %esp,%ebp
 804b479:	83 ec 14             	sub    $0x14,%esp
	hw_irq_ctrl_change_lock(false);
 804b47c:	6a 00                	push   $0x0
 804b47e:	e8 de 01 00 00       	call   804b661 <hw_irq_ctrl_change_lock>
 804b483:	83 c4 10             	add    $0x10,%esp
}
 804b486:	c9                   	leave  
 804b487:	c3                   	ret    

0804b488 <posix_irq_enable>:

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
 804b488:	e9 9d 02 00 00       	jmp    804b72a <hw_irq_ctrl_enable_irq>

0804b48d <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
 804b48d:	55                   	push   %ebp
 804b48e:	89 e5                	mov    %esp,%ebp
 804b490:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_vector_table[irq_p].irq   = irq_p;
 804b493:	89 ca                	mov    %ecx,%edx
 804b495:	c1 e2 04             	shl    $0x4,%edx
 804b498:	8d 82 40 14 05 08    	lea    0x8051440(%edx),%eax
 804b49e:	89 8a 40 14 05 08    	mov    %ecx,0x8051440(%edx)
	irq_vector_table[irq_p].func  = isr_p;
 804b4a4:	8b 55 10             	mov    0x10(%ebp),%edx
 804b4a7:	89 50 08             	mov    %edx,0x8(%eax)
	irq_vector_table[irq_p].param = isr_param_p;
 804b4aa:	8b 55 14             	mov    0x14(%ebp),%edx
 804b4ad:	89 50 0c             	mov    %edx,0xc(%eax)
	irq_vector_table[irq_p].flags = flags;
 804b4b0:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b4b3:	89 50 04             	mov    %edx,0x4(%eax)
}
 804b4b6:	5d                   	pop    %ebp
 804b4b7:	c3                   	ret    

0804b4b8 <posix_irq_priority_set>:
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
 804b4b8:	e9 e9 00 00 00       	jmp    804b5a6 <hw_irq_ctrl_prio_set>

0804b4bd <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
 804b4bd:	80 3d 75 19 05 08 00 	cmpb   $0x0,0x8051975
 804b4c4:	74 09                	je     804b4cf <irq_raising_from_hw_now+0x12>
 804b4c6:	80 3d 74 19 05 08 00 	cmpb   $0x0,0x8051974
 804b4cd:	74 0c                	je     804b4db <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
 804b4cf:	c6 05 74 19 05 08 00 	movb   $0x0,0x8051974
		posix_interrupt_raised();
 804b4d6:	e9 40 f4 ff ff       	jmp    804a91b <posix_interrupt_raised>
	}
}
 804b4db:	c3                   	ret    

0804b4dc <hw_irq_ctrl_irq_raise_prefix>:
{
 804b4dc:	89 c1                	mov    %eax,%ecx
	if (irq < N_IRQS) {
 804b4de:	83 f8 1f             	cmp    $0x1f,%eax
 804b4e1:	77 4e                	ja     804b531 <hw_irq_ctrl_irq_raise_prefix+0x55>
{
 804b4e3:	55                   	push   %ebp
		irq_premask |= ((uint64_t)1<<irq);
 804b4e4:	31 c0                	xor    %eax,%eax
 804b4e6:	31 d2                	xor    %edx,%edx
 804b4e8:	f6 c1 20             	test   $0x20,%cl
 804b4eb:	0f 94 c0             	sete   %al
 804b4ee:	0f 95 c2             	setne  %dl
 804b4f1:	d3 e2                	shl    %cl,%edx
 804b4f3:	d3 e0                	shl    %cl,%eax
 804b4f5:	09 15 9c 18 05 08    	or     %edx,0x805189c
{
 804b4fb:	89 e5                	mov    %esp,%ebp
 804b4fd:	56                   	push   %esi
		if (irq_mask & (1 << irq)) {
 804b4fe:	be 01 00 00 00       	mov    $0x1,%esi
 804b503:	d3 e6                	shl    %cl,%esi
{
 804b505:	53                   	push   %ebx
		if (irq_mask & (1 << irq)) {
 804b506:	8b 0d 94 18 05 08    	mov    0x8051894,%ecx
 804b50c:	89 f3                	mov    %esi,%ebx
 804b50e:	23 35 90 18 05 08    	and    0x8051890,%esi
		irq_premask |= ((uint64_t)1<<irq);
 804b514:	09 05 98 18 05 08    	or     %eax,0x8051898
		if (irq_mask & (1 << irq)) {
 804b51a:	c1 fb 1f             	sar    $0x1f,%ebx
 804b51d:	21 d9                	and    %ebx,%ecx
 804b51f:	09 f1                	or     %esi,%ecx
 804b521:	74 1d                	je     804b540 <hw_irq_ctrl_irq_raise_prefix+0x64>
			irq_status |= ((uint64_t)1<<irq);
 804b523:	09 05 a0 18 05 08    	or     %eax,0x80518a0
 804b529:	09 15 a4 18 05 08    	or     %edx,0x80518a4
 804b52f:	eb 0f                	jmp    804b540 <hw_irq_ctrl_irq_raise_prefix+0x64>
	} else if (irq == PHONY_HARD_IRQ) {
 804b531:	3d ff ff 00 00       	cmp    $0xffff,%eax
 804b536:	75 0c                	jne    804b544 <hw_irq_ctrl_irq_raise_prefix+0x68>
		lock_ignore = true;
 804b538:	c6 05 74 19 05 08 01 	movb   $0x1,0x8051974
}
 804b53f:	c3                   	ret    
 804b540:	5b                   	pop    %ebx
 804b541:	5e                   	pop    %esi
 804b542:	5d                   	pop    %ebp
 804b543:	c3                   	ret    
 804b544:	c3                   	ret    

0804b545 <hw_irq_ctrl_init>:
{
 804b545:	55                   	push   %ebp
		irq_prio[i] = 255U;
 804b546:	ba 40 16 05 08       	mov    $0x8051640,%edx
 804b54b:	b9 20 00 00 00       	mov    $0x20,%ecx
 804b550:	b0 ff                	mov    $0xff,%al
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804b552:	c7 05 90 18 05 08 00 	movl   $0x0,0x8051890
 804b559:	00 00 00 
 804b55c:	c7 05 94 18 05 08 00 	movl   $0x0,0x8051894
 804b563:	00 00 00 
{
 804b566:	89 e5                	mov    %esp,%ebp
 804b568:	57                   	push   %edi
		irq_prio[i] = 255U;
 804b569:	89 d7                	mov    %edx,%edi
 804b56b:	f3 aa                	rep stos %al,%es:(%edi)
	irqs_locked = false;
 804b56d:	c6 05 75 19 05 08 00 	movb   $0x0,0x8051975
	irq_premask = 0U;
 804b574:	c7 05 98 18 05 08 00 	movl   $0x0,0x8051898
 804b57b:	00 00 00 
}
 804b57e:	5f                   	pop    %edi
	lock_ignore = false;
 804b57f:	c6 05 74 19 05 08 00 	movb   $0x0,0x8051974
	irq_premask = 0U;
 804b586:	c7 05 9c 18 05 08 00 	movl   $0x0,0x805189c
 804b58d:	00 00 00 
}
 804b590:	5d                   	pop    %ebp
 804b591:	c3                   	ret    

0804b592 <hw_irq_ctrl_cleanup>:
}
 804b592:	c3                   	ret    

0804b593 <hw_irq_ctrl_set_cur_prio>:
{
 804b593:	55                   	push   %ebp
 804b594:	89 e5                	mov    %esp,%ebp
	currently_running_prio = new;
 804b596:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b599:	5d                   	pop    %ebp
	currently_running_prio = new;
 804b59a:	a3 c4 11 05 08       	mov    %eax,0x80511c4
}
 804b59f:	c3                   	ret    

0804b5a0 <hw_irq_ctrl_get_cur_prio>:
}
 804b5a0:	a1 c4 11 05 08       	mov    0x80511c4,%eax
 804b5a5:	c3                   	ret    

0804b5a6 <hw_irq_ctrl_prio_set>:
{
 804b5a6:	55                   	push   %ebp
 804b5a7:	89 e5                	mov    %esp,%ebp
	irq_prio[irq] = prio;
 804b5a9:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5ac:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804b5af:	5d                   	pop    %ebp
	irq_prio[irq] = prio;
 804b5b0:	88 90 40 16 05 08    	mov    %dl,0x8051640(%eax)
}
 804b5b6:	c3                   	ret    

0804b5b7 <hw_irq_ctrl_get_prio>:
{
 804b5b7:	55                   	push   %ebp
 804b5b8:	89 e5                	mov    %esp,%ebp
	return irq_prio[irq];
 804b5ba:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b5bd:	5d                   	pop    %ebp
	return irq_prio[irq];
 804b5be:	8a 80 40 16 05 08    	mov    0x8051640(%eax),%al
}
 804b5c4:	c3                   	ret    

0804b5c5 <hw_irq_ctrl_get_highest_prio_irq>:
		return -1;
 804b5c5:	83 ca ff             	or     $0xffffffff,%edx
	if (irqs_locked) {
 804b5c8:	80 3d 75 19 05 08 00 	cmpb   $0x0,0x8051975
 804b5cf:	0f 85 81 00 00 00    	jne    804b656 <hw_irq_ctrl_get_highest_prio_irq+0x91>
{
 804b5d5:	55                   	push   %ebp
 804b5d6:	89 e5                	mov    %esp,%ebp
 804b5d8:	57                   	push   %edi
 804b5d9:	56                   	push   %esi
 804b5da:	53                   	push   %ebx
	int winner_prio = 256;
 804b5db:	bb 00 01 00 00       	mov    $0x100,%ebx
{
 804b5e0:	83 ec 14             	sub    $0x14,%esp
	return irq_status;
 804b5e3:	8b 3d a4 18 05 08    	mov    0x80518a4,%edi
 804b5e9:	a1 a0 18 05 08       	mov    0x80518a0,%eax
 804b5ee:	89 7d e4             	mov    %edi,-0x1c(%ebp)
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804b5f1:	8b 3d c4 11 05 08    	mov    0x80511c4,%edi
 804b5f7:	89 7d e0             	mov    %edi,-0x20(%ebp)
	while (irq_status != 0U) {
 804b5fa:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804b5fd:	09 c1                	or     %eax,%ecx
 804b5ff:	74 4b                	je     804b64c <hw_irq_ctrl_get_highest_prio_irq+0x87>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
 804b601:	0f bc c8             	bsf    %eax,%ecx
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804b604:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b609:	be 01 00 00 00       	mov    $0x1,%esi
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804b60e:	0f 44 cf             	cmove  %edi,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b611:	31 ff                	xor    %edi,%edi
 804b613:	0f a5 f7             	shld   %cl,%esi,%edi
 804b616:	d3 e6                	shl    %cl,%esi
 804b618:	f6 c1 20             	test   $0x20,%cl
 804b61b:	74 04                	je     804b621 <hw_irq_ctrl_get_highest_prio_irq+0x5c>
 804b61d:	89 f7                	mov    %esi,%edi
 804b61f:	31 f6                	xor    %esi,%esi
 804b621:	89 75 e8             	mov    %esi,-0x18(%ebp)
 804b624:	8b 75 e8             	mov    -0x18(%ebp),%esi
 804b627:	89 7d ec             	mov    %edi,-0x14(%ebp)
 804b62a:	8b 7d ec             	mov    -0x14(%ebp),%edi
 804b62d:	f7 d6                	not    %esi
 804b62f:	21 f0                	and    %esi,%eax
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804b631:	0f b6 b1 40 16 05 08 	movzbl 0x8051640(%ecx),%esi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b638:	f7 d7                	not    %edi
 804b63a:	21 7d e4             	and    %edi,-0x1c(%ebp)
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804b63d:	39 de                	cmp    %ebx,%esi
 804b63f:	7d b9                	jge    804b5fa <hw_irq_ctrl_get_highest_prio_irq+0x35>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804b641:	3b 75 e0             	cmp    -0x20(%ebp),%esi
 804b644:	0f 4c de             	cmovl  %esi,%ebx
 804b647:	0f 4c d1             	cmovl  %ecx,%edx
 804b64a:	eb ae                	jmp    804b5fa <hw_irq_ctrl_get_highest_prio_irq+0x35>
}
 804b64c:	83 c4 14             	add    $0x14,%esp
 804b64f:	89 d0                	mov    %edx,%eax
 804b651:	5b                   	pop    %ebx
 804b652:	5e                   	pop    %esi
 804b653:	5f                   	pop    %edi
 804b654:	5d                   	pop    %ebp
 804b655:	c3                   	ret    
 804b656:	89 d0                	mov    %edx,%eax
 804b658:	c3                   	ret    

0804b659 <hw_irq_ctrl_get_current_lock>:
	return irqs_locked;
 804b659:	0f b6 05 75 19 05 08 	movzbl 0x8051975,%eax
}
 804b660:	c3                   	ret    

0804b661 <hw_irq_ctrl_change_lock>:
{
 804b661:	55                   	push   %ebp
 804b662:	89 e5                	mov    %esp,%ebp
 804b664:	53                   	push   %ebx
 804b665:	51                   	push   %ecx
	irqs_locked = new_lock;
 804b666:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
	uint32_t previous_lock = irqs_locked;
 804b66a:	0f b6 1d 75 19 05 08 	movzbl 0x8051975,%ebx
	irqs_locked = new_lock;
 804b671:	0f 95 05 75 19 05 08 	setne  0x8051975
	if ((previous_lock == true) && (new_lock == false)) {
 804b678:	75 16                	jne    804b690 <hw_irq_ctrl_change_lock+0x2f>
 804b67a:	84 db                	test   %bl,%bl
 804b67c:	74 12                	je     804b690 <hw_irq_ctrl_change_lock+0x2f>
		if (irq_status != 0U) {
 804b67e:	a1 a4 18 05 08       	mov    0x80518a4,%eax
 804b683:	0b 05 a0 18 05 08    	or     0x80518a0,%eax
 804b689:	74 05                	je     804b690 <hw_irq_ctrl_change_lock+0x2f>
			posix_irq_handler_im_from_sw();
 804b68b:	e8 9c fd ff ff       	call   804b42c <posix_irq_handler_im_from_sw>
}
 804b690:	89 d8                	mov    %ebx,%eax
 804b692:	5a                   	pop    %edx
 804b693:	5b                   	pop    %ebx
 804b694:	5d                   	pop    %ebp
 804b695:	c3                   	ret    

0804b696 <hw_irq_ctrl_clear_irq>:
{
 804b696:	55                   	push   %ebp
 804b697:	89 e5                	mov    %esp,%ebp
 804b699:	57                   	push   %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804b69a:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
 804b69d:	56                   	push   %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804b69e:	89 cf                	mov    %ecx,%edi
 804b6a0:	c1 ef 05             	shr    $0x5,%edi
 804b6a3:	83 e7 01             	and    $0x1,%edi
 804b6a6:	89 fe                	mov    %edi,%esi
 804b6a8:	d3 e7                	shl    %cl,%edi
 804b6aa:	83 f6 01             	xor    $0x1,%esi
 804b6ad:	89 f8                	mov    %edi,%eax
 804b6af:	d3 e6                	shl    %cl,%esi
 804b6b1:	f7 d0                	not    %eax
 804b6b3:	21 05 a4 18 05 08    	and    %eax,0x80518a4
 804b6b9:	89 f2                	mov    %esi,%edx
	irq_premask &= ~((uint64_t)1<<irq);
 804b6bb:	21 05 9c 18 05 08    	and    %eax,0x805189c
}
 804b6c1:	5e                   	pop    %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804b6c2:	f7 d2                	not    %edx
}
 804b6c4:	5f                   	pop    %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804b6c5:	21 15 a0 18 05 08    	and    %edx,0x80518a0
	irq_premask &= ~((uint64_t)1<<irq);
 804b6cb:	21 15 98 18 05 08    	and    %edx,0x8051898
}
 804b6d1:	5d                   	pop    %ebp
 804b6d2:	c3                   	ret    

0804b6d3 <hw_irq_ctrl_set_irq>:
{
 804b6d3:	55                   	push   %ebp
 804b6d4:	89 e5                	mov    %esp,%ebp
 804b6d6:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804b6d9:	8b 45 08             	mov    0x8(%ebp),%eax
 804b6dc:	e8 fb fd ff ff       	call   804b4dc <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
 804b6e1:	80 3d 75 19 05 08 00 	cmpb   $0x0,0x8051975
 804b6e8:	74 09                	je     804b6f3 <hw_irq_ctrl_set_irq+0x20>
 804b6ea:	80 3d 74 19 05 08 00 	cmpb   $0x0,0x8051974
 804b6f1:	74 16                	je     804b709 <hw_irq_ctrl_set_irq+0x36>
		irq_ctrl_timer = hwm_get_time();
 804b6f3:	e8 17 f6 ff ff       	call   804ad0f <hwm_get_time>
 804b6f8:	a3 a8 11 05 08       	mov    %eax,0x80511a8
 804b6fd:	89 15 ac 11 05 08    	mov    %edx,0x80511ac
}
 804b703:	c9                   	leave  
		hwm_find_next_timer();
 804b704:	e9 82 f4 ff ff       	jmp    804ab8b <hwm_find_next_timer>
}
 804b709:	c9                   	leave  
 804b70a:	c3                   	ret    

0804b70b <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
 804b70b:	55                   	push   %ebp
 804b70c:	89 e5                	mov    %esp,%ebp
 804b70e:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804b711:	8b 45 08             	mov    0x8(%ebp),%eax
 804b714:	e8 c3 fd ff ff       	call   804b4dc <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
 804b719:	80 3d 75 19 05 08 00 	cmpb   $0x0,0x8051975
 804b720:	75 06                	jne    804b728 <hw_irq_ctrl_raise_im_from_sw+0x1d>
		posix_irq_handler_im_from_sw();
	}
}
 804b722:	c9                   	leave  
		posix_irq_handler_im_from_sw();
 804b723:	e9 04 fd ff ff       	jmp    804b42c <posix_irq_handler_im_from_sw>
}
 804b728:	c9                   	leave  
 804b729:	c3                   	ret    

0804b72a <hw_irq_ctrl_enable_irq>:
{
 804b72a:	55                   	push   %ebp
	irq_mask |= ((uint64_t)1<<irq);
 804b72b:	31 c0                	xor    %eax,%eax
 804b72d:	31 d2                	xor    %edx,%edx
{
 804b72f:	89 e5                	mov    %esp,%ebp
 804b731:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_mask |= ((uint64_t)1<<irq);
 804b734:	f6 c1 20             	test   $0x20,%cl
 804b737:	0f 94 c0             	sete   %al
 804b73a:	0f 95 c2             	setne  %dl
 804b73d:	d3 e2                	shl    %cl,%edx
 804b73f:	d3 e0                	shl    %cl,%eax
 804b741:	09 15 94 18 05 08    	or     %edx,0x8051894
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804b747:	8b 15 9c 18 05 08    	mov    0x805189c,%edx
	irq_mask |= ((uint64_t)1<<irq);
 804b74d:	09 05 90 18 05 08    	or     %eax,0x8051890
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804b753:	a1 98 18 05 08       	mov    0x8051898,%eax
 804b758:	0f ad d0             	shrd   %cl,%edx,%eax
 804b75b:	d3 ea                	shr    %cl,%edx
 804b75d:	f6 c1 20             	test   $0x20,%cl
 804b760:	74 02                	je     804b764 <hw_irq_ctrl_enable_irq+0x3a>
 804b762:	89 d0                	mov    %edx,%eax
 804b764:	83 e0 01             	and    $0x1,%eax
 804b767:	74 06                	je     804b76f <hw_irq_ctrl_enable_irq+0x45>
}
 804b769:	5d                   	pop    %ebp
		hw_irq_ctrl_raise_im_from_sw(irq);
 804b76a:	e9 9c ff ff ff       	jmp    804b70b <hw_irq_ctrl_raise_im_from_sw>
}
 804b76f:	5d                   	pop    %ebp
 804b770:	c3                   	ret    

0804b771 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
 804b771:	c7 05 a8 11 05 08 ff 	movl   $0xffffffff,0x80511a8
 804b778:	ff ff ff 
 804b77b:	c7 05 ac 11 05 08 ff 	movl   $0xffffffff,0x80511ac
 804b782:	ff ff ff 
	irq_raising_from_hw_now();
 804b785:	e9 33 fd ff ff       	jmp    804b4bd <irq_raising_from_hw_now>

0804b78a <posix_exit>:
#include <zephyr/sys/time_units.h>
#include "cmdline.h"
#include "irq_ctrl.h"

void posix_exit(int exit_code)
{
 804b78a:	55                   	push   %ebp
 804b78b:	89 e5                	mov    %esp,%ebp
 804b78d:	83 ec 08             	sub    $0x8,%esp
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
 804b790:	a1 28 19 05 08       	mov    0x8051928,%eax
 804b795:	8b 55 08             	mov    0x8(%ebp),%edx
 804b798:	39 d0                	cmp    %edx,%eax
 804b79a:	0f 4c c2             	cmovl  %edx,%eax
 804b79d:	a3 28 19 05 08       	mov    %eax,0x8051928
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
 804b7a2:	e8 8b f2 ff ff       	call   804aa32 <posix_soc_clean_up>
	hwm_cleanup();
 804b7a7:	e8 8f f5 ff ff       	call   804ad3b <hwm_cleanup>
	native_cleanup_cmd_line();
 804b7ac:	e8 55 08 00 00       	call   804c006 <native_cleanup_cmd_line>
	exit(max_exit_code);
 804b7b1:	83 ec 0c             	sub    $0xc,%esp
 804b7b4:	ff 35 28 19 05 08    	push   0x8051928
 804b7ba:	e8 d1 da ff ff       	call   8049290 <exit@plt>

0804b7bf <posix_init>:
 * Run all early native_posix initialization steps, including command
 * line parsing and CPU start, until we are ready to let the HW models
 * run via hwm_one_event()
 */
void posix_init(int argc, char *argv[])
{
 804b7bf:	55                   	push   %ebp
 804b7c0:	89 e5                	mov    %esp,%ebp
 804b7c2:	56                   	push   %esi
 804b7c3:	53                   	push   %ebx
 804b7c4:	8b 75 0c             	mov    0xc(%ebp),%esi
	 * Let's ensure that even if we are redirecting to a file, we get stdout
	 * and stderr line buffered (default for console)
	 * Note that glibc ignores size. But just in case we set a reasonable
	 * number in case somebody tries to compile against a different library
	 */
	setvbuf(stdout, NULL, _IOLBF, 512);
 804b7c7:	68 00 02 00 00       	push   $0x200
{
 804b7cc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	setvbuf(stdout, NULL, _IOLBF, 512);
 804b7cf:	6a 01                	push   $0x1
 804b7d1:	6a 00                	push   $0x0
 804b7d3:	ff 35 84 12 05 08    	push   0x8051284
 804b7d9:	e8 d2 d9 ff ff       	call   80491b0 <setvbuf@plt>
 804b7de:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
 804b7e1:	68 00 02 00 00       	push   $0x200
 804b7e6:	6a 01                	push   $0x1
 804b7e8:	6a 00                	push   $0x0
 804b7ea:	ff 35 80 12 05 08    	push   0x8051280
 804b7f0:	e8 bb d9 ff ff       	call   80491b0 <setvbuf@plt>

	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
 804b7f5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b7fc:	e8 08 f2 ff ff       	call   804aa09 <run_native_tasks>
 804b801:	58                   	pop    %eax
 804b802:	5a                   	pop    %edx

	native_handle_cmd_line(argc, argv);
 804b803:	56                   	push   %esi
 804b804:	53                   	push   %ebx
 804b805:	e8 d0 08 00 00       	call   804c0da <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
 804b80a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804b811:	e8 f3 f1 ff ff       	call   804aa09 <run_native_tasks>
 804b816:	83 c4 10             	add    $0x10,%esp

	hwm_init();
 804b819:	e8 fd f4 ff ff       	call   804ad1b <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
 804b81e:	83 ec 0c             	sub    $0xc,%esp
 804b821:	6a 02                	push   $0x2
 804b823:	e8 e1 f1 ff ff       	call   804aa09 <run_native_tasks>
 804b828:	83 c4 10             	add    $0x10,%esp

	posix_boot_cpu();
 804b82b:	e8 29 f1 ff ff       	call   804a959 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
 804b830:	c7 45 08 03 00 00 00 	movl   $0x3,0x8(%ebp)
}
 804b837:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b83a:	5b                   	pop    %ebx
 804b83b:	5e                   	pop    %esi
 804b83c:	5d                   	pop    %ebp
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
 804b83d:	e9 c7 f1 ff ff       	jmp    804aa09 <run_native_tasks>

0804b842 <main>:
 *
 * Not used when building fuzz cases, as libfuzzer has its own main()
 * and calls the "OS" through a per-case fuzz test entry point.
 */
int main(int argc, char *argv[])
{
 804b842:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 804b846:	83 e4 f0             	and    $0xfffffff0,%esp
 804b849:	ff 71 fc             	push   -0x4(%ecx)
 804b84c:	55                   	push   %ebp
 804b84d:	89 e5                	mov    %esp,%ebp
 804b84f:	51                   	push   %ecx
 804b850:	83 ec 0c             	sub    $0xc,%esp
	posix_init(argc, argv);
 804b853:	ff 71 04             	push   0x4(%ecx)
 804b856:	ff 31                	push   (%ecx)
 804b858:	e8 62 ff ff ff       	call   804b7bf <posix_init>
 804b85d:	83 c4 10             	add    $0x10,%esp
	while (true) {
		hwm_one_event();
 804b860:	e8 a7 f3 ff ff       	call   804ac0c <hwm_one_event>
	while (true) {
 804b865:	eb f9                	jmp    804b860 <main+0x1e>

0804b867 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
 804b867:	c7 05 c8 11 05 08 00 	movl   $0x0,0x80511c8
 804b86e:	00 00 00 
	is_a_tty[1] = 0;
 804b871:	c7 05 cc 11 05 08 00 	movl   $0x0,0x80511cc
 804b878:	00 00 00 
}
 804b87b:	c3                   	ret    

0804b87c <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
 804b87c:	c7 05 c8 11 05 08 ff 	movl   $0xffffffff,0x80511c8
 804b883:	ff ff ff 
	is_a_tty[1] = -1;
 804b886:	c7 05 cc 11 05 08 ff 	movl   $0xffffffff,0x80511cc
 804b88d:	ff ff ff 

}
 804b890:	c3                   	ret    

0804b891 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
 804b891:	c7 05 c8 11 05 08 01 	movl   $0x1,0x80511c8
 804b898:	00 00 00 
	is_a_tty[1] = 1;
 804b89b:	c7 05 cc 11 05 08 01 	movl   $0x1,0x80511cc
 804b8a2:	00 00 00 
}
 804b8a5:	c3                   	ret    

0804b8a6 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
 804b8a6:	55                   	push   %ebp
 804b8a7:	89 e5                	mov    %esp,%ebp
 804b8a9:	83 ec 08             	sub    $0x8,%esp
	if (is_a_tty[0] == -1) {
 804b8ac:	83 3d c8 11 05 08 ff 	cmpl   $0xffffffff,0x80511c8
 804b8b3:	75 12                	jne    804b8c7 <decide_about_color+0x21>
		is_a_tty[0] = isatty(STDOUT_FILENO);
 804b8b5:	83 ec 0c             	sub    $0xc,%esp
 804b8b8:	6a 01                	push   $0x1
 804b8ba:	e8 81 d8 ff ff       	call   8049140 <isatty@plt>
 804b8bf:	83 c4 10             	add    $0x10,%esp
 804b8c2:	a3 c8 11 05 08       	mov    %eax,0x80511c8
	}
	if (is_a_tty[1] == -1) {
 804b8c7:	83 3d cc 11 05 08 ff 	cmpl   $0xffffffff,0x80511cc
 804b8ce:	75 12                	jne    804b8e2 <decide_about_color+0x3c>
		is_a_tty[1] = isatty(STDERR_FILENO);
 804b8d0:	83 ec 0c             	sub    $0xc,%esp
 804b8d3:	6a 02                	push   $0x2
 804b8d5:	e8 66 d8 ff ff       	call   8049140 <isatty@plt>
 804b8da:	83 c4 10             	add    $0x10,%esp
 804b8dd:	a3 cc 11 05 08       	mov    %eax,0x80511cc
	}
}
 804b8e2:	c9                   	leave  
 804b8e3:	c3                   	ret    

0804b8e4 <posix_print_error_and_exit>:
{
 804b8e4:	55                   	push   %ebp
 804b8e5:	89 e5                	mov    %esp,%ebp
 804b8e7:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b8ea:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
 804b8ed:	50                   	push   %eax
 804b8ee:	ff 75 08             	push   0x8(%ebp)
 804b8f1:	6a 01                	push   $0x1
 804b8f3:	ff 35 80 12 05 08    	push   0x8051280
 804b8f9:	e8 12 d8 ff ff       	call   8049110 <__vfprintf_chk@plt>
	posix_exit(1);
 804b8fe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804b905:	e8 80 fe ff ff       	call   804b78a <posix_exit>
 804b90a:	83 c4 10             	add    $0x10,%esp
}
 804b90d:	c9                   	leave  
 804b90e:	c3                   	ret    

0804b90f <posix_print_warning>:
{
 804b90f:	55                   	push   %ebp
 804b910:	89 e5                	mov    %esp,%ebp
 804b912:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b915:	8d 45 0c             	lea    0xc(%ebp),%eax
 804b918:	50                   	push   %eax
 804b919:	ff 75 08             	push   0x8(%ebp)
 804b91c:	6a 01                	push   $0x1
 804b91e:	ff 35 80 12 05 08    	push   0x8051280
 804b924:	e8 e7 d7 ff ff       	call   8049110 <__vfprintf_chk@plt>
 804b929:	83 c4 10             	add    $0x10,%esp
}
 804b92c:	c9                   	leave  
 804b92d:	c3                   	ret    

0804b92e <posix_print_trace>:
{
 804b92e:	55                   	push   %ebp
 804b92f:	89 e5                	mov    %esp,%ebp
 804b931:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b934:	8d 45 0c             	lea    0xc(%ebp),%eax
 804b937:	50                   	push   %eax
 804b938:	ff 75 08             	push   0x8(%ebp)
 804b93b:	6a 01                	push   $0x1
 804b93d:	ff 35 84 12 05 08    	push   0x8051284
 804b943:	e8 c8 d7 ff ff       	call   8049110 <__vfprintf_chk@plt>
 804b948:	83 c4 10             	add    $0x10,%esp
}
 804b94b:	c9                   	leave  
 804b94c:	c3                   	ret    

0804b94d <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
 804b94d:	55                   	push   %ebp
 804b94e:	89 e5                	mov    %esp,%ebp
 804b950:	83 ec 14             	sub    $0x14,%esp
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
 804b953:	68 e0 10 05 08       	push   $0x80510e0
 804b958:	e8 ce 06 00 00       	call   804c02b <native_add_command_line_opts>
 804b95d:	83 c4 10             	add    $0x10,%esp
}
 804b960:	c9                   	leave  
 804b961:	c3                   	ret    

0804b962 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
 804b962:	55                   	push   %ebp
 804b963:	89 e5                	mov    %esp,%ebp
 804b965:	57                   	push   %edi
 804b966:	89 d7                	mov    %edx,%edi
 804b968:	56                   	push   %esi
 804b969:	be 46 00 00 00       	mov    $0x46,%esi
 804b96e:	53                   	push   %ebx
 804b96f:	89 c3                	mov    %eax,%ebx
 804b971:	83 ec 1c             	sub    $0x1c,%esp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
 804b974:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
 804b978:	75 09                	jne    804b983 <cmd_gen_switch_syntax.constprop.0+0x21>
		*buf++ = '[';
 804b97a:	c6 00 5b             	movb   $0x5b,(%eax)
 804b97d:	43                   	inc    %ebx
		size--;
 804b97e:	be 45 00 00 00       	mov    $0x45,%esi
	}

	if (args_s_el->is_switch == true) {
 804b983:	80 7f 02 00          	cmpb   $0x0,0x2(%edi)
		ret = snprintf(buf, size, "-%s", args_s_el->option);
 804b987:	8b 47 04             	mov    0x4(%edi),%eax
	if (args_s_el->is_switch == true) {
 804b98a:	74 0a                	je     804b996 <cmd_gen_switch_syntax.constprop.0+0x34>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
 804b98c:	52                   	push   %edx
 804b98d:	52                   	push   %edx
 804b98e:	50                   	push   %eax
 804b98f:	68 ac ea 04 08       	push   $0x804eaac
 804b994:	eb 1b                	jmp    804b9b1 <cmd_gen_switch_syntax.constprop.0+0x4f>
	} else {
		if (args_s_el->type != 'l') {
 804b996:	80 7f 0c 6c          	cmpb   $0x6c,0xc(%edi)
			ret = snprintf(buf, size, "-%s=<%s>",
 804b99a:	8b 57 08             	mov    0x8(%edi),%edx
		if (args_s_el->type != 'l') {
 804b99d:	74 0a                	je     804b9a9 <cmd_gen_switch_syntax.constprop.0+0x47>
 804b99f:	51                   	push   %ecx
 804b9a0:	52                   	push   %edx
 804b9a1:	50                   	push   %eax
 804b9a2:	68 b0 ea 04 08       	push   $0x804eab0
 804b9a7:	eb 08                	jmp    804b9b1 <cmd_gen_switch_syntax.constprop.0+0x4f>
 804b9a9:	51                   	push   %ecx
 804b9aa:	52                   	push   %edx
 804b9ab:	50                   	push   %eax
 804b9ac:	68 b9 ea 04 08       	push   $0x804eab9
 804b9b1:	6a ff                	push   $0xffffffff
 804b9b3:	6a 01                	push   $0x1
 804b9b5:	56                   	push   %esi
 804b9b6:	53                   	push   %ebx
 804b9b7:	e8 54 d8 ff ff       	call   8049210 <__snprintf_chk@plt>
 804b9bc:	83 c4 20             	add    $0x20,%esp
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
 804b9bf:	85 c0                	test   %eax,%eax
 804b9c1:	79 1e                	jns    804b9e1 <cmd_gen_switch_syntax.constprop.0+0x7f>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
 804b9c3:	51                   	push   %ecx
 804b9c4:	68 07 01 00 00       	push   $0x107
 804b9c9:	68 c5 ea 04 08       	push   $0x804eac5
 804b9ce:	68 03 eb 04 08       	push   $0x804eb03
 804b9d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804b9d6:	e8 09 ff ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804b9db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b9de:	83 c4 10             	add    $0x10,%esp
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
 804b9e1:	29 c6                	sub    %eax,%esi
 804b9e3:	78 20                	js     804ba05 <cmd_gen_switch_syntax.constprop.0+0xa3>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
 804b9e5:	01 c3                	add    %eax,%ebx
	size -= ret;

	if (args_s_el->is_mandatory == false) {
 804b9e7:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
 804b9eb:	75 08                	jne    804b9f5 <cmd_gen_switch_syntax.constprop.0+0x93>
 804b9ed:	52                   	push   %edx
 804b9ee:	68 1e eb 04 08       	push   $0x804eb1e
 804b9f3:	eb 06                	jmp    804b9fb <cmd_gen_switch_syntax.constprop.0+0x99>
 804b9f5:	50                   	push   %eax
 804b9f6:	68 1f eb 04 08       	push   $0x804eb1f
 804b9fb:	56                   	push   %esi
 804b9fc:	53                   	push   %ebx
 804b9fd:	e8 2e d8 ff ff       	call   8049230 <snprintf@plt>
 804ba02:	83 c4 10             	add    $0x10,%esp
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
 804ba05:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ba08:	5b                   	pop    %ebx
 804ba09:	5e                   	pop    %esi
 804ba0a:	5f                   	pop    %edi
 804ba0b:	5d                   	pop    %ebp
 804ba0c:	c3                   	ret    

0804ba0d <cmd_is_option>:
{
 804ba0d:	55                   	push   %ebp
 804ba0e:	89 e5                	mov    %esp,%ebp
 804ba10:	57                   	push   %edi
 804ba11:	56                   	push   %esi
 804ba12:	53                   	push   %ebx
 804ba13:	83 ec 28             	sub    $0x28,%esp
 804ba16:	8b 75 0c             	mov    0xc(%ebp),%esi
 804ba19:	8b 7d 08             	mov    0x8(%ebp),%edi
 804ba1c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t to_match_len = strlen(option);
 804ba1f:	56                   	push   %esi
 804ba20:	e8 4b d7 ff ff       	call   8049170 <strlen@plt>
	int of = 0;
 804ba25:	31 c9                	xor    %ecx,%ecx
	size_t to_match_len = strlen(option);
 804ba27:	83 c4 10             	add    $0x10,%esp
	int of = 0;
 804ba2a:	80 3f 2d             	cmpb   $0x2d,(%edi)
 804ba2d:	0f 94 c1             	sete   %cl
	size_t to_match_len = strlen(option);
 804ba30:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (arg[of] == '-') {
 804ba33:	80 3c 0f 2d          	cmpb   $0x2d,(%edi,%ecx,1)
 804ba37:	75 01                	jne    804ba3a <cmd_is_option+0x2d>
		of++;
 804ba39:	41                   	inc    %ecx
	if (!with_value) {
 804ba3a:	85 db                	test   %ebx,%ebx
 804ba3c:	75 20                	jne    804ba5e <cmd_is_option+0x51>
		if (strcmp(&arg[of], option) != 0) {
 804ba3e:	52                   	push   %edx
 804ba3f:	52                   	push   %edx
 804ba40:	8d 14 0f             	lea    (%edi,%ecx,1),%edx
 804ba43:	56                   	push   %esi
 804ba44:	52                   	push   %edx
 804ba45:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 804ba48:	e8 23 d8 ff ff       	call   8049270 <strcmp@plt>
 804ba4d:	83 c4 10             	add    $0x10,%esp
 804ba50:	85 c0                	test   %eax,%eax
 804ba52:	75 4a                	jne    804ba9e <cmd_is_option+0x91>
			return of + to_match_len;
 804ba54:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
 804ba57:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 804ba5a:	01 cb                	add    %ecx,%ebx
 804ba5c:	eb 40                	jmp    804ba9e <cmd_is_option+0x91>
 804ba5e:	89 cb                	mov    %ecx,%ebx
		if (*option == 0) {
 804ba60:	29 ce                	sub    %ecx,%esi
	while (!(arg[of] == 0 && *option == 0)) {
 804ba62:	8a 04 1f             	mov    (%edi,%ebx,1),%al
		if (*option == 0) {
 804ba65:	8a 0c 1e             	mov    (%esi,%ebx,1),%cl
	while (!(arg[of] == 0 && *option == 0)) {
 804ba68:	89 c2                	mov    %eax,%edx
 804ba6a:	08 ca                	or     %cl,%dl
 804ba6c:	74 1c                	je     804ba8a <cmd_is_option+0x7d>
		if (*option == 0) {
 804ba6e:	84 c9                	test   %cl,%cl
 804ba70:	75 11                	jne    804ba83 <cmd_is_option+0x76>
			if ((arg[of] == ':') || (arg[of] == '=')) {
 804ba72:	3c 3a                	cmp    $0x3a,%al
 804ba74:	74 04                	je     804ba7a <cmd_is_option+0x6d>
 804ba76:	3c 3d                	cmp    $0x3d,%al
 804ba78:	75 22                	jne    804ba9c <cmd_is_option+0x8f>
				of++;
 804ba7a:	43                   	inc    %ebx
	if (arg[of] == 0) { /* we need a value to follow */
 804ba7b:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
 804ba7f:	75 1d                	jne    804ba9e <cmd_is_option+0x91>
 804ba81:	eb 07                	jmp    804ba8a <cmd_is_option+0x7d>
		if (arg[of] != *option) {
 804ba83:	38 c8                	cmp    %cl,%al
 804ba85:	75 15                	jne    804ba9c <cmd_is_option+0x8f>
		of++;
 804ba87:	43                   	inc    %ebx
		option++;
 804ba88:	eb d8                	jmp    804ba62 <cmd_is_option+0x55>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
 804ba8a:	50                   	push   %eax
 804ba8b:	50                   	push   %eax
 804ba8c:	57                   	push   %edi
 804ba8d:	68 21 eb 04 08       	push   $0x804eb21
 804ba92:	e8 4d fe ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804ba97:	83 c4 10             	add    $0x10,%esp
 804ba9a:	eb 02                	jmp    804ba9e <cmd_is_option+0x91>
			return 0;
 804ba9c:	31 db                	xor    %ebx,%ebx
}
 804ba9e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804baa1:	89 d8                	mov    %ebx,%eax
 804baa3:	5b                   	pop    %ebx
 804baa4:	5e                   	pop    %esi
 804baa5:	5f                   	pop    %edi
 804baa6:	5d                   	pop    %ebp
 804baa7:	c3                   	ret    

0804baa8 <cmd_is_help_option>:
{
 804baa8:	55                   	push   %ebp
 804baa9:	89 e5                	mov    %esp,%ebp
 804baab:	53                   	push   %ebx
 804baac:	53                   	push   %ebx
 804baad:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (arg[0] == '-') {
 804bab0:	80 3b 2d             	cmpb   $0x2d,(%ebx)
 804bab3:	75 0c                	jne    804bac1 <cmd_is_help_option+0x19>
	if (arg[0] == '-') {
 804bab5:	80 7b 01 2d          	cmpb   $0x2d,0x1(%ebx)
 804bab9:	74 03                	je     804babe <cmd_is_help_option+0x16>
		arg++;
 804babb:	43                   	inc    %ebx
 804babc:	eb 03                	jmp    804bac1 <cmd_is_help_option+0x19>
		arg++;
 804babe:	83 c3 02             	add    $0x2,%ebx
	if ((strcasecmp(arg, "?") == 0) ||
 804bac1:	51                   	push   %ecx
 804bac2:	51                   	push   %ecx
 804bac3:	68 7b eb 04 08       	push   $0x804eb7b
 804bac8:	53                   	push   %ebx
 804bac9:	e8 d2 d6 ff ff       	call   80491a0 <strcasecmp@plt>
 804bace:	83 c4 10             	add    $0x10,%esp
 804bad1:	89 c2                	mov    %eax,%edx
		return 1;
 804bad3:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804bad8:	85 d2                	test   %edx,%edx
 804bada:	74 33                	je     804bb0f <cmd_is_help_option+0x67>
	    (strcasecmp(arg, "h") == 0) ||
 804badc:	52                   	push   %edx
 804badd:	52                   	push   %edx
 804bade:	68 7d eb 04 08       	push   $0x804eb7d
 804bae3:	53                   	push   %ebx
 804bae4:	e8 b7 d6 ff ff       	call   80491a0 <strcasecmp@plt>
 804bae9:	83 c4 10             	add    $0x10,%esp
 804baec:	89 c2                	mov    %eax,%edx
		return 1;
 804baee:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804baf3:	85 d2                	test   %edx,%edx
 804baf5:	74 18                	je     804bb0f <cmd_is_help_option+0x67>
	    (strcasecmp(arg, "help") == 0)) {
 804baf7:	50                   	push   %eax
 804baf8:	50                   	push   %eax
 804baf9:	68 1f ec 04 08       	push   $0x804ec1f
 804bafe:	53                   	push   %ebx
 804baff:	e8 9c d6 ff ff       	call   80491a0 <strcasecmp@plt>
 804bb04:	83 c4 10             	add    $0x10,%esp
	    (strcasecmp(arg, "h") == 0) ||
 804bb07:	85 c0                	test   %eax,%eax
 804bb09:	0f 94 c0             	sete   %al
 804bb0c:	0f b6 c0             	movzbl %al,%eax
}
 804bb0f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804bb12:	c9                   	leave  
 804bb13:	c3                   	ret    

0804bb14 <cmd_read_option_value>:
{
 804bb14:	55                   	push   %ebp
 804bb15:	89 e5                	mov    %esp,%ebp
 804bb17:	57                   	push   %edi
 804bb18:	56                   	push   %esi
 804bb19:	53                   	push   %ebx
 804bb1a:	83 ec 1c             	sub    $0x1c,%esp
 804bb1d:	8b 45 10             	mov    0x10(%ebp),%eax
 804bb20:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bb23:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 804bb2a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804bb2d:	31 d2                	xor    %edx,%edx
 804bb2f:	8b 75 0c             	mov    0xc(%ebp),%esi
 804bb32:	8b 7d 14             	mov    0x14(%ebp),%edi
	char *endptr = NULL;
 804bb35:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	switch (type) {
 804bb3c:	3c 64                	cmp    $0x64,%al
 804bb3e:	0f 84 18 01 00 00    	je     804bc5c <cmd_read_option_value+0x148>
 804bb44:	7f 26                	jg     804bb6c <cmd_read_option_value+0x58>
 804bb46:	3c 55                	cmp    $0x55,%al
 804bb48:	0f 84 ee 00 00 00    	je     804bc3c <cmd_read_option_value+0x128>
 804bb4e:	3c 62                	cmp    $0x62,%al
 804bb50:	74 44                	je     804bb96 <cmd_read_option_value+0x82>
 804bb52:	3c 49                	cmp    $0x49,%al
 804bb54:	0f 85 15 01 00 00    	jne    804bc6f <cmd_read_option_value+0x15b>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804bb5a:	50                   	push   %eax
 804bb5b:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bb5e:	6a 00                	push   $0x0
 804bb60:	50                   	push   %eax
 804bb61:	53                   	push   %ebx
 804bb62:	e8 49 d5 ff ff       	call   80490b0 <strtoll@plt>
 804bb67:	e9 e6 00 00 00       	jmp    804bc52 <cmd_read_option_value+0x13e>
	switch (type) {
 804bb6c:	3c 73                	cmp    $0x73,%al
 804bb6e:	0f 84 a7 00 00 00    	je     804bc1b <cmd_read_option_value+0x107>
 804bb74:	3c 75                	cmp    $0x75,%al
 804bb76:	0f 84 b1 00 00 00    	je     804bc2d <cmd_read_option_value+0x119>
 804bb7c:	3c 69                	cmp    $0x69,%al
 804bb7e:	0f 85 eb 00 00 00    	jne    804bc6f <cmd_read_option_value+0x15b>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804bb84:	50                   	push   %eax
 804bb85:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bb88:	6a 00                	push   $0x0
 804bb8a:	50                   	push   %eax
 804bb8b:	53                   	push   %ebx
 804bb8c:	e8 2f d5 ff ff       	call   80490c0 <strtol@plt>
 804bb91:	e9 b5 00 00 00       	jmp    804bc4b <cmd_read_option_value+0x137>
		if (strcasecmp(str, "false") == 0) {
 804bb96:	50                   	push   %eax
 804bb97:	50                   	push   %eax
 804bb98:	68 7f eb 04 08       	push   $0x804eb7f
 804bb9d:	53                   	push   %ebx
 804bb9e:	e8 fd d5 ff ff       	call   80491a0 <strcasecmp@plt>
 804bba3:	83 c4 10             	add    $0x10,%esp
 804bba6:	85 c0                	test   %eax,%eax
 804bba8:	75 08                	jne    804bbb2 <cmd_read_option_value+0x9e>
			*(bool *)dest = false;
 804bbaa:	c6 06 00             	movb   $0x0,(%esi)
			endptr = (char *)str + 5;
 804bbad:	8d 43 05             	lea    0x5(%ebx),%eax
 804bbb0:	eb 1a                	jmp    804bbcc <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "0") == 0) {
 804bbb2:	50                   	push   %eax
 804bbb3:	50                   	push   %eax
 804bbb4:	68 85 eb 04 08       	push   $0x804eb85
 804bbb9:	53                   	push   %ebx
 804bbba:	e8 b1 d6 ff ff       	call   8049270 <strcmp@plt>
 804bbbf:	83 c4 10             	add    $0x10,%esp
 804bbc2:	85 c0                	test   %eax,%eax
 804bbc4:	75 0e                	jne    804bbd4 <cmd_read_option_value+0xc0>
			*(bool *)dest = false;
 804bbc6:	c6 06 00             	movb   $0x0,(%esi)
			endptr = (char *)str + 1;
 804bbc9:	8d 43 01             	lea    0x1(%ebx),%eax
 804bbcc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!error && endptr && *endptr != 0) {
 804bbcf:	e9 ae 00 00 00       	jmp    804bc82 <cmd_read_option_value+0x16e>
		} else if (strcasecmp(str, "true") == 0) {
 804bbd4:	51                   	push   %ecx
 804bbd5:	51                   	push   %ecx
 804bbd6:	68 87 eb 04 08       	push   $0x804eb87
 804bbdb:	53                   	push   %ebx
 804bbdc:	e8 bf d5 ff ff       	call   80491a0 <strcasecmp@plt>
 804bbe1:	83 c4 10             	add    $0x10,%esp
 804bbe4:	85 c0                	test   %eax,%eax
 804bbe6:	75 08                	jne    804bbf0 <cmd_read_option_value+0xdc>
			*(bool *)dest = true;
 804bbe8:	c6 06 01             	movb   $0x1,(%esi)
			endptr = (char *)str + 4;
 804bbeb:	8d 43 04             	lea    0x4(%ebx),%eax
 804bbee:	eb dc                	jmp    804bbcc <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "1") == 0) {
 804bbf0:	52                   	push   %edx
 804bbf1:	52                   	push   %edx
 804bbf2:	68 8c eb 04 08       	push   $0x804eb8c
 804bbf7:	53                   	push   %ebx
 804bbf8:	e8 73 d6 ff ff       	call   8049270 <strcmp@plt>
 804bbfd:	83 c4 10             	add    $0x10,%esp
 804bc00:	85 c0                	test   %eax,%eax
 804bc02:	74 12                	je     804bc16 <cmd_read_option_value+0x102>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
 804bc04:	50                   	push   %eax
 804bc05:	53                   	push   %ebx
 804bc06:	57                   	push   %edi
 804bc07:	68 8e eb 04 08       	push   $0x804eb8e
 804bc0c:	e8 d3 fc ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804bc11:	83 c4 10             	add    $0x10,%esp
 804bc14:	eb 7c                	jmp    804bc92 <cmd_read_option_value+0x17e>
			*(bool *)dest = true;
 804bc16:	c6 06 01             	movb   $0x1,(%esi)
			endptr = (char *)str + 1;
 804bc19:	eb ae                	jmp    804bbc9 <cmd_read_option_value+0xb5>
		endptr = (char *)str + strlen(str);
 804bc1b:	83 ec 0c             	sub    $0xc,%esp
		*(char **)dest = (char *)str;
 804bc1e:	89 1e                	mov    %ebx,(%esi)
		endptr = (char *)str + strlen(str);
 804bc20:	53                   	push   %ebx
 804bc21:	e8 4a d5 ff ff       	call   8049170 <strlen@plt>
 804bc26:	83 c4 10             	add    $0x10,%esp
 804bc29:	01 d8                	add    %ebx,%eax
 804bc2b:	eb 9f                	jmp    804bbcc <cmd_read_option_value+0xb8>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
 804bc2d:	50                   	push   %eax
 804bc2e:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bc31:	6a 00                	push   $0x0
 804bc33:	50                   	push   %eax
 804bc34:	53                   	push   %ebx
 804bc35:	e8 26 d5 ff ff       	call   8049160 <strtoul@plt>
 804bc3a:	eb 0f                	jmp    804bc4b <cmd_read_option_value+0x137>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
 804bc3c:	50                   	push   %eax
 804bc3d:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bc40:	6a 00                	push   $0x0
 804bc42:	50                   	push   %eax
 804bc43:	53                   	push   %ebx
 804bc44:	e8 a7 d4 ff ff       	call   80490f0 <strtoull@plt>
 804bc49:	eb 07                	jmp    804bc52 <cmd_read_option_value+0x13e>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804bc4b:	89 06                	mov    %eax,(%esi)
 804bc4d:	83 c4 10             	add    $0x10,%esp
 804bc50:	eb 30                	jmp    804bc82 <cmd_read_option_value+0x16e>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804bc52:	89 06                	mov    %eax,(%esi)
 804bc54:	83 c4 10             	add    $0x10,%esp
 804bc57:	89 56 04             	mov    %edx,0x4(%esi)
	if (!error && endptr && *endptr != 0) {
 804bc5a:	eb 26                	jmp    804bc82 <cmd_read_option_value+0x16e>
		*(double *)dest = strtod(str, &endptr);
 804bc5c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bc5f:	51                   	push   %ecx
 804bc60:	51                   	push   %ecx
 804bc61:	50                   	push   %eax
 804bc62:	53                   	push   %ebx
 804bc63:	e8 28 d4 ff ff       	call   8049090 <strtod@plt>
 804bc68:	83 c4 10             	add    $0x10,%esp
 804bc6b:	dd 1e                	fstpl  (%esi)
	if (!error && endptr && *endptr != 0) {
 804bc6d:	eb 13                	jmp    804bc82 <cmd_read_option_value+0x16e>
	switch (type) {
 804bc6f:	0f be c0             	movsbl %al,%eax
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
 804bc72:	52                   	push   %edx
 804bc73:	52                   	push   %edx
 804bc74:	50                   	push   %eax
 804bc75:	68 d0 eb 04 08       	push   $0x804ebd0
 804bc7a:	e8 65 fc ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804bc7f:	83 c4 10             	add    $0x10,%esp
	if (!error && endptr && *endptr != 0) {
 804bc82:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bc85:	85 c0                	test   %eax,%eax
 804bc87:	74 09                	je     804bc92 <cmd_read_option_value+0x17e>
 804bc89:	80 38 00             	cmpb   $0x0,(%eax)
 804bc8c:	0f 85 72 ff ff ff    	jne    804bc04 <cmd_read_option_value+0xf0>
}
 804bc92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bc95:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804bc9c:	74 05                	je     804bca3 <cmd_read_option_value+0x18f>
 804bc9e:	e8 2d d5 ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804bca3:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bca6:	5b                   	pop    %ebx
 804bca7:	5e                   	pop    %esi
 804bca8:	5f                   	pop    %edi
 804bca9:	5d                   	pop    %ebp
 804bcaa:	c3                   	ret    

0804bcab <cmd_args_set_defaults>:
{
 804bcab:	55                   	push   %ebp
 804bcac:	89 e5                	mov    %esp,%ebp
 804bcae:	53                   	push   %ebx
 804bcaf:	51                   	push   %ecx
 804bcb0:	8b 45 08             	mov    0x8(%ebp),%eax
 804bcb3:	8d 58 04             	lea    0x4(%eax),%ebx
	while (args_struct[count].option != NULL) {
 804bcb6:	83 3b 00             	cmpl   $0x0,(%ebx)
 804bcb9:	0f 84 8c 00 00 00    	je     804bd4b <cmd_args_set_defaults+0xa0>
		if (args_struct[count].dest == NULL) {
 804bcbf:	8b 53 0c             	mov    0xc(%ebx),%edx
 804bcc2:	85 d2                	test   %edx,%edx
 804bcc4:	74 7d                	je     804bd43 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
 804bcc6:	0f be 43 08          	movsbl 0x8(%ebx),%eax
 804bcca:	3c 64                	cmp    $0x64,%al
 804bccc:	74 5b                	je     804bd29 <cmd_args_set_defaults+0x7e>
 804bcce:	7f 26                	jg     804bcf6 <cmd_args_set_defaults+0x4b>
 804bcd0:	3c 55                	cmp    $0x55,%al
 804bcd2:	74 46                	je     804bd1a <cmd_args_set_defaults+0x6f>
 804bcd4:	7f 17                	jg     804bced <cmd_args_set_defaults+0x42>
 804bcd6:	84 c0                	test   %al,%al
 804bcd8:	74 69                	je     804bd43 <cmd_args_set_defaults+0x98>
 804bcda:	3c 49                	cmp    $0x49,%al
 804bcdc:	75 55                	jne    804bd33 <cmd_args_set_defaults+0x88>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
 804bcde:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804bce4:	c7 42 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%edx)
			break;
 804bceb:	eb 56                	jmp    804bd43 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
 804bced:	3c 62                	cmp    $0x62,%al
 804bcef:	75 42                	jne    804bd33 <cmd_args_set_defaults+0x88>
			*(bool *)args_struct[count].dest = false;
 804bcf1:	c6 02 00             	movb   $0x0,(%edx)
			break;
 804bcf4:	eb 4d                	jmp    804bd43 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
 804bcf6:	3c 73                	cmp    $0x73,%al
 804bcf8:	74 10                	je     804bd0a <cmd_args_set_defaults+0x5f>
 804bcfa:	3c 75                	cmp    $0x75,%al
 804bcfc:	74 14                	je     804bd12 <cmd_args_set_defaults+0x67>
 804bcfe:	3c 69                	cmp    $0x69,%al
 804bd00:	75 31                	jne    804bd33 <cmd_args_set_defaults+0x88>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
 804bd02:	c7 02 ff ff ff 7f    	movl   $0x7fffffff,(%edx)
			break;
 804bd08:	eb 39                	jmp    804bd43 <cmd_args_set_defaults+0x98>
			*(char **)args_struct[count].dest = NULL;
 804bd0a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			break;
 804bd10:	eb 31                	jmp    804bd43 <cmd_args_set_defaults+0x98>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
 804bd12:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
			break;
 804bd18:	eb 29                	jmp    804bd43 <cmd_args_set_defaults+0x98>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
 804bd1a:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804bd20:	c7 42 04 ff ff ff ff 	movl   $0xffffffff,0x4(%edx)
			break;
 804bd27:	eb 1a                	jmp    804bd43 <cmd_args_set_defaults+0x98>
			*(double *)args_struct[count].dest = (double)NAN;
 804bd29:	d9 05 10 e1 04 08    	flds   0x804e110
 804bd2f:	dd 1a                	fstpl  (%edx)
			break;
 804bd31:	eb 10                	jmp    804bd43 <cmd_args_set_defaults+0x98>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
 804bd33:	52                   	push   %edx
 804bd34:	52                   	push   %edx
 804bd35:	50                   	push   %eax
 804bd36:	68 d0 eb 04 08       	push   $0x804ebd0
 804bd3b:	e8 a4 fb ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804bd40:	83 c4 10             	add    $0x10,%esp
		count++;
 804bd43:	83 c3 1c             	add    $0x1c,%ebx
 804bd46:	e9 6b ff ff ff       	jmp    804bcb6 <cmd_args_set_defaults+0xb>
}
 804bd4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804bd4e:	c9                   	leave  
 804bd4f:	c3                   	ret    

0804bd50 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
 804bd50:	55                   	push   %ebp
 804bd51:	89 e5                	mov    %esp,%ebp
 804bd53:	57                   	push   %edi
 804bd54:	56                   	push   %esi
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
 804bd55:	be 19 00 00 00       	mov    $0x19,%esi
{
 804bd5a:	53                   	push   %ebx
 804bd5b:	83 ec 5c             	sub    $0x5c,%esp
 804bd5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bd61:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804bd67:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804bd6a:	31 c0                	xor    %eax,%eax
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
 804bd6c:	68 f5 eb 04 08       	push   $0x804ebf5
 804bd71:	68 0e ec 04 08       	push   $0x804ec0e
 804bd76:	6a 01                	push   $0x1
 804bd78:	ff 35 84 12 05 08    	push   0x8051284
 804bd7e:	e8 ed d2 ff ff       	call   8049070 <__fprintf_chk@plt>
 804bd83:	83 c4 10             	add    $0x10,%esp

	fprintf(stdout, "%s ", _HELP_SWITCH);

	while (args_struct[count].option != NULL) {
 804bd86:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804bd8a:	74 5c                	je     804bde8 <cmd_print_switches_help+0x98>
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804bd8c:	8d 7d 9e             	lea    -0x62(%ebp),%edi
 804bd8f:	89 da                	mov    %ebx,%edx
 804bd91:	89 f8                	mov    %edi,%eax
 804bd93:	e8 ca fb ff ff       	call   804b962 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804bd98:	83 ec 0c             	sub    $0xc,%esp
 804bd9b:	57                   	push   %edi
 804bd9c:	e8 cf d3 ff ff       	call   8049170 <strlen@plt>
 804bda1:	83 c4 10             	add    $0x10,%esp
 804bda4:	01 f0                	add    %esi,%eax
 804bda6:	83 f8 64             	cmp    $0x64,%eax
 804bda9:	76 18                	jbe    804bdc3 <cmd_print_switches_help+0x73>
 804bdab:	52                   	push   %edx
			fprintf(stdout, "\n");
			printed_in_line = 0;
 804bdac:	31 f6                	xor    %esi,%esi
 804bdae:	68 8e ec 04 08       	push   $0x804ec8e
 804bdb3:	6a 01                	push   $0x1
 804bdb5:	ff 35 84 12 05 08    	push   0x8051284
 804bdbb:	e8 b0 d2 ff ff       	call   8049070 <__fprintf_chk@plt>
 804bdc0:	83 c4 10             	add    $0x10,%esp
 804bdc3:	57                   	push   %edi
 804bdc4:	83 c3 1c             	add    $0x1c,%ebx
 804bdc7:	68 ad ea 04 08       	push   $0x804eaad
 804bdcc:	6a 01                	push   $0x1
 804bdce:	ff 35 84 12 05 08    	push   0x8051284
 804bdd4:	e8 97 d2 ff ff       	call   8049070 <__fprintf_chk@plt>
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
 804bdd9:	89 3c 24             	mov    %edi,(%esp)
 804bddc:	e8 8f d3 ff ff       	call   8049170 <strlen@plt>
 804bde1:	83 c4 10             	add    $0x10,%esp
 804bde4:	01 c6                	add    %eax,%esi
		count++;
 804bde6:	eb 9e                	jmp    804bd86 <cmd_print_switches_help+0x36>
 804bde8:	50                   	push   %eax
 804bde9:	68 8e ec 04 08       	push   $0x804ec8e
 804bdee:	6a 01                	push   $0x1
 804bdf0:	ff 35 84 12 05 08    	push   0x8051284
 804bdf6:	e8 75 d2 ff ff       	call   8049070 <__fprintf_chk@plt>
 804bdfb:	83 c4 10             	add    $0x10,%esp
	}

	fprintf(stdout, "\n");
}
 804bdfe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804be01:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804be08:	74 05                	je     804be0f <cmd_print_switches_help+0xbf>
 804be0a:	e8 c1 d3 ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804be0f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804be12:	5b                   	pop    %ebx
 804be13:	5e                   	pop    %esi
 804be14:	5f                   	pop    %edi
 804be15:	5d                   	pop    %ebp
 804be16:	c3                   	ret    

0804be17 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
 804be17:	55                   	push   %ebp
 804be18:	89 e5                	mov    %esp,%ebp
 804be1a:	57                   	push   %edi
 804be1b:	56                   	push   %esi
 804be1c:	53                   	push   %ebx
 804be1d:	83 ec 78             	sub    $0x78,%esp
 804be20:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804be23:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804be29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804be2c:	31 c0                	xor    %eax,%eax
	int ret;
	int count = 0;
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
 804be2e:	53                   	push   %ebx
 804be2f:	e8 1c ff ff ff       	call   804bd50 <cmd_print_switches_help>
 804be34:	5a                   	pop    %edx
 804be35:	59                   	pop    %ecx
 804be36:	68 12 ec 04 08       	push   $0x804ec12
 804be3b:	68 f5 eb 04 08       	push   $0x804ebf5
 804be40:	6a 1d                	push   $0x1d
 804be42:	68 24 ec 04 08       	push   $0x804ec24
 804be47:	6a 01                	push   $0x1
 804be49:	ff 35 84 12 05 08    	push   0x8051284
 804be4f:	e8 1c d2 ff ff       	call   8049070 <__fprintf_chk@plt>
 804be54:	83 c4 20             	add    $0x20,%esp

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
 804be57:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804be5b:	0f 84 a5 00 00 00    	je     804bf06 <cmd_print_long_help+0xef>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804be61:	8d 75 9e             	lea    -0x62(%ebp),%esi
 804be64:	89 da                	mov    %ebx,%edx
 804be66:	89 f0                	mov    %esi,%eax
 804be68:	e8 f5 fa ff ff       	call   804b962 <cmd_gen_switch_syntax.constprop.0>
 804be6d:	83 ec 0c             	sub    $0xc,%esp
 804be70:	56                   	push   %esi
 804be71:	6a 1d                	push   $0x1d
 804be73:	68 2f ec 04 08       	push   $0x804ec2f
 804be78:	6a 01                	push   $0x1
 804be7a:	ff 35 84 12 05 08    	push   0x8051284
 804be80:	e8 eb d1 ff ff       	call   8049070 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
 804be85:	8b 7b 18             	mov    0x18(%ebx),%edi
 804be88:	83 c4 14             	add    $0x14,%esp
 804be8b:	89 c6                	mov    %eax,%esi
		total_to_print = strlen(toprint);
 804be8d:	57                   	push   %edi
 804be8e:	e8 dd d2 ff ff       	call   8049170 <strlen@plt>
 804be93:	89 3c 24             	mov    %edi,(%esp)
 804be96:	89 45 94             	mov    %eax,-0x6c(%ebp)
		ret = fprintf(stdout, "%.*s\n",
 804be99:	b8 64 00 00 00       	mov    $0x64,%eax
 804be9e:	29 f0                	sub    %esi,%eax
 804bea0:	50                   	push   %eax
 804bea1:	68 36 ec 04 08       	push   $0x804ec36
 804bea6:	6a 01                	push   $0x1
 804bea8:	ff 35 84 12 05 08    	push   0x8051284
 804beae:	e8 bd d1 ff ff       	call   8049070 <__fprintf_chk@plt>
 804beb3:	83 c4 20             	add    $0x20,%esp
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
 804beb6:	8d 70 ff             	lea    -0x1(%eax),%esi

		while (printed_right < total_to_print) {
 804beb9:	3b 75 94             	cmp    -0x6c(%ebp),%esi
 804bebc:	7d 40                	jge    804befe <cmd_print_long_help+0xe7>
 804bebe:	83 ec 0c             	sub    $0xc,%esp
 804bec1:	68 8f ec 04 08       	push   $0x804ec8f
 804bec6:	6a 1e                	push   $0x1e
 804bec8:	68 3c ec 04 08       	push   $0x804ec3c
 804becd:	6a 01                	push   $0x1
 804becf:	ff 35 84 12 05 08    	push   0x8051284
 804bed5:	e8 96 d1 ff ff       	call   8049070 <__fprintf_chk@plt>
 804beda:	83 c4 14             	add    $0x14,%esp
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
 804bedd:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804bee0:	50                   	push   %eax
 804bee1:	6a 46                	push   $0x46
 804bee3:	68 36 ec 04 08       	push   $0x804ec36
 804bee8:	6a 01                	push   $0x1
 804beea:	ff 35 84 12 05 08    	push   0x8051284
 804bef0:	e8 7b d1 ff ff       	call   8049070 <__fprintf_chk@plt>
 804bef5:	83 c4 20             	add    $0x20,%esp
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
 804bef8:	8d 74 06 ff          	lea    -0x1(%esi,%eax,1),%esi
 804befc:	eb bb                	jmp    804beb9 <cmd_print_long_help+0xa2>
		}
		count++;
 804befe:	83 c3 1c             	add    $0x1c,%ebx
 804bf01:	e9 51 ff ff ff       	jmp    804be57 <cmd_print_long_help+0x40>
 804bf06:	50                   	push   %eax
 804bf07:	68 8e ec 04 08       	push   $0x804ec8e
 804bf0c:	6a 01                	push   $0x1
 804bf0e:	ff 35 84 12 05 08    	push   0x8051284
 804bf14:	e8 57 d1 ff ff       	call   8049070 <__fprintf_chk@plt>
 804bf19:	83 c4 0c             	add    $0xc,%esp
 804bf1c:	68 40 ec 04 08       	push   $0x804ec40
 804bf21:	6a 01                	push   $0x1
 804bf23:	ff 35 84 12 05 08    	push   0x8051284
 804bf29:	e8 42 d1 ff ff       	call   8049070 <__fprintf_chk@plt>
 804bf2e:	83 c4 10             	add    $0x10,%esp
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
 804bf31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bf34:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804bf3b:	74 05                	je     804bf42 <cmd_print_long_help+0x12b>
 804bf3d:	e8 8e d2 ff ff       	call   80491d0 <__stack_chk_fail@plt>
 804bf42:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bf45:	5b                   	pop    %ebx
 804bf46:	5e                   	pop    %esi
 804bf47:	5f                   	pop    %edi
 804bf48:	5d                   	pop    %ebp
 804bf49:	c3                   	ret    

0804bf4a <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
 804bf4a:	55                   	push   %ebp
 804bf4b:	89 e5                	mov    %esp,%ebp
 804bf4d:	57                   	push   %edi
 804bf4e:	56                   	push   %esi
 804bf4f:	53                   	push   %ebx
 804bf50:	83 ec 18             	sub    $0x18,%esp
 804bf53:	8b 7d 08             	mov    0x8(%ebp),%edi
 804bf56:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
 804bf59:	57                   	push   %edi
 804bf5a:	e8 49 fb ff ff       	call   804baa8 <cmd_is_help_option>
 804bf5f:	83 c4 10             	add    $0x10,%esp
 804bf62:	85 c0                	test   %eax,%eax
 804bf64:	74 22                	je     804bf88 <cmd_parse_one_arg+0x3e>
		cmd_print_long_help(args_struct);
 804bf66:	83 ec 0c             	sub    $0xc,%esp
 804bf69:	53                   	push   %ebx
 804bf6a:	e8 a8 fe ff ff       	call   804be17 <cmd_print_long_help>
		posix_exit(0);
 804bf6f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804bf76:	e8 0f f8 ff ff       	call   804b78a <posix_exit>
 804bf7b:	83 c4 10             	add    $0x10,%esp
 804bf7e:	eb 08                	jmp    804bf88 <cmd_parse_one_arg+0x3e>
	}

	while (args_struct[count].option != NULL) {
		if (args_struct[count].manual) {
 804bf80:	80 3b 00             	cmpb   $0x0,(%ebx)
 804bf83:	74 0c                	je     804bf91 <cmd_parse_one_arg+0x47>
 804bf85:	83 c3 1c             	add    $0x1c,%ebx
	while (args_struct[count].option != NULL) {
 804bf88:	8b 53 04             	mov    0x4(%ebx),%edx
 804bf8b:	85 d2                	test   %edx,%edx
 804bf8d:	75 f1                	jne    804bf80 <cmd_parse_one_arg+0x36>
 804bf8f:	eb 6b                	jmp    804bffc <cmd_parse_one_arg+0xb2>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
 804bf91:	51                   	push   %ecx
				    !args_struct[count].is_switch);
 804bf92:	8a 43 02             	mov    0x2(%ebx),%al
 804bf95:	83 f0 01             	xor    $0x1,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
 804bf98:	0f b6 c0             	movzbl %al,%eax
 804bf9b:	50                   	push   %eax
 804bf9c:	52                   	push   %edx
 804bf9d:	57                   	push   %edi
 804bf9e:	e8 6a fa ff ff       	call   804ba0d <cmd_is_option>
 804bfa3:	83 c4 10             	add    $0x10,%esp
 804bfa6:	89 c6                	mov    %eax,%esi
		if (ret) {
 804bfa8:	85 c0                	test   %eax,%eax
 804bfaa:	74 d9                	je     804bf85 <cmd_parse_one_arg+0x3b>
	if (arg_element->dest != NULL) {
 804bfac:	8b 53 10             	mov    0x10(%ebx),%edx
 804bfaf:	85 d2                	test   %edx,%edx
 804bfb1:	74 33                	je     804bfe6 <cmd_parse_one_arg+0x9c>
		if (arg_element->is_switch) {
 804bfb3:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
			if (arg_element->type == 'b') {
 804bfb7:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
		if (arg_element->is_switch) {
 804bfbb:	74 18                	je     804bfd5 <cmd_parse_one_arg+0x8b>
			if (arg_element->type == 'b') {
 804bfbd:	3c 62                	cmp    $0x62,%al
 804bfbf:	75 05                	jne    804bfc6 <cmd_parse_one_arg+0x7c>
				*(bool *)arg_element->dest = true;
 804bfc1:	c6 02 01             	movb   $0x1,(%edx)
 804bfc4:	eb 20                	jmp    804bfe6 <cmd_parse_one_arg+0x9c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
 804bfc6:	83 ec 0c             	sub    $0xc,%esp
 804bfc9:	68 90 ec 04 08       	push   $0x804ec90
 804bfce:	e8 11 f9 ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804bfd3:	eb 0e                	jmp    804bfe3 <cmd_parse_one_arg+0x99>
			cmd_read_option_value(&argv[offset],
 804bfd5:	ff 73 04             	push   0x4(%ebx)
 804bfd8:	50                   	push   %eax
 804bfd9:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804bfdc:	52                   	push   %edx
 804bfdd:	50                   	push   %eax
 804bfde:	e8 31 fb ff ff       	call   804bb14 <cmd_read_option_value>
 804bfe3:	83 c4 10             	add    $0x10,%esp
	if (arg_element->call_when_found) {
 804bfe6:	8b 53 14             	mov    0x14(%ebx),%edx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
 804bfe9:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
 804bfeb:	85 d2                	test   %edx,%edx
 804bfed:	74 0f                	je     804bffe <cmd_parse_one_arg+0xb4>
		arg_element->call_when_found(argv, offset);
 804bfef:	50                   	push   %eax
 804bff0:	50                   	push   %eax
 804bff1:	56                   	push   %esi
 804bff2:	57                   	push   %edi
 804bff3:	ff d2                	call   *%edx
			return true;
 804bff5:	b0 01                	mov    $0x1,%al
		arg_element->call_when_found(argv, offset);
 804bff7:	83 c4 10             	add    $0x10,%esp
 804bffa:	eb 02                	jmp    804bffe <cmd_parse_one_arg+0xb4>
		}
		count++;
	}
	return false;
 804bffc:	31 c0                	xor    %eax,%eax
}
 804bffe:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c001:	5b                   	pop    %ebx
 804c002:	5e                   	pop    %esi
 804c003:	5f                   	pop    %edi
 804c004:	5d                   	pop    %ebp
 804c005:	c3                   	ret    

0804c006 <native_cleanup_cmd_line>:
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
 804c006:	a1 34 19 05 08       	mov    0x8051934,%eax
 804c00b:	85 c0                	test   %eax,%eax
 804c00d:	74 1b                	je     804c02a <native_cleanup_cmd_line+0x24>
{
 804c00f:	55                   	push   %ebp
 804c010:	89 e5                	mov    %esp,%ebp
 804c012:	83 ec 14             	sub    $0x14,%esp
		free(args_struct);
 804c015:	50                   	push   %eax
 804c016:	e8 c5 d0 ff ff       	call   80490e0 <free@plt>
 804c01b:	83 c4 10             	add    $0x10,%esp
		args_struct = NULL;
 804c01e:	c7 05 34 19 05 08 00 	movl   $0x0,0x8051934
 804c025:	00 00 00 
	}
}
 804c028:	c9                   	leave  
 804c029:	c3                   	ret    
 804c02a:	c3                   	ret    

0804c02b <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
 804c02b:	55                   	push   %ebp
	int count = 0;
 804c02c:	31 c0                	xor    %eax,%eax
{
 804c02e:	89 e5                	mov    %esp,%ebp
 804c030:	57                   	push   %edi
 804c031:	56                   	push   %esi
 804c032:	53                   	push   %ebx
 804c033:	83 ec 0c             	sub    $0xc,%esp

	while (args[count].option != NULL) {
 804c036:	6b f0 1c             	imul   $0x1c,%eax,%esi
 804c039:	8b 7d 08             	mov    0x8(%ebp),%edi
 804c03c:	89 c3                	mov    %eax,%ebx
		count++;
 804c03e:	8d 40 01             	lea    0x1(%eax),%eax
	while (args[count].option != NULL) {
 804c041:	83 7c 37 04 00       	cmpl   $0x0,0x4(%edi,%esi,1)
 804c046:	75 ee                	jne    804c036 <native_add_command_line_opts+0xb>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
 804c048:	8b 0d 30 19 05 08    	mov    0x8051930,%ecx
 804c04e:	8b 15 2c 19 05 08    	mov    0x805192c,%edx
 804c054:	01 c1                	add    %eax,%ecx
 804c056:	39 d1                	cmp    %edx,%ecx
 804c058:	7c 42                	jl     804c09c <native_add_command_line_opts+0x71>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
 804c05a:	b9 14 00 00 00       	mov    $0x14,%ecx
 804c05f:	39 c8                	cmp    %ecx,%eax
 804c061:	0f 4c c1             	cmovl  %ecx,%eax
 804c064:	8d 3c 10             	lea    (%eax,%edx,1),%edi
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804c067:	50                   	push   %eax
 804c068:	50                   	push   %eax
 804c069:	6b c7 1c             	imul   $0x1c,%edi,%eax
 804c06c:	50                   	push   %eax
 804c06d:	ff 35 34 19 05 08    	push   0x8051934
 804c073:	e8 08 d0 ff ff       	call   8049080 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
 804c078:	89 3d 2c 19 05 08    	mov    %edi,0x805192c
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804c07e:	83 c4 10             	add    $0x10,%esp
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
 804c081:	85 c0                	test   %eax,%eax
 804c083:	75 12                	jne    804c097 <native_add_command_line_opts+0x6c>
			posix_print_error_and_exit("Could not allocate memory");
 804c085:	83 ec 0c             	sub    $0xc,%esp
 804c088:	68 db ec 04 08       	push   $0x804ecdb
 804c08d:	e8 52 f8 ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804c092:	83 c4 10             	add    $0x10,%esp
 804c095:	eb 05                	jmp    804c09c <native_add_command_line_opts+0x71>
		} else {
			args_struct = new_args_struct;
 804c097:	a3 34 19 05 08       	mov    %eax,0x8051934
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
 804c09c:	8b 15 30 19 05 08    	mov    0x8051930,%edx
 804c0a2:	8d 4e 1c             	lea    0x1c(%esi),%ecx
  return __builtin___memcpy_chk (__dest, __src, __len,
 804c0a5:	8b 75 08             	mov    0x8(%ebp),%esi
 804c0a8:	6b c2 1c             	imul   $0x1c,%edx,%eax
 804c0ab:	03 05 34 19 05 08    	add    0x8051934,%eax
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
 804c0b1:	01 da                	add    %ebx,%edx
 804c0b3:	89 c7                	mov    %eax,%edi
 804c0b5:	89 15 30 19 05 08    	mov    %edx,0x8051930
 804c0bb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
 804c0bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c0c0:	5b                   	pop    %ebx
 804c0c1:	5e                   	pop    %esi
 804c0c2:	5f                   	pop    %edi
 804c0c3:	5d                   	pop    %ebp
 804c0c4:	c3                   	ret    

0804c0c5 <native_add_testargs_option>:

void native_add_testargs_option(void)
{
 804c0c5:	55                   	push   %ebp
 804c0c6:	89 e5                	mov    %esp,%ebp
 804c0c8:	83 ec 14             	sub    $0x14,%esp
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
 804c0cb:	68 60 11 05 08       	push   $0x8051160
 804c0d0:	e8 56 ff ff ff       	call   804c02b <native_add_command_line_opts>
 804c0d5:	83 c4 10             	add    $0x10,%esp
}
 804c0d8:	c9                   	leave  
 804c0d9:	c3                   	ret    

0804c0da <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
 804c0da:	55                   	push   %ebp
 804c0db:	89 e5                	mov    %esp,%ebp
 804c0dd:	57                   	push   %edi
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
 804c0de:	bf 01 00 00 00       	mov    $0x1,%edi
{
 804c0e3:	56                   	push   %esi
 804c0e4:	53                   	push   %ebx
 804c0e5:	83 ec 1c             	sub    $0x1c,%esp
 804c0e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804c0eb:	8b 75 0c             	mov    0xc(%ebp),%esi
	native_add_tracing_options();
 804c0ee:	e8 5a f8 ff ff       	call   804b94d <native_add_tracing_options>
	native_add_testargs_option();
 804c0f3:	e8 cd ff ff ff       	call   804c0c5 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
 804c0f8:	83 ec 0c             	sub    $0xc,%esp
 804c0fb:	ff 35 34 19 05 08    	push   0x8051934
	s_argv = argv;
 804c101:	89 35 3c 19 05 08    	mov    %esi,0x805193c
	s_argc = argc;
 804c107:	89 1d 44 19 05 08    	mov    %ebx,0x8051944
	cmd_args_set_defaults(args_struct);
 804c10d:	e8 99 fb ff ff       	call   804bcab <cmd_args_set_defaults>
 804c112:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804c115:	39 df                	cmp    %ebx,%edi
 804c117:	7d 6c                	jge    804c185 <native_handle_cmd_line+0xab>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
 804c119:	50                   	push   %eax
 804c11a:	6a 00                	push   $0x0
 804c11c:	68 f5 ec 04 08       	push   $0x804ecf5
 804c121:	ff 34 be             	push   (%esi,%edi,4)
 804c124:	e8 e4 f8 ff ff       	call   804ba0d <cmd_is_option>
 804c129:	83 c4 10             	add    $0x10,%esp
 804c12c:	85 c0                	test   %eax,%eax
 804c12e:	8d 47 01             	lea    0x1(%edi),%eax
 804c131:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c134:	74 13                	je     804c149 <native_handle_cmd_line+0x6f>
			test_argc = argc - i - 1;
 804c136:	29 fb                	sub    %edi,%ebx
			test_argv = &argv[i+1];
 804c138:	8d 04 86             	lea    (%esi,%eax,4),%eax
			test_argc = argc - i - 1;
 804c13b:	4b                   	dec    %ebx
			test_argv = &argv[i+1];
 804c13c:	a3 38 19 05 08       	mov    %eax,0x8051938
			test_argc = argc - i - 1;
 804c141:	89 1d 40 19 05 08    	mov    %ebx,0x8051940
			break;
 804c147:	eb 3c                	jmp    804c185 <native_handle_cmd_line+0xab>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
 804c149:	51                   	push   %ecx
 804c14a:	51                   	push   %ecx
 804c14b:	ff 35 34 19 05 08    	push   0x8051934
 804c151:	ff 34 be             	push   (%esi,%edi,4)
 804c154:	e8 f1 fd ff ff       	call   804bf4a <cmd_parse_one_arg>
 804c159:	83 c4 10             	add    $0x10,%esp
 804c15c:	84 c0                	test   %al,%al
 804c15e:	75 20                	jne    804c180 <native_handle_cmd_line+0xa6>
			cmd_print_switches_help(args_struct);
 804c160:	83 ec 0c             	sub    $0xc,%esp
 804c163:	ff 35 34 19 05 08    	push   0x8051934
 804c169:	e8 e2 fb ff ff       	call   804bd50 <cmd_print_switches_help>
 804c16e:	58                   	pop    %eax
 804c16f:	5a                   	pop    %edx
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
 804c170:	ff 34 be             	push   (%esi,%edi,4)
 804c173:	68 fe ec 04 08       	push   $0x804ecfe
 804c178:	e8 67 f7 ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804c17d:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804c180:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 804c183:	eb 90                	jmp    804c115 <native_handle_cmd_line+0x3b>
			print_invalid_opt_error(argv[i]);
		}
	}
}
 804c185:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c188:	5b                   	pop    %ebx
 804c189:	5e                   	pop    %esi
 804c18a:	5f                   	pop    %edi
 804c18b:	5d                   	pop    %ebp
 804c18c:	c3                   	ret    

0804c18d <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
 804c18d:	c7 05 c0 18 05 08 ff 	movl   $0xffffffff,0x80518c0
 804c194:	ff ff ff 
 804c197:	c7 05 c4 18 05 08 ff 	movl   $0xffffffff,0x80518c4
 804c19e:	ff ff ff 
	counter_target = NEVER;
 804c1a1:	c7 05 b0 18 05 08 ff 	movl   $0xffffffff,0x80518b0
 804c1a8:	ff ff ff 
 804c1ab:	c7 05 b4 18 05 08 ff 	movl   $0xffffffff,0x80518b4
 804c1b2:	ff ff ff 
	counter_value = 0;
 804c1b5:	c7 05 b8 18 05 08 00 	movl   $0x0,0x80518b8
 804c1bc:	00 00 00 
 804c1bf:	c7 05 bc 18 05 08 00 	movl   $0x0,0x80518bc
 804c1c6:	00 00 00 
	counter_running = false;
 804c1c9:	c6 05 76 19 05 08 00 	movb   $0x0,0x8051976
	counter_period = NEVER;
 804c1d0:	c7 05 a8 18 05 08 ff 	movl   $0xffffffff,0x80518a8
 804c1d7:	ff ff ff 
 804c1da:	c7 05 ac 18 05 08 ff 	movl   $0xffffffff,0x80518ac
 804c1e1:	ff ff ff 
}
 804c1e4:	c3                   	ret    

0804c1e5 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
	if (!counter_running) {
 804c1e5:	80 3d 76 19 05 08 00 	cmpb   $0x0,0x8051976
 804c1ec:	75 15                	jne    804c203 <hw_counter_triggered+0x1e>
		hw_counter_timer = NEVER;
 804c1ee:	c7 05 c0 18 05 08 ff 	movl   $0xffffffff,0x80518c0
 804c1f5:	ff ff ff 
 804c1f8:	c7 05 c4 18 05 08 ff 	movl   $0xffffffff,0x80518c4
 804c1ff:	ff ff ff 
		return;
 804c202:	c3                   	ret    
{
 804c203:	55                   	push   %ebp
 804c204:	89 e5                	mov    %esp,%ebp
 804c206:	83 ec 08             	sub    $0x8,%esp
	}

	hw_counter_timer = hwm_get_time() + counter_period;
 804c209:	e8 01 eb ff ff       	call   804ad0f <hwm_get_time>
 804c20e:	03 05 a8 18 05 08    	add    0x80518a8,%eax
 804c214:	13 15 ac 18 05 08    	adc    0x80518ac,%edx
 804c21a:	a3 c0 18 05 08       	mov    %eax,0x80518c0
	counter_value = counter_value + 1;
 804c21f:	a1 b8 18 05 08       	mov    0x80518b8,%eax
	hw_counter_timer = hwm_get_time() + counter_period;
 804c224:	89 15 c4 18 05 08    	mov    %edx,0x80518c4
	counter_value = counter_value + 1;
 804c22a:	8b 15 bc 18 05 08    	mov    0x80518bc,%edx
 804c230:	83 c0 01             	add    $0x1,%eax
 804c233:	83 d2 00             	adc    $0x0,%edx
 804c236:	a3 b8 18 05 08       	mov    %eax,0x80518b8
 804c23b:	89 15 bc 18 05 08    	mov    %edx,0x80518bc

	if (counter_value == counter_target) {
 804c241:	3b 15 b4 18 05 08    	cmp    0x80518b4,%edx
 804c247:	75 15                	jne    804c25e <hw_counter_triggered+0x79>
 804c249:	3b 05 b0 18 05 08    	cmp    0x80518b0,%eax
 804c24f:	75 0d                	jne    804c25e <hw_counter_triggered+0x79>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
 804c251:	83 ec 0c             	sub    $0xc,%esp
 804c254:	6a 02                	push   $0x2
 804c256:	e8 78 f4 ff ff       	call   804b6d3 <hw_irq_ctrl_set_irq>
 804c25b:	83 c4 10             	add    $0x10,%esp
	}
}
 804c25e:	c9                   	leave  
 804c25f:	c3                   	ret    

0804c260 <posix_arch_console_init>:
		stdout_buff[0] = 0;
	}
}

static int posix_arch_console_init(void)
{
 804c260:	55                   	push   %ebp
 804c261:	89 e5                	mov    %esp,%ebp
 804c263:	83 ec 14             	sub    $0x14,%esp
#ifdef CONFIG_PRINTK
	extern void __printk_hook_install(int (*fn)(int));
	__printk_hook_install(print_char);
 804c266:	68 77 c2 04 08       	push   $0x804c277
 804c26b:	e8 36 d5 ff ff       	call   80497a6 <__printk_hook_install>
 804c270:	83 c4 10             	add    $0x10,%esp
#ifdef CONFIG_STDOUT_CONSOLE
	extern void __stdout_hook_install(int (*fn)(int));
	__stdout_hook_install(print_char);
#endif
	return 0;
}
 804c273:	31 c0                	xor    %eax,%eax
 804c275:	c9                   	leave  
 804c276:	c3                   	ret    

0804c277 <print_char>:
{
 804c277:	55                   	push   %ebp
 804c278:	89 e5                	mov    %esp,%ebp
 804c27a:	83 ec 08             	sub    $0x8,%esp
 804c27d:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((c != '\n') && (c != '\r')) {
 804c280:	83 f8 0a             	cmp    $0xa,%eax
 804c283:	74 05                	je     804c28a <print_char+0x13>
 804c285:	83 f8 0d             	cmp    $0xd,%eax
 804c288:	75 2d                	jne    804c2b7 <print_char+0x40>
 804c28a:	89 45 08             	mov    %eax,0x8(%ebp)
		posix_print_trace("%s\n", stdout_buff);
 804c28d:	50                   	push   %eax
 804c28e:	50                   	push   %eax
 804c28f:	68 60 16 05 08       	push   $0x8051660
 804c294:	68 18 e2 04 08       	push   $0x804e218
 804c299:	e8 90 f6 ff ff       	call   804b92e <posix_print_trace>
		stdout_buff[0] = 0;
 804c29e:	c6 05 60 16 05 08 00 	movb   $0x0,0x8051660
 804c2a5:	8b 45 08             	mov    0x8(%ebp),%eax
		posix_print_trace("%s\n", stdout_buff);
 804c2a8:	83 c4 10             	add    $0x10,%esp
		n_pend = 0;
 804c2ab:	c7 05 48 19 05 08 00 	movl   $0x0,0x8051948
 804c2b2:	00 00 00 
		stdout_buff[0] = 0;
 804c2b5:	eb 24                	jmp    804c2db <print_char+0x64>
		stdout_buff[n_pend++] = c;
 804c2b7:	8b 15 48 19 05 08    	mov    0x8051948,%edx
 804c2bd:	8d 4a 01             	lea    0x1(%edx),%ecx
 804c2c0:	88 82 60 16 05 08    	mov    %al,0x8051660(%edx)
 804c2c6:	89 0d 48 19 05 08    	mov    %ecx,0x8051948
		stdout_buff[n_pend] = 0;
 804c2cc:	c6 82 61 16 05 08 00 	movb   $0x0,0x8051661(%edx)
	if (printnow) {
 804c2d3:	81 f9 fe 00 00 00    	cmp    $0xfe,%ecx
 804c2d9:	7f af                	jg     804c28a <print_char+0x13>
}
 804c2db:	c9                   	leave  
 804c2dc:	c3                   	ret    

0804c2dd <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
 804c2dd:	55                   	push   %ebp
 804c2de:	89 e5                	mov    %esp,%ebp
 804c2e0:	57                   	push   %edi
 804c2e1:	56                   	push   %esi
 804c2e2:	53                   	push   %ebx
 804c2e3:	83 ec 1c             	sub    $0x1c,%esp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
 804c2e6:	e8 24 ea ff ff       	call   804ad0f <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 804c2eb:	8b 35 c8 18 05 08    	mov    0x80518c8,%esi
 804c2f1:	8b 3d cc 18 05 08    	mov    0x80518cc,%edi
 804c2f7:	8b 0d d0 18 05 08    	mov    0x80518d0,%ecx
 804c2fd:	8b 1d d4 18 05 08    	mov    0x80518d4,%ebx
 804c303:	29 f0                	sub    %esi,%eax
 804c305:	19 fa                	sbb    %edi,%edx
 804c307:	53                   	push   %ebx
 804c308:	51                   	push   %ecx
 804c309:	52                   	push   %edx
 804c30a:	50                   	push   %eax
 804c30b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 804c30e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
 804c311:	e8 da d0 ff ff       	call   80493f0 <__udivdi3>
 804c316:	83 c4 10             	add    $0x10,%esp
 804c319:	89 c1                	mov    %eax,%ecx

	last_tick_time += elapsed_ticks*tick_period;
 804c31b:	99                   	cltd   
 804c31c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c31f:	0f af 55 e0          	imul   -0x20(%ebp),%edx
	sys_clock_announce(elapsed_ticks);
 804c323:	89 4d 08             	mov    %ecx,0x8(%ebp)
	last_tick_time += elapsed_ticks*tick_period;
 804c326:	0f af c1             	imul   %ecx,%eax
 804c329:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
 804c32c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c32f:	f7 e1                	mul    %ecx
 804c331:	01 da                	add    %ebx,%edx
 804c333:	01 f0                	add    %esi,%eax
 804c335:	11 fa                	adc    %edi,%edx
 804c337:	a3 c8 18 05 08       	mov    %eax,0x80518c8
 804c33c:	89 15 cc 18 05 08    	mov    %edx,0x80518cc
}
 804c342:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c345:	5b                   	pop    %ebx
 804c346:	5e                   	pop    %esi
 804c347:	5f                   	pop    %edi
 804c348:	5d                   	pop    %ebp
	sys_clock_announce(elapsed_ticks);
 804c349:	e9 a5 10 00 00       	jmp    804d3f3 <sys_clock_announce>

0804c34e <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(void)
{
 804c34e:	55                   	push   %ebp
 804c34f:	89 e5                	mov    %esp,%ebp
 804c351:	83 ec 08             	sub    $0x8,%esp

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
 804c354:	c7 05 d0 18 05 08 10 	movl   $0x2710,0x80518d0
 804c35b:	27 00 00 
 804c35e:	c7 05 d4 18 05 08 00 	movl   $0x0,0x80518d4
 804c365:	00 00 00 

	last_tick_time = hwm_get_time();
 804c368:	e8 a2 e9 ff ff       	call   804ad0f <hwm_get_time>
 804c36d:	89 15 cc 18 05 08    	mov    %edx,0x80518cc
	hwtimer_enable(tick_period);
 804c373:	52                   	push   %edx
 804c374:	52                   	push   %edx
 804c375:	ff 35 d4 18 05 08    	push   0x80518d4
 804c37b:	ff 35 d0 18 05 08    	push   0x80518d0
	last_tick_time = hwm_get_time();
 804c381:	a3 c8 18 05 08       	mov    %eax,0x80518c8
	hwtimer_enable(tick_period);
 804c386:	e8 58 ed ff ff       	call   804b0e3 <hwtimer_enable>
 804c38b:	83 c4 10             	add    $0x10,%esp

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
 804c38e:	6a 00                	push   $0x0
 804c390:	68 dd c2 04 08       	push   $0x804c2dd
 804c395:	6a 00                	push   $0x0
 804c397:	6a 00                	push   $0x0
 804c399:	e8 ef f0 ff ff       	call   804b48d <posix_isr_declare>
 804c39e:	83 c4 0c             	add    $0xc,%esp
 804c3a1:	6a 00                	push   $0x0
 804c3a3:	6a 01                	push   $0x1
 804c3a5:	6a 00                	push   $0x0
 804c3a7:	e8 0c f1 ff ff       	call   804b4b8 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
 804c3ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c3b3:	e8 6d df ff ff       	call   804a325 <arch_irq_enable>
 804c3b8:	83 c4 10             	add    $0x10,%esp

	return 0;
}
 804c3bb:	31 c0                	xor    %eax,%eax
 804c3bd:	c9                   	leave  
 804c3be:	c3                   	ret    

0804c3bf <sys_clock_set_timeout>:
{
 804c3bf:	55                   	push   %ebp
		silent_ticks = INT64_MAX;
 804c3c0:	83 c8 ff             	or     $0xffffffff,%eax
 804c3c3:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
{
 804c3c8:	89 e5                	mov    %esp,%ebp
 804c3ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (ticks == K_TICKS_FOREVER) {
 804c3cd:	83 f9 ff             	cmp    $0xffffffff,%ecx
 804c3d0:	74 0c                	je     804c3de <sys_clock_set_timeout+0x1f>
		silent_ticks = 0;
 804c3d2:	31 c0                	xor    %eax,%eax
 804c3d4:	31 d2                	xor    %edx,%edx
	} else if (ticks > 0) {
 804c3d6:	85 c9                	test   %ecx,%ecx
 804c3d8:	7e 04                	jle    804c3de <sys_clock_set_timeout+0x1f>
		silent_ticks = ticks - 1;
 804c3da:	8d 41 ff             	lea    -0x1(%ecx),%eax
 804c3dd:	99                   	cltd   
	hwtimer_set_silent_ticks(silent_ticks);
 804c3de:	89 45 08             	mov    %eax,0x8(%ebp)
 804c3e1:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 804c3e4:	5d                   	pop    %ebp
	hwtimer_set_silent_ticks(silent_ticks);
 804c3e5:	e9 15 ef ff ff       	jmp    804b2ff <hwtimer_set_silent_ticks>

0804c3ea <sys_clock_elapsed>:
{
 804c3ea:	55                   	push   %ebp
 804c3eb:	89 e5                	mov    %esp,%ebp
 804c3ed:	83 ec 08             	sub    $0x8,%esp
	return (hwm_get_time() - last_tick_time)/tick_period;
 804c3f0:	e8 1a e9 ff ff       	call   804ad0f <hwm_get_time>
 804c3f5:	2b 05 c8 18 05 08    	sub    0x80518c8,%eax
 804c3fb:	1b 15 cc 18 05 08    	sbb    0x80518cc,%edx
 804c401:	ff 35 d4 18 05 08    	push   0x80518d4
 804c407:	ff 35 d0 18 05 08    	push   0x80518d0
 804c40d:	52                   	push   %edx
 804c40e:	50                   	push   %eax
 804c40f:	e8 dc cf ff ff       	call   80493f0 <__udivdi3>
 804c414:	83 c4 10             	add    $0x10,%esp
}
 804c417:	c9                   	leave  
 804c418:	c3                   	ret    

0804c419 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
 804c419:	55                   	push   %ebp
 804c41a:	89 e5                	mov    %esp,%ebp
 804c41c:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
 804c41f:	ff 75 08             	push   0x8(%ebp)
 804c422:	e8 d7 de ff ff       	call   804a2fe <arch_system_halt>

0804c427 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 804c427:	55                   	push   %ebp
 804c428:	89 e5                	mov    %esp,%ebp
 804c42a:	57                   	push   %edi
 804c42b:	56                   	push   %esi
 804c42c:	53                   	push   %ebx
 804c42d:	83 ec 1c             	sub    $0x1c,%esp
 804c430:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c433:	8b 7d 08             	mov    0x8(%ebp),%edi
 804c436:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	return posix_irq_lock();
 804c439:	e8 21 f0 ff ff       	call   804b45f <posix_irq_lock>
 804c43e:	89 c6                	mov    %eax,%esi
	return z_impl_z_current_get();
 804c440:	e8 8b 0c 00 00       	call   804d0d0 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
 804c445:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c448:	89 c3                	mov    %eax,%ebx
 804c44a:	50                   	push   %eax
 804c44b:	50                   	push   %eax
 804c44c:	52                   	push   %edx
 804c44d:	57                   	push   %edi
 804c44e:	e8 c6 ff ff ff       	call   804c419 <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
 804c453:	89 34 24             	mov    %esi,(%esp)
 804c456:	e8 16 f0 ff ff       	call   804b471 <posix_irq_unlock>
 804c45b:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_abort(thread);
 804c45e:	89 5d 08             	mov    %ebx,0x8(%ebp)
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
 804c461:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c464:	5b                   	pop    %ebx
 804c465:	5e                   	pop    %esi
 804c466:	5f                   	pop    %edi
 804c467:	5d                   	pop    %ebp
 804c468:	e9 95 e2 ff ff       	jmp    804a702 <z_impl_k_thread_abort>

0804c46d <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
 804c46d:	55                   	push   %ebp
 804c46e:	89 e5                	mov    %esp,%ebp
 804c470:	57                   	push   %edi
 804c471:	56                   	push   %esi
 804c472:	53                   	push   %ebx
 804c473:	89 c3                	mov    %eax,%ebx
 804c475:	83 ec 0c             	sub    $0xc,%esp
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 804c478:	8b 34 85 14 e1 04 08 	mov    0x804e114(,%eax,4),%esi
 804c47f:	39 34 9d 18 e1 04 08 	cmp    %esi,0x804e118(,%ebx,4)
 804c486:	76 40                	jbe    804c4c8 <z_sys_init_run_level+0x5b>
		const struct device *dev = entry->dev;
 804c488:	8b 7e 04             	mov    0x4(%esi),%edi

		if (dev != NULL) {
			int rc = 0;

			if (entry->init_fn.dev != NULL) {
 804c48b:	8b 06                	mov    (%esi),%eax
		if (dev != NULL) {
 804c48d:	85 ff                	test   %edi,%edi
 804c48f:	74 30                	je     804c4c1 <z_sys_init_run_level+0x54>
			if (entry->init_fn.dev != NULL) {
 804c491:	85 c0                	test   %eax,%eax
 804c493:	74 23                	je     804c4b8 <z_sys_init_run_level+0x4b>
				rc = entry->init_fn.dev(dev);
 804c495:	83 ec 0c             	sub    $0xc,%esp
 804c498:	57                   	push   %edi
 804c499:	ff d0                	call   *%eax
 804c49b:	83 c4 10             	add    $0x10,%esp
				/* Mark device initialized. If initialization
				 * failed, record the error condition.
				 */
				if (rc != 0) {
 804c49e:	85 c0                	test   %eax,%eax
 804c4a0:	74 16                	je     804c4b8 <z_sys_init_run_level+0x4b>
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
						rc = UINT8_MAX;
					}
					dev->state->init_res = rc;
 804c4a2:	89 c2                	mov    %eax,%edx
 804c4a4:	8b 4f 0c             	mov    0xc(%edi),%ecx
 804c4a7:	f7 da                	neg    %edx
 804c4a9:	0f 49 c2             	cmovns %edx,%eax
 804c4ac:	ba ff 00 00 00       	mov    $0xff,%edx
 804c4b1:	39 d0                	cmp    %edx,%eax
 804c4b3:	0f 4f c2             	cmovg  %edx,%eax
 804c4b6:	88 01                	mov    %al,(%ecx)
				}
			}

			dev->state->initialized = true;
 804c4b8:	8b 47 0c             	mov    0xc(%edi),%eax
 804c4bb:	80 48 01 01          	orb    $0x1,0x1(%eax)

			if (rc == 0) {
 804c4bf:	eb 02                	jmp    804c4c3 <z_sys_init_run_level+0x56>
				/* Run automatic device runtime enablement */
				(void)pm_device_runtime_auto_enable(dev);
			}
		} else {
			(void)entry->init_fn.sys();
 804c4c1:	ff d0                	call   *%eax
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 804c4c3:	83 c6 08             	add    $0x8,%esi
 804c4c6:	eb b7                	jmp    804c47f <z_sys_init_run_level+0x12>
		}
	}
}
 804c4c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c4cb:	5b                   	pop    %ebx
 804c4cc:	5e                   	pop    %esi
 804c4cd:	5f                   	pop    %edi
 804c4ce:	5d                   	pop    %ebp
 804c4cf:	c3                   	ret    

0804c4d0 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
 804c4d0:	55                   	push   %ebp
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 804c4d1:	b8 03 00 00 00       	mov    $0x3,%eax
{
 804c4d6:	89 e5                	mov    %esp,%ebp
 804c4d8:	83 ec 08             	sub    $0x8,%esp
	z_sys_post_kernel = true;
 804c4db:	c6 05 77 19 05 08 01 	movb   $0x1,0x8051977
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 804c4e2:	e8 86 ff ff ff       	call   804c46d <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 804c4e7:	e8 53 10 00 00       	call   804d53f <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 804c4ec:	b8 04 00 00 00       	mov    $0x4,%eax
 804c4f1:	e8 77 ff ff ff       	call   804c46d <z_sys_init_run_level>

	z_init_static_threads();
 804c4f6:	e8 c1 01 00 00       	call   804c6bc <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
 804c4fb:	e8 3b 10 00 00       	call   804d53b <_posix_zephyr_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 804c500:	80 25 cc 17 05 08 fe 	andb   $0xfe,0x80517cc

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 804c507:	c9                   	leave  
 804c508:	c3                   	ret    

0804c509 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
 804c509:	55                   	push   %ebp
 804c50a:	89 e5                	mov    %esp,%ebp
 804c50c:	57                   	push   %edi
 804c50d:	56                   	push   %esi
 804c50e:	53                   	push   %ebx
 804c50f:	83 ec 14             	sub    $0x14,%esp
 804c512:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_setup_new_thread(thread, stack,
 804c515:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 804c517:	6b fb 50             	imul   $0x50,%ebx,%edi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c51a:	89 d8                	mov    %ebx,%eax
	z_setup_new_thread(thread, stack,
 804c51c:	6a 01                	push   $0x1
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804c51e:	6b f3 14             	imul   $0x14,%ebx,%esi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c521:	c1 e0 08             	shl    $0x8,%eax
	z_setup_new_thread(thread, stack,
 804c524:	6a 0f                	push   $0xf
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c526:	05 7c 29 05 08       	add    $0x805297c,%eax
	z_setup_new_thread(thread, stack,
 804c52b:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 804c52d:	81 c7 60 17 05 08    	add    $0x8051760,%edi
	z_setup_new_thread(thread, stack,
 804c533:	6a 00                	push   $0x0
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804c535:	81 c6 20 18 05 08    	add    $0x8051820,%esi
	z_setup_new_thread(thread, stack,
 804c53b:	56                   	push   %esi
 804c53c:	68 6e c7 04 08       	push   $0x804c76e
 804c541:	68 00 01 00 00       	push   $0x100
 804c546:	50                   	push   %eax
 804c547:	57                   	push   %edi
 804c548:	e8 ec 00 00 00       	call   804c639 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804c54d:	80 67 0d fb          	andb   $0xfb,0xd(%edi)
 804c551:	83 c4 30             	add    $0x30,%esp
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
 804c554:	88 5e 10             	mov    %bl,0x10(%esi)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c557:	c1 e3 0b             	shl    $0xb,%ebx
 804c55a:	8d 83 7c 29 05 08    	lea    0x805297c(%ebx),%eax
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 804c560:	89 7e 0c             	mov    %edi,0xc(%esi)
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c563:	89 46 04             	mov    %eax,0x4(%esi)
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 804c566:	f0 ff 05 4c 19 05 08 	lock incl 0x805194c
	/*
	 * Increment number of CPUs active. The pm subsystem
	 * will keep track of this from here.
	 */
	atomic_inc(&_cpus_active);
}
 804c56d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c570:	5b                   	pop    %ebx
 804c571:	5e                   	pop    %esi
 804c572:	5f                   	pop    %edi
 804c573:	5d                   	pop    %ebp
 804c574:	c3                   	ret    

0804c575 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
 804c575:	55                   	push   %ebp
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 804c576:	31 c0                	xor    %eax,%eax
{
 804c578:	89 e5                	mov    %esp,%ebp
 804c57a:	53                   	push   %ebx
 804c57b:	83 ec 54             	sub    $0x54,%esp
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 804c57e:	e8 ea fe ff ff       	call   804c46d <z_sys_init_run_level>

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
 804c583:	8d 45 a8             	lea    -0x58(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
 804c586:	66 c7 45 b4 01 01    	movw   $0x101,-0x4c(%ebp)
	_current_cpu->current = dummy_thread;
 804c58c:	a3 28 18 05 08       	mov    %eax,0x8051828
	dummy_thread->resource_pool = NULL;
 804c591:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 804c598:	e8 b7 0f 00 00       	call   804d554 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 804c59d:	b8 01 00 00 00       	mov    $0x1,%eax
 804c5a2:	e8 c6 fe ff ff       	call   804c46d <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 804c5a7:	b8 02 00 00 00       	mov    $0x2,%eax
 804c5ac:	e8 bc fe ff ff       	call   804c46d <z_sys_init_run_level>
	z_sched_init();
 804c5b1:	e8 a1 09 00 00       	call   804cf57 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
 804c5b6:	c7 05 34 18 05 08 c0 	movl   $0x80517c0,0x8051834
 804c5bd:	17 05 08 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804c5c0:	50                   	push   %eax
 804c5c1:	50                   	push   %eax
 804c5c2:	68 ba ed 04 08       	push   $0x804edba
 804c5c7:	6a 01                	push   $0x1
 804c5c9:	6a 00                	push   $0x0
 804c5cb:	6a 00                	push   $0x0
 804c5cd:	6a 00                	push   $0x0
 804c5cf:	6a 00                	push   $0x0
 804c5d1:	68 d0 c4 04 08       	push   $0x804c4d0
 804c5d6:	68 00 04 00 00       	push   $0x400
 804c5db:	68 7c 2a 05 08       	push   $0x8052a7c
 804c5e0:	68 c0 17 05 08       	push   $0x80517c0
 804c5e5:	e8 4f 00 00 00       	call   804c639 <z_setup_new_thread>
 804c5ea:	83 c4 24             	add    $0x24,%esp
 804c5ed:	80 25 cd 17 05 08 fb 	andb   $0xfb,0x80517cd
	z_ready_thread(&z_main_thread);
 804c5f4:	68 c0 17 05 08       	push   $0x80517c0
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804c5f9:	89 c3                	mov    %eax,%ebx
	z_ready_thread(&z_main_thread);
 804c5fb:	e8 97 06 00 00       	call   804cc97 <z_ready_thread>
	z_init_cpu(0);
 804c600:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c607:	e8 fd fe ff ff       	call   804c509 <z_init_cpu>
 804c60c:	83 c4 0c             	add    $0xc,%esp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 804c60f:	68 d0 c4 04 08       	push   $0x804c4d0
 804c614:	53                   	push   %ebx
 804c615:	68 c0 17 05 08       	push   $0x80517c0
 804c61a:	e8 ba e1 ff ff       	call   804a7d9 <arch_switch_to_main_thread>
 804c61f:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804c622:	68 d4 01 00 00       	push   $0x1d4
 804c627:	68 bf ed 04 08       	push   $0x804edbf
 804c62c:	68 90 e1 04 08       	push   $0x804e190
 804c631:	e8 ae f2 ff ff       	call   804b8e4 <posix_print_error_and_exit>
 804c636:	83 c4 10             	add    $0x10,%esp

0804c639 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
 804c639:	55                   	push   %ebp
 804c63a:	89 e5                	mov    %esp,%ebp
 804c63c:	53                   	push   %ebx
 804c63d:	83 ec 18             	sub    $0x18,%esp
 804c640:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804c643:	8b 55 0c             	mov    0xc(%ebp),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 804c646:	8d 43 3c             	lea    0x3c(%ebx),%eax

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
 804c649:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 804c650:	89 43 3c             	mov    %eax,0x3c(%ebx)
	list->tail = (sys_dnode_t *)list;
 804c653:	89 43 40             	mov    %eax,0x40(%ebx)
	thread_base->user_options = (uint8_t)options;
 804c656:	8b 45 28             	mov    0x28(%ebp),%eax
	thread_base->thread_state = (uint8_t)initial_state;
 804c659:	c6 43 0d 04          	movb   $0x4,0xd(%ebx)
	thread_base->user_options = (uint8_t)options;
 804c65d:	88 43 0c             	mov    %al,0xc(%ebx)

	thread_base->prio = priority;
 804c660:	8b 45 24             	mov    0x24(%ebp),%eax

	thread_base->sched_locked = 0U;
 804c663:	c6 43 0f 00          	movb   $0x0,0xf(%ebx)
	thread_base->prio = priority;
 804c667:	88 43 0e             	mov    %al,0xe(%ebx)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 804c66a:	8b 45 10             	mov    0x10(%ebp),%eax
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
 804c66d:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
 804c674:	83 c0 03             	add    $0x3,%eax
	node->prev = NULL;
 804c677:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
 804c67e:	83 e0 fc             	and    $0xfffffffc,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c681:	ff 75 20             	push   0x20(%ebp)
	stack_ptr = (char *)stack + stack_obj_size;
 804c684:	01 d0                	add    %edx,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c686:	ff 75 1c             	push   0x1c(%ebp)
 804c689:	ff 75 18             	push   0x18(%ebp)
 804c68c:	ff 75 14             	push   0x14(%ebp)
 804c68f:	50                   	push   %eax
 804c690:	52                   	push   %edx
 804c691:	53                   	push   %ebx
 804c692:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c695:	e8 5b e1 ff ff       	call   804a7f5 <arch_new_thread>
	if (!_current) {
 804c69a:	8b 15 28 18 05 08    	mov    0x8051828,%edx
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c6a0:	83 c4 20             	add    $0x20,%esp
	if (!_current) {
 804c6a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
	new_thread->init_data = NULL;
 804c6a6:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
	if (!_current) {
 804c6ad:	85 d2                	test   %edx,%edx
 804c6af:	74 03                	je     804c6b4 <z_setup_new_thread+0x7b>
	new_thread->resource_pool = _current->resource_pool;
 804c6b1:	8b 52 48             	mov    0x48(%edx),%edx
	return stack_ptr;
 804c6b4:	89 53 48             	mov    %edx,0x48(%ebx)
}
 804c6b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c6ba:	c9                   	leave  
 804c6bb:	c3                   	ret    

0804c6bc <z_init_static_threads>:
{
 804c6bc:	55                   	push   %ebp
 804c6bd:	89 e5                	mov    %esp,%ebp
 804c6bf:	56                   	push   %esi
 804c6c0:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
 804c6c1:	bb f4 11 05 08       	mov    $0x80511f4,%ebx
 804c6c6:	81 fb 4c 12 05 08    	cmp    $0x805124c,%ebx
 804c6cc:	73 31                	jae    804c6ff <z_init_static_threads+0x43>
		z_setup_new_thread(
 804c6ce:	50                   	push   %eax
 804c6cf:	50                   	push   %eax
 804c6d0:	ff 73 28             	push   0x28(%ebx)
 804c6d3:	ff 73 20             	push   0x20(%ebx)
 804c6d6:	ff 73 1c             	push   0x1c(%ebx)
 804c6d9:	ff 73 18             	push   0x18(%ebx)
 804c6dc:	ff 73 14             	push   0x14(%ebx)
 804c6df:	ff 73 10             	push   0x10(%ebx)
 804c6e2:	ff 73 0c             	push   0xc(%ebx)
 804c6e5:	ff 73 08             	push   0x8(%ebx)
 804c6e8:	ff 73 04             	push   0x4(%ebx)
 804c6eb:	ff 33                	push   (%ebx)
 804c6ed:	e8 47 ff ff ff       	call   804c639 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 804c6f2:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
 804c6f4:	83 c4 30             	add    $0x30,%esp
		thread_data->init_thread->init_data = thread_data;
 804c6f7:	89 58 38             	mov    %ebx,0x38(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
 804c6fa:	83 c3 2c             	add    $0x2c,%ebx
 804c6fd:	eb c7                	jmp    804c6c6 <z_init_static_threads+0xa>
	k_sched_lock();
 804c6ff:	e8 b5 03 00 00       	call   804cab9 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
 804c704:	bb f4 11 05 08       	mov    $0x80511f4,%ebx
 804c709:	81 fb 4c 12 05 08    	cmp    $0x805124c,%ebx
 804c70f:	73 52                	jae    804c763 <z_init_static_threads+0xa7>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 804c711:	8b 43 24             	mov    0x24(%ebx),%eax
 804c714:	83 f8 ff             	cmp    $0xffffffff,%eax
 804c717:	74 45                	je     804c75e <z_init_static_threads+0xa2>
					    K_MSEC(thread_data->init_delay));
 804c719:	31 d2                	xor    %edx,%edx
 804c71b:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
 804c71d:	8b 33                	mov    (%ebx),%esi
					    K_MSEC(thread_data->init_delay));
 804c71f:	0f 48 c2             	cmovs  %edx,%eax
 804c722:	99                   	cltd   
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
 804c723:	83 c0 09             	add    $0x9,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 804c726:	89 c1                	mov    %eax,%ecx
 804c728:	83 d2 00             	adc    $0x0,%edx
 804c72b:	83 f1 09             	xor    $0x9,%ecx
 804c72e:	09 d1                	or     %edx,%ecx
 804c730:	75 0b                	jne    804c73d <z_init_static_threads+0x81>
	z_sched_start(thread);
 804c732:	83 ec 0c             	sub    $0xc,%esp
 804c735:	56                   	push   %esi
 804c736:	e8 7d 05 00 00       	call   804ccb8 <z_sched_start>
 804c73b:	eb 1e                	jmp    804c75b <z_init_static_threads+0x9f>
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
 804c73d:	6a 00                	push   $0x0

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 804c73f:	83 c6 18             	add    $0x18,%esi
 804c742:	6a 0a                	push   $0xa
 804c744:	52                   	push   %edx
 804c745:	50                   	push   %eax
 804c746:	e8 a5 cc ff ff       	call   80493f0 <__udivdi3>
 804c74b:	83 c4 10             	add    $0x10,%esp
 804c74e:	52                   	push   %edx
 804c74f:	50                   	push   %eax
 804c750:	68 54 cd 04 08       	push   $0x804cd54
 804c755:	56                   	push   %esi
 804c756:	e8 1e 0b 00 00       	call   804d279 <z_add_timeout>
 804c75b:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
 804c75e:	83 c3 2c             	add    $0x2c,%ebx
 804c761:	eb a6                	jmp    804c709 <z_init_static_threads+0x4d>
}
 804c763:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804c766:	5b                   	pop    %ebx
 804c767:	5e                   	pop    %esi
 804c768:	5d                   	pop    %ebp
	k_sched_unlock();
 804c769:	e9 70 07 00 00       	jmp    804cede <k_sched_unlock>

0804c76e <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
 804c76e:	55                   	push   %ebp
 804c76f:	89 e5                	mov    %esp,%ebp
 804c771:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 804c774:	e8 e6 ec ff ff       	call   804b45f <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
 804c779:	e8 6a db ff ff       	call   804a2e8 <arch_cpu_idle>
 804c77e:	eb f4                	jmp    804c774 <idle+0x6>

0804c780 <k_msgq_init>:
}
#endif /* CONFIG_POLL */

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
 804c780:	55                   	push   %ebp
 804c781:	89 e5                	mov    %esp,%ebp
 804c783:	53                   	push   %ebx
 804c784:	8b 45 08             	mov    0x8(%ebp),%eax
 804c787:	8b 5d 14             	mov    0x14(%ebp),%ebx
 804c78a:	8b 55 10             	mov    0x10(%ebp),%edx
 804c78d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	msgq->msg_size = msg_size;
	msgq->max_msgs = max_msgs;
 804c790:	89 58 0c             	mov    %ebx,0xc(%eax)
	msgq->msg_size = msg_size;
 804c793:	89 50 08             	mov    %edx,0x8(%eax)
	msgq->buffer_start = buffer;
	msgq->buffer_end = buffer + (max_msgs * msg_size);
 804c796:	0f af d3             	imul   %ebx,%edx
	msgq->buffer_start = buffer;
 804c799:	89 48 10             	mov    %ecx,0x10(%eax)
	msgq->read_ptr = buffer;
 804c79c:	89 48 18             	mov    %ecx,0x18(%eax)
	msgq->buffer_end = buffer + (max_msgs * msg_size);
 804c79f:	01 ca                	add    %ecx,%edx
	msgq->write_ptr = buffer;
 804c7a1:	89 48 1c             	mov    %ecx,0x1c(%eax)
	msgq->buffer_end = buffer + (max_msgs * msg_size);
 804c7a4:	89 50 14             	mov    %edx,0x14(%eax)
	msgq->used_msgs = 0;
 804c7a7:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	msgq->flags = 0;
 804c7ae:	c6 40 24 00          	movb   $0x0,0x24(%eax)
	list->head = (sys_dnode_t *)list;
 804c7b2:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
 804c7b4:	89 40 04             	mov    %eax,0x4(%eax)
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
}
 804c7b7:	5b                   	pop    %ebx
 804c7b8:	5d                   	pop    %ebp
 804c7b9:	c3                   	ret    

0804c7ba <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
 804c7ba:	55                   	push   %ebp
 804c7bb:	89 e5                	mov    %esp,%ebp
 804c7bd:	57                   	push   %edi
 804c7be:	56                   	push   %esi
 804c7bf:	53                   	push   %ebx
 804c7c0:	83 ec 1c             	sub    $0x1c,%esp
 804c7c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804c7c6:	8b 75 0c             	mov    0xc(%ebp),%esi

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
 804c7c9:	8d 43 08             	lea    0x8(%ebx),%eax
 804c7cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c7cf:	e8 8b ec ff ff       	call   804b45f <posix_irq_lock>
 804c7d4:	89 c2                	mov    %eax,%edx

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
 804c7d6:	8b 43 0c             	mov    0xc(%ebx),%eax
 804c7d9:	39 43 20             	cmp    %eax,0x20(%ebx)
 804c7dc:	73 63                	jae    804c841 <z_impl_k_msgq_put+0x87>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 804c7de:	83 ec 0c             	sub    $0xc,%esp
 804c7e1:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804c7e4:	53                   	push   %ebx
 804c7e5:	e8 24 07 00 00       	call   804cf0e <z_unpend_first_thread>
 804c7ea:	83 c4 10             	add    $0x10,%esp
		if (pending_thread != NULL) {
 804c7ed:	8b 4b 08             	mov    0x8(%ebx),%ecx
 804c7f0:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804c7f3:	85 c0                	test   %eax,%eax
 804c7f5:	74 2a                	je     804c821 <z_impl_k_msgq_put+0x67>
 804c7f7:	8b 78 14             	mov    0x14(%eax),%edi
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
 804c7fa:	83 ec 0c             	sub    $0xc,%esp
 804c7fd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
 804c7ff:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
 804c806:	50                   	push   %eax
 804c807:	e8 8b 04 00 00       	call   804cc97 <z_ready_thread>
 804c80c:	58                   	pop    %eax
 804c80d:	5a                   	pop    %edx
			z_reschedule(&msgq->lock, key);
 804c80e:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804c811:	52                   	push   %edx
 804c812:	ff 75 e4             	push   -0x1c(%ebp)
 804c815:	e8 31 02 00 00       	call   804ca4b <z_reschedule>
 804c81a:	83 c4 10             	add    $0x10,%esp
			return 0;
 804c81d:	31 c0                	xor    %eax,%eax
 804c81f:	eb 5f                	jmp    804c880 <z_impl_k_msgq_put+0xc6>
 804c821:	8b 7b 1c             	mov    0x1c(%ebx),%edi
 804c824:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		} else {
			/* put message in queue */
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
					msgq->write_ptr < msgq->buffer_end);
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
 804c826:	8b 43 08             	mov    0x8(%ebx),%eax
 804c829:	03 43 1c             	add    0x1c(%ebx),%eax
 804c82c:	89 43 1c             	mov    %eax,0x1c(%ebx)
			if (msgq->write_ptr == msgq->buffer_end) {
 804c82f:	3b 43 14             	cmp    0x14(%ebx),%eax
 804c832:	75 06                	jne    804c83a <z_impl_k_msgq_put+0x80>
				msgq->write_ptr = msgq->buffer_start;
 804c834:	8b 43 10             	mov    0x10(%ebx),%eax
 804c837:	89 43 1c             	mov    %eax,0x1c(%ebx)
			}
			msgq->used_msgs++;
 804c83a:	ff 43 20             	incl   0x20(%ebx)
#ifdef CONFIG_POLL
			handle_poll_events(msgq, K_POLL_STATE_MSGQ_DATA_AVAILABLE);
#endif /* CONFIG_POLL */
		}
		result = 0;
 804c83d:	31 c0                	xor    %eax,%eax
 804c83f:	eb 2d                	jmp    804c86e <z_impl_k_msgq_put+0xb4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804c841:	8b 7d 14             	mov    0x14(%ebp),%edi
 804c844:	0b 7d 10             	or     0x10(%ebp),%edi
		/* don't wait for message space to become available */
		result = -ENOMSG;
 804c847:	b8 d6 ff ff ff       	mov    $0xffffffd6,%eax
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804c84c:	74 20                	je     804c86e <z_impl_k_msgq_put+0xb4>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, put, msgq, timeout);

		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
 804c84e:	a1 28 18 05 08       	mov    0x8051828,%eax

		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 804c853:	83 ec 0c             	sub    $0xc,%esp
		_current->base.swap_data = (void *) data;
 804c856:	89 70 14             	mov    %esi,0x14(%eax)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 804c859:	ff 75 14             	push   0x14(%ebp)
 804c85c:	ff 75 10             	push   0x10(%ebp)
 804c85f:	53                   	push   %ebx
 804c860:	52                   	push   %edx
 804c861:	ff 75 e4             	push   -0x1c(%ebp)
 804c864:	e8 c9 05 00 00       	call   804ce32 <z_pend_curr>
 804c869:	83 c4 20             	add    $0x20,%esp
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);
		return result;
 804c86c:	eb 12                	jmp    804c880 <z_impl_k_msgq_put+0xc6>
	posix_irq_unlock(key);
 804c86e:	83 ec 0c             	sub    $0xc,%esp
 804c871:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c874:	52                   	push   %edx
 804c875:	e8 f7 eb ff ff       	call   804b471 <posix_irq_unlock>
 804c87a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c87d:	83 c4 10             	add    $0x10,%esp
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
 804c880:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c883:	5b                   	pop    %ebx
 804c884:	5e                   	pop    %esi
 804c885:	5f                   	pop    %edi
 804c886:	5d                   	pop    %ebp
 804c887:	c3                   	ret    

0804c888 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
 804c888:	55                   	push   %ebp
 804c889:	89 e5                	mov    %esp,%ebp
 804c88b:	57                   	push   %edi
 804c88c:	56                   	push   %esi
 804c88d:	53                   	push   %ebx
 804c88e:	83 ec 1c             	sub    $0x1c,%esp
 804c891:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804c894:	8b 75 10             	mov    0x10(%ebp),%esi
 804c897:	8b 7d 14             	mov    0x14(%ebp),%edi

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
 804c89a:	8d 43 08             	lea    0x8(%ebx),%eax
 804c89d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return posix_irq_lock();
 804c8a0:	e8 ba eb ff ff       	call   804b45f <posix_irq_lock>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
 804c8a5:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
 804c8a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c8ac:	74 7c                	je     804c92a <z_impl_k_msgq_get+0xa2>
 804c8ae:	8b 73 18             	mov    0x18(%ebx),%esi
 804c8b1:	8b 4b 08             	mov    0x8(%ebx),%ecx
 804c8b4:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804c8b7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
 804c8b9:	8b 43 08             	mov    0x8(%ebx),%eax
 804c8bc:	03 43 18             	add    0x18(%ebx),%eax
 804c8bf:	89 43 18             	mov    %eax,0x18(%ebx)
		if (msgq->read_ptr == msgq->buffer_end) {
 804c8c2:	3b 43 14             	cmp    0x14(%ebx),%eax
 804c8c5:	75 06                	jne    804c8cd <z_impl_k_msgq_get+0x45>
			msgq->read_ptr = msgq->buffer_start;
 804c8c7:	8b 43 10             	mov    0x10(%ebx),%eax
 804c8ca:	89 43 18             	mov    %eax,0x18(%ebx)
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 804c8cd:	83 ec 0c             	sub    $0xc,%esp
		msgq->used_msgs--;
 804c8d0:	ff 4b 20             	decl   0x20(%ebx)
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 804c8d3:	53                   	push   %ebx
 804c8d4:	e8 35 06 00 00       	call   804cf0e <z_unpend_first_thread>
 804c8d9:	83 c4 10             	add    $0x10,%esp
 804c8dc:	89 c2                	mov    %eax,%edx

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
		}
		result = 0;
 804c8de:	31 c0                	xor    %eax,%eax
		if (pending_thread != NULL) {
 804c8e0:	85 d2                	test   %edx,%edx
 804c8e2:	74 72                	je     804c956 <z_impl_k_msgq_get+0xce>
 804c8e4:	8b 72 14             	mov    0x14(%edx),%esi
 804c8e7:	8b 7b 1c             	mov    0x1c(%ebx),%edi
 804c8ea:	8b 4b 08             	mov    0x8(%ebx),%ecx
 804c8ed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
			msgq->write_ptr += msgq->msg_size;
 804c8ef:	8b 43 08             	mov    0x8(%ebx),%eax
 804c8f2:	03 43 1c             	add    0x1c(%ebx),%eax
 804c8f5:	89 43 1c             	mov    %eax,0x1c(%ebx)
			if (msgq->write_ptr == msgq->buffer_end) {
 804c8f8:	3b 43 14             	cmp    0x14(%ebx),%eax
 804c8fb:	75 06                	jne    804c903 <z_impl_k_msgq_get+0x7b>
				msgq->write_ptr = msgq->buffer_start;
 804c8fd:	8b 43 10             	mov    0x10(%ebx),%eax
 804c900:	89 43 1c             	mov    %eax,0x1c(%ebx)
			z_ready_thread(pending_thread);
 804c903:	83 ec 0c             	sub    $0xc,%esp
			msgq->used_msgs++;
 804c906:	ff 43 20             	incl   0x20(%ebx)
 804c909:	c7 42 30 00 00 00 00 	movl   $0x0,0x30(%edx)
			z_ready_thread(pending_thread);
 804c910:	52                   	push   %edx
 804c911:	e8 81 03 00 00       	call   804cc97 <z_ready_thread>
 804c916:	58                   	pop    %eax
 804c917:	5a                   	pop    %edx
			z_reschedule(&msgq->lock, key);
 804c918:	ff 75 e4             	push   -0x1c(%ebp)
 804c91b:	ff 75 e0             	push   -0x20(%ebp)
 804c91e:	e8 28 01 00 00       	call   804ca4b <z_reschedule>
 804c923:	83 c4 10             	add    $0x10,%esp
			return 0;
 804c926:	31 c0                	xor    %eax,%eax
 804c928:	eb 40                	jmp    804c96a <z_impl_k_msgq_get+0xe2>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804c92a:	89 fa                	mov    %edi,%edx
		/* don't wait for a message to become available */
		result = -ENOMSG;
 804c92c:	b8 d6 ff ff ff       	mov    $0xffffffd6,%eax
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804c931:	09 f2                	or     %esi,%edx
 804c933:	74 21                	je     804c956 <z_impl_k_msgq_get+0xce>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

		/* wait for get message success or timeout */
		_current->base.swap_data = data;
 804c935:	a1 28 18 05 08       	mov    0x8051828,%eax
 804c93a:	8b 4d 0c             	mov    0xc(%ebp),%ecx

		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 804c93d:	83 ec 0c             	sub    $0xc,%esp
		_current->base.swap_data = data;
 804c940:	89 48 14             	mov    %ecx,0x14(%eax)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 804c943:	57                   	push   %edi
 804c944:	56                   	push   %esi
 804c945:	53                   	push   %ebx
 804c946:	ff 75 e4             	push   -0x1c(%ebp)
 804c949:	ff 75 e0             	push   -0x20(%ebp)
 804c94c:	e8 e1 04 00 00       	call   804ce32 <z_pend_curr>
 804c951:	83 c4 20             	add    $0x20,%esp
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);
		return result;
 804c954:	eb 14                	jmp    804c96a <z_impl_k_msgq_get+0xe2>
	posix_irq_unlock(key);
 804c956:	83 ec 0c             	sub    $0xc,%esp
 804c959:	ff 75 e4             	push   -0x1c(%ebp)
 804c95c:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804c95f:	e8 0d eb ff ff       	call   804b471 <posix_irq_unlock>
 804c964:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c967:	83 c4 10             	add    $0x10,%esp
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
 804c96a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c96d:	5b                   	pop    %ebx
 804c96e:	5e                   	pop    %esi
 804c96f:	5f                   	pop    %edi
 804c970:	5d                   	pop    %ebp
 804c971:	c3                   	ret    

0804c972 <sys_dlist_remove>:
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
 804c972:	8b 48 04             	mov    0x4(%eax),%ecx
	sys_dnode_t *const next = node->next;
 804c975:	8b 10                	mov    (%eax),%edx

	prev->next = next;
 804c977:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 804c979:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
 804c97c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
 804c982:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	sys_dnode_init(node);
}
 804c989:	c3                   	ret    

0804c98a <sliceable>:
#endif
	return ret;
}

static inline bool sliceable(struct k_thread *thread)
{
 804c98a:	89 c2                	mov    %eax,%edx
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
 804c98c:	31 c0                	xor    %eax,%eax
 804c98e:	66 83 7a 0e 7f       	cmpw   $0x7f,0xe(%edx)
 804c993:	77 2b                	ja     804c9c0 <sliceable+0x36>
	int ret = slice_ticks;
 804c995:	a1 68 19 05 08       	mov    0x8051968,%eax
		&& slice_time(thread) != 0
 804c99a:	85 c0                	test   %eax,%eax
 804c99c:	74 22                	je     804c9c0 <sliceable+0x36>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 804c99e:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
		&& !z_is_idle_thread_object(thread);
 804c9a2:	31 c0                	xor    %eax,%eax
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 804c9a4:	39 0d 64 19 05 08    	cmp    %ecx,0x8051964
 804c9aa:	7f 14                	jg     804c9c0 <sliceable+0x36>
		&& !z_is_thread_prevented_from_running(thread)
 804c9ac:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
 804c9b0:	0f 94 c1             	sete   %cl
		&& !z_is_idle_thread_object(thread);
 804c9b3:	31 c0                	xor    %eax,%eax
 804c9b5:	81 fa 60 17 05 08    	cmp    $0x8051760,%edx
 804c9bb:	0f 95 c0             	setne  %al
 804c9be:	21 c8                	and    %ecx,%eax
	bool ret = is_preempt(thread)
 804c9c0:	83 e0 01             	and    $0x1,%eax
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
 804c9c3:	c3                   	ret    

0804c9c4 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
 804c9c4:	55                   	push   %ebp
 804c9c5:	89 e5                	mov    %esp,%ebp
	int cpu = ARRAY_INDEX(slice_timeouts, t);
 804c9c7:	8b 45 08             	mov    0x8(%ebp),%eax
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
 804c9ca:	5d                   	pop    %ebp
	int cpu = ARRAY_INDEX(slice_timeouts, t);
 804c9cb:	2d 50 19 05 08       	sub    $0x8051950,%eax
 804c9d0:	c1 f8 02             	sar    $0x2,%eax
 804c9d3:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
	slice_expired[cpu] = true;
 804c9d9:	c6 80 78 19 05 08 01 	movb   $0x1,0x8051978(%eax)
}
 804c9e0:	c3                   	ret    

0804c9e1 <unpend_thread_no_timeout>:
		pend_locked(thread, wait_q, timeout);
	}
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
 804c9e1:	55                   	push   %ebp
 804c9e2:	89 e5                	mov    %esp,%ebp
 804c9e4:	83 ec 08             	sub    $0x8,%esp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
 804c9e7:	e8 86 ff ff ff       	call   804c972 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
 804c9ec:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
	thread->base.pended_on = NULL;
 804c9f0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
 804c9f7:	c9                   	leave  
 804c9f8:	c3                   	ret    

0804c9f9 <z_reset_time_slice>:
{
 804c9f9:	55                   	push   %ebp
 804c9fa:	89 e5                	mov    %esp,%ebp
 804c9fc:	56                   	push   %esi
	z_abort_timeout(&slice_timeouts[cpu]);
 804c9fd:	0f b6 35 30 18 05 08 	movzbl 0x8051830,%esi
{
 804ca04:	53                   	push   %ebx
	z_abort_timeout(&slice_timeouts[cpu]);
 804ca05:	6b de 14             	imul   $0x14,%esi,%ebx
 804ca08:	83 ec 0c             	sub    $0xc,%esp
 804ca0b:	81 c3 50 19 05 08    	add    $0x8051950,%ebx
 804ca11:	53                   	push   %ebx
 804ca12:	e8 a1 09 00 00       	call   804d3b8 <z_abort_timeout>
	if (sliceable(curr)) {
 804ca17:	8b 45 08             	mov    0x8(%ebp),%eax
	z_abort_timeout(&slice_timeouts[cpu]);
 804ca1a:	83 c4 10             	add    $0x10,%esp
	slice_expired[cpu] = false;
 804ca1d:	c6 86 78 19 05 08 00 	movb   $0x0,0x8051978(%esi)
	if (sliceable(curr)) {
 804ca24:	e8 61 ff ff ff       	call   804c98a <sliceable>
 804ca29:	84 c0                	test   %al,%al
 804ca2b:	74 17                	je     804ca44 <z_reset_time_slice+0x4b>
			      K_TICKS(slice_time(curr) - 1));
 804ca2d:	a1 68 19 05 08       	mov    0x8051968,%eax
 804ca32:	48                   	dec    %eax
 804ca33:	99                   	cltd   
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 804ca34:	52                   	push   %edx
 804ca35:	50                   	push   %eax
 804ca36:	68 c4 c9 04 08       	push   $0x804c9c4
 804ca3b:	53                   	push   %ebx
 804ca3c:	e8 38 08 00 00       	call   804d279 <z_add_timeout>
 804ca41:	83 c4 10             	add    $0x10,%esp
}
 804ca44:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ca47:	5b                   	pop    %ebx
 804ca48:	5e                   	pop    %esi
 804ca49:	5d                   	pop    %ebp
 804ca4a:	c3                   	ret    

0804ca4b <z_reschedule>:
{
 804ca4b:	55                   	push   %ebp
 804ca4c:	89 e5                	mov    %esp,%ebp
 804ca4e:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (resched(key.key) && need_swap()) {
 804ca51:	89 c2                	mov    %eax,%edx
 804ca53:	0b 15 20 18 05 08    	or     0x8051820,%edx
 804ca59:	75 1b                	jne    804ca76 <z_reschedule+0x2b>
 804ca5b:	8b 0d 28 18 05 08    	mov    0x8051828,%ecx
 804ca61:	39 0d 34 18 05 08    	cmp    %ecx,0x8051834
 804ca67:	74 0d                	je     804ca76 <z_reschedule+0x2b>
	ret = arch_swap(key);
 804ca69:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 804ca70:	5d                   	pop    %ebp
 804ca71:	e9 13 dd ff ff       	jmp    804a789 <arch_swap>
 804ca76:	89 45 08             	mov    %eax,0x8(%ebp)
 804ca79:	5d                   	pop    %ebp
 804ca7a:	e9 f2 e9 ff ff       	jmp    804b471 <posix_irq_unlock>

0804ca7f <z_reschedule_irqlock>:
{
 804ca7f:	55                   	push   %ebp
 804ca80:	89 e5                	mov    %esp,%ebp
	if (resched(key)) {
 804ca82:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca85:	0b 05 20 18 05 08    	or     0x8051820,%eax
 804ca8b:	75 0d                	jne    804ca9a <z_reschedule_irqlock+0x1b>
 804ca8d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 804ca94:	5d                   	pop    %ebp
 804ca95:	e9 ef dc ff ff       	jmp    804a789 <arch_swap>
 804ca9a:	5d                   	pop    %ebp
 804ca9b:	e9 d1 e9 ff ff       	jmp    804b471 <posix_irq_unlock>

0804caa0 <z_reschedule_unlocked>:
{
 804caa0:	55                   	push   %ebp
 804caa1:	89 e5                	mov    %esp,%ebp
 804caa3:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 804caa6:	e8 b4 e9 ff ff       	call   804b45f <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
 804caab:	83 ec 0c             	sub    $0xc,%esp
 804caae:	50                   	push   %eax
 804caaf:	e8 cb ff ff ff       	call   804ca7f <z_reschedule_irqlock>
 804cab4:	83 c4 10             	add    $0x10,%esp
}
 804cab7:	c9                   	leave  
 804cab8:	c3                   	ret    

0804cab9 <k_sched_lock>:
{
 804cab9:	55                   	push   %ebp
 804caba:	89 e5                	mov    %esp,%ebp
 804cabc:	83 ec 08             	sub    $0x8,%esp
 804cabf:	e8 9b e9 ff ff       	call   804b45f <posix_irq_lock>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
 804cac4:	8b 15 28 18 05 08    	mov    0x8051828,%edx
 804caca:	fe 4a 0f             	decb   0xf(%edx)
	posix_irq_unlock(key);
 804cacd:	83 ec 0c             	sub    $0xc,%esp
 804cad0:	50                   	push   %eax
 804cad1:	e8 9b e9 ff ff       	call   804b471 <posix_irq_unlock>
 804cad6:	83 c4 10             	add    $0x10,%esp
}
 804cad9:	c9                   	leave  
 804cada:	c3                   	ret    

0804cadb <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
 804cadb:	55                   	push   %ebp
 804cadc:	89 e5                	mov    %esp,%ebp
 804cade:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
 804cae1:	8b 02                	mov    (%edx),%eax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
 804cae3:	85 c0                	test   %eax,%eax
 804cae5:	74 04                	je     804caeb <z_priq_dumb_best+0x10>
 804cae7:	39 c2                	cmp    %eax,%edx
 804cae9:	75 02                	jne    804caed <z_priq_dumb_best+0x12>
	struct k_thread *thread = NULL;
 804caeb:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
 804caed:	5d                   	pop    %ebp
 804caee:	c3                   	ret    

0804caef <update_cache>:
{
 804caef:	55                   	push   %ebp
 804caf0:	89 c1                	mov    %eax,%ecx
 804caf2:	89 e5                	mov    %esp,%ebp
 804caf4:	53                   	push   %ebx
 804caf5:	83 ec 10             	sub    $0x10,%esp
	return _priq_run_best(curr_cpu_runq());
 804caf8:	68 38 18 05 08       	push   $0x8051838
 804cafd:	e8 d9 ff ff ff       	call   804cadb <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804cb02:	8b 1d 2c 18 05 08    	mov    0x805182c,%ebx
	return _priq_run_best(curr_cpu_runq());
 804cb08:	83 c4 10             	add    $0x10,%esp
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804cb0b:	85 c0                	test   %eax,%eax
 804cb0d:	74 02                	je     804cb11 <update_cache+0x22>
 804cb0f:	89 c3                	mov    %eax,%ebx
	if (z_is_thread_prevented_from_running(_current)) {
 804cb11:	8b 15 28 18 05 08    	mov    0x8051828,%edx
	if (preempt_ok != 0) {
 804cb17:	85 c9                	test   %ecx,%ecx
 804cb19:	75 0d                	jne    804cb28 <update_cache+0x39>
	if (z_is_thread_prevented_from_running(_current)) {
 804cb1b:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
 804cb1f:	75 07                	jne    804cb28 <update_cache+0x39>
	if (is_preempt(_current) || is_metairq(thread)) {
 804cb21:	66 83 7a 0e 7f       	cmpw   $0x7f,0xe(%edx)
 804cb26:	77 12                	ja     804cb3a <update_cache+0x4b>
		if (thread != _current) {
 804cb28:	39 d3                	cmp    %edx,%ebx
 804cb2a:	74 0c                	je     804cb38 <update_cache+0x49>
			z_reset_time_slice(thread);
 804cb2c:	83 ec 0c             	sub    $0xc,%esp
 804cb2f:	53                   	push   %ebx
 804cb30:	e8 c4 fe ff ff       	call   804c9f9 <z_reset_time_slice>
 804cb35:	83 c4 10             	add    $0x10,%esp
		_kernel.ready_q.cache = thread;
 804cb38:	89 da                	mov    %ebx,%edx
 804cb3a:	89 15 34 18 05 08    	mov    %edx,0x8051834
}
 804cb40:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804cb43:	c9                   	leave  
 804cb44:	c3                   	ret    

0804cb45 <move_thread_to_end_of_prio_q>:
{
 804cb45:	55                   	push   %ebp
 804cb46:	89 e5                	mov    %esp,%ebp
 804cb48:	56                   	push   %esi
 804cb49:	53                   	push   %ebx
	return (thread->base.thread_state & state) != 0U;
 804cb4a:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
 804cb4d:	84 d2                	test   %dl,%dl
 804cb4f:	79 0b                	jns    804cb5c <move_thread_to_end_of_prio_q+0x17>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804cb51:	83 e2 7f             	and    $0x7f,%edx
 804cb54:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cb57:	e8 16 fe ff ff       	call   804c972 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
 804cb5c:	80 48 0d 80          	orb    $0x80,0xd(%eax)
 804cb60:	8b 15 38 18 05 08    	mov    0x8051838,%edx
 804cb66:	8b 0d 3c 18 05 08    	mov    0x805183c,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cb6c:	85 d2                	test   %edx,%edx
 804cb6e:	74 31                	je     804cba1 <move_thread_to_end_of_prio_q+0x5c>
 804cb70:	81 fa 38 18 05 08    	cmp    $0x8051838,%edx
 804cb76:	74 29                	je     804cba1 <move_thread_to_end_of_prio_q+0x5c>
	int32_t b1 = thread_1->base.prio;
 804cb78:	0f be 58 0e          	movsbl 0xe(%eax),%ebx
	int32_t b2 = thread_2->base.prio;
 804cb7c:	0f be 72 0e          	movsbl 0xe(%edx),%esi
	if (b1 != b2) {
 804cb80:	39 f3                	cmp    %esi,%ebx
 804cb82:	74 13                	je     804cb97 <move_thread_to_end_of_prio_q+0x52>
		if (z_sched_prio_cmp(thread, t) > 0) {
 804cb84:	39 de                	cmp    %ebx,%esi
 804cb86:	7e 0f                	jle    804cb97 <move_thread_to_end_of_prio_q+0x52>
	sys_dnode_t *const prev = successor->prev;
 804cb88:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804cb8b:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804cb8d:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804cb90:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804cb92:	89 42 04             	mov    %eax,0x4(%edx)
}
 804cb95:	eb 1a                	jmp    804cbb1 <move_thread_to_end_of_prio_q+0x6c>
	return (node == list->tail) ? NULL : node->next;
 804cb97:	39 ca                	cmp    %ecx,%edx
 804cb99:	74 06                	je     804cba1 <move_thread_to_end_of_prio_q+0x5c>
 804cb9b:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cb9d:	85 d2                	test   %edx,%edx
 804cb9f:	75 db                	jne    804cb7c <move_thread_to_end_of_prio_q+0x37>
	node->next = list;
 804cba1:	c7 00 38 18 05 08    	movl   $0x8051838,(%eax)
	node->prev = tail;
 804cba7:	89 48 04             	mov    %ecx,0x4(%eax)
	tail->next = node;
 804cbaa:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
 804cbac:	a3 3c 18 05 08       	mov    %eax,0x805183c
	update_cache(thread == _current);
 804cbb1:	39 05 28 18 05 08    	cmp    %eax,0x8051828
}
 804cbb7:	5b                   	pop    %ebx
	update_cache(thread == _current);
 804cbb8:	0f 94 c0             	sete   %al
}
 804cbbb:	5e                   	pop    %esi
 804cbbc:	5d                   	pop    %ebp
	update_cache(thread == _current);
 804cbbd:	0f b6 c0             	movzbl %al,%eax
 804cbc0:	e9 2a ff ff ff       	jmp    804caef <update_cache>

0804cbc5 <z_time_slice>:
{
 804cbc5:	55                   	push   %ebp
 804cbc6:	89 e5                	mov    %esp,%ebp
 804cbc8:	56                   	push   %esi
 804cbc9:	53                   	push   %ebx
	return posix_irq_lock();
 804cbca:	e8 90 e8 ff ff       	call   804b45f <posix_irq_lock>
 804cbcf:	89 c6                	mov    %eax,%esi
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
 804cbd1:	0f b6 05 30 18 05 08 	movzbl 0x8051830,%eax
 804cbd8:	80 b8 78 19 05 08 00 	cmpb   $0x0,0x8051978(%eax)
 804cbdf:	74 2a                	je     804cc0b <z_time_slice+0x46>
	struct k_thread *curr = _current;
 804cbe1:	8b 1d 28 18 05 08    	mov    0x8051828,%ebx
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
 804cbe7:	89 d8                	mov    %ebx,%eax
 804cbe9:	e8 9c fd ff ff       	call   804c98a <sliceable>
 804cbee:	84 c0                	test   %al,%al
 804cbf0:	74 19                	je     804cc0b <z_time_slice+0x46>
		if (!z_is_thread_prevented_from_running(curr)) {
 804cbf2:	f6 43 0d 1f          	testb  $0x1f,0xd(%ebx)
 804cbf6:	75 07                	jne    804cbff <z_time_slice+0x3a>
			move_thread_to_end_of_prio_q(curr);
 804cbf8:	89 d8                	mov    %ebx,%eax
 804cbfa:	e8 46 ff ff ff       	call   804cb45 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
 804cbff:	83 ec 0c             	sub    $0xc,%esp
 804cc02:	53                   	push   %ebx
 804cc03:	e8 f1 fd ff ff       	call   804c9f9 <z_reset_time_slice>
 804cc08:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804cc0b:	83 ec 0c             	sub    $0xc,%esp
 804cc0e:	56                   	push   %esi
 804cc0f:	e8 5d e8 ff ff       	call   804b471 <posix_irq_unlock>
 804cc14:	83 c4 10             	add    $0x10,%esp
}
 804cc17:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cc1a:	5b                   	pop    %ebx
 804cc1b:	5e                   	pop    %esi
 804cc1c:	5d                   	pop    %ebp
 804cc1d:	c3                   	ret    

0804cc1e <ready_thread>:
 804cc1e:	8a 50 0d             	mov    0xd(%eax),%dl
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 804cc21:	84 d2                	test   %dl,%dl
 804cc23:	78 71                	js     804cc96 <ready_thread+0x78>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 804cc25:	f6 c2 1f             	test   $0x1f,%dl
 804cc28:	75 6c                	jne    804cc96 <ready_thread+0x78>
 804cc2a:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
 804cc2e:	75 66                	jne    804cc96 <ready_thread+0x78>
{
 804cc30:	55                   	push   %ebp
	thread->base.thread_state |= _THREAD_QUEUED;
 804cc31:	83 ca 80             	or     $0xffffff80,%edx
{
 804cc34:	89 e5                	mov    %esp,%ebp
 804cc36:	56                   	push   %esi
 804cc37:	53                   	push   %ebx
	thread->base.thread_state |= _THREAD_QUEUED;
 804cc38:	88 50 0d             	mov    %dl,0xd(%eax)
	return list->head == list;
 804cc3b:	8b 15 38 18 05 08    	mov    0x8051838,%edx
 804cc41:	8b 0d 3c 18 05 08    	mov    0x805183c,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cc47:	85 d2                	test   %edx,%edx
 804cc49:	74 31                	je     804cc7c <ready_thread+0x5e>
 804cc4b:	81 fa 38 18 05 08    	cmp    $0x8051838,%edx
 804cc51:	74 29                	je     804cc7c <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
 804cc53:	0f be 58 0e          	movsbl 0xe(%eax),%ebx
	int32_t b2 = thread_2->base.prio;
 804cc57:	0f be 72 0e          	movsbl 0xe(%edx),%esi
	if (b1 != b2) {
 804cc5b:	39 f3                	cmp    %esi,%ebx
 804cc5d:	74 13                	je     804cc72 <ready_thread+0x54>
		if (z_sched_prio_cmp(thread, t) > 0) {
 804cc5f:	39 de                	cmp    %ebx,%esi
 804cc61:	7e 0f                	jle    804cc72 <ready_thread+0x54>
	sys_dnode_t *const prev = successor->prev;
 804cc63:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804cc66:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804cc68:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804cc6b:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804cc6d:	89 42 04             	mov    %eax,0x4(%edx)
}
 804cc70:	eb 1a                	jmp    804cc8c <ready_thread+0x6e>
	return (node == list->tail) ? NULL : node->next;
 804cc72:	39 ca                	cmp    %ecx,%edx
 804cc74:	74 06                	je     804cc7c <ready_thread+0x5e>
 804cc76:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cc78:	85 d2                	test   %edx,%edx
 804cc7a:	75 db                	jne    804cc57 <ready_thread+0x39>
	node->next = list;
 804cc7c:	c7 00 38 18 05 08    	movl   $0x8051838,(%eax)
	node->prev = tail;
 804cc82:	89 48 04             	mov    %ecx,0x4(%eax)
	tail->next = node;
 804cc85:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
 804cc87:	a3 3c 18 05 08       	mov    %eax,0x805183c
}
 804cc8c:	5b                   	pop    %ebx
		update_cache(0);
 804cc8d:	31 c0                	xor    %eax,%eax
}
 804cc8f:	5e                   	pop    %esi
 804cc90:	5d                   	pop    %ebp
		update_cache(0);
 804cc91:	e9 59 fe ff ff       	jmp    804caef <update_cache>
 804cc96:	c3                   	ret    

0804cc97 <z_ready_thread>:
{
 804cc97:	55                   	push   %ebp
 804cc98:	89 e5                	mov    %esp,%ebp
 804cc9a:	56                   	push   %esi
 804cc9b:	53                   	push   %ebx
 804cc9c:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804cc9f:	e8 bb e7 ff ff       	call   804b45f <posix_irq_lock>
 804cca4:	89 c3                	mov    %eax,%ebx
			ready_thread(thread);
 804cca6:	89 f0                	mov    %esi,%eax
 804cca8:	e8 71 ff ff ff       	call   804cc1e <ready_thread>
	posix_irq_unlock(key);
 804ccad:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804ccb0:	5b                   	pop    %ebx
 804ccb1:	5e                   	pop    %esi
 804ccb2:	5d                   	pop    %ebp
 804ccb3:	e9 b9 e7 ff ff       	jmp    804b471 <posix_irq_unlock>

0804ccb8 <z_sched_start>:
{
 804ccb8:	55                   	push   %ebp
 804ccb9:	89 e5                	mov    %esp,%ebp
 804ccbb:	56                   	push   %esi
 804ccbc:	53                   	push   %ebx
 804ccbd:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804ccc0:	e8 9a e7 ff ff       	call   804b45f <posix_irq_lock>
 804ccc5:	89 c3                	mov    %eax,%ebx
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
 804ccc7:	8a 46 0d             	mov    0xd(%esi),%al
	if (z_has_thread_started(thread)) {
 804ccca:	a8 04                	test   $0x4,%al
 804cccc:	75 0e                	jne    804ccdc <z_sched_start+0x24>
	posix_irq_unlock(key);
 804ccce:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804ccd1:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ccd4:	5b                   	pop    %ebx
 804ccd5:	5e                   	pop    %esi
 804ccd6:	5d                   	pop    %ebp
 804ccd7:	e9 95 e7 ff ff       	jmp    804b471 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804ccdc:	83 e0 fb             	and    $0xfffffffb,%eax
 804ccdf:	88 46 0d             	mov    %al,0xd(%esi)
	ready_thread(thread);
 804cce2:	89 f0                	mov    %esi,%eax
 804cce4:	e8 35 ff ff ff       	call   804cc1e <ready_thread>
	z_reschedule(&sched_spinlock, key);
 804cce9:	50                   	push   %eax
 804ccea:	50                   	push   %eax
 804cceb:	53                   	push   %ebx
 804ccec:	68 79 19 05 08       	push   $0x8051979
 804ccf1:	e8 55 fd ff ff       	call   804ca4b <z_reschedule>
 804ccf6:	83 c4 10             	add    $0x10,%esp
}
 804ccf9:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ccfc:	5b                   	pop    %ebx
 804ccfd:	5e                   	pop    %esi
 804ccfe:	5d                   	pop    %ebp
 804ccff:	c3                   	ret    

0804cd00 <z_sched_wake_thread>:
{
 804cd00:	55                   	push   %ebp
 804cd01:	89 e5                	mov    %esp,%ebp
 804cd03:	57                   	push   %edi
 804cd04:	56                   	push   %esi
 804cd05:	53                   	push   %ebx
 804cd06:	83 ec 0c             	sub    $0xc,%esp
 804cd09:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804cd0c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 804cd0f:	e8 4b e7 ff ff       	call   804b45f <posix_irq_lock>
 804cd14:	89 c6                	mov    %eax,%esi
		if (!killed) {
 804cd16:	f6 43 0d 28          	testb  $0x28,0xd(%ebx)
 804cd1a:	75 29                	jne    804cd45 <z_sched_wake_thread+0x45>
			if (thread->base.pended_on != NULL) {
 804cd1c:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 804cd20:	74 07                	je     804cd29 <z_sched_wake_thread+0x29>
				unpend_thread_no_timeout(thread);
 804cd22:	89 d8                	mov    %ebx,%eax
 804cd24:	e8 b8 fc ff ff       	call   804c9e1 <unpend_thread_no_timeout>
 804cd29:	8a 43 0d             	mov    0xd(%ebx),%al
 804cd2c:	89 f9                	mov    %edi,%ecx
 804cd2e:	89 c2                	mov    %eax,%edx
 804cd30:	83 e0 fb             	and    $0xfffffffb,%eax
 804cd33:	83 e2 eb             	and    $0xffffffeb,%edx
 804cd36:	84 c9                	test   %cl,%cl
 804cd38:	0f 45 c2             	cmovne %edx,%eax
 804cd3b:	88 43 0d             	mov    %al,0xd(%ebx)
			ready_thread(thread);
 804cd3e:	89 d8                	mov    %ebx,%eax
 804cd40:	e8 d9 fe ff ff       	call   804cc1e <ready_thread>
	posix_irq_unlock(key);
 804cd45:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804cd48:	83 c4 0c             	add    $0xc,%esp
 804cd4b:	5b                   	pop    %ebx
 804cd4c:	5e                   	pop    %esi
 804cd4d:	5f                   	pop    %edi
 804cd4e:	5d                   	pop    %ebp
 804cd4f:	e9 1d e7 ff ff       	jmp    804b471 <posix_irq_unlock>

0804cd54 <z_thread_timeout>:
{
 804cd54:	55                   	push   %ebp
 804cd55:	89 e5                	mov    %esp,%ebp
 804cd57:	83 ec 10             	sub    $0x10,%esp
	struct k_thread *thread = CONTAINER_OF(timeout,
 804cd5a:	8b 45 08             	mov    0x8(%ebp),%eax
	z_sched_wake_thread(thread, true);
 804cd5d:	6a 01                	push   $0x1
	struct k_thread *thread = CONTAINER_OF(timeout,
 804cd5f:	83 e8 18             	sub    $0x18,%eax
	z_sched_wake_thread(thread, true);
 804cd62:	50                   	push   %eax
 804cd63:	e8 98 ff ff ff       	call   804cd00 <z_sched_wake_thread>
 804cd68:	83 c4 10             	add    $0x10,%esp
}
 804cd6b:	c9                   	leave  
 804cd6c:	c3                   	ret    

0804cd6d <unready_thread>:
{
 804cd6d:	55                   	push   %ebp
 804cd6e:	89 e5                	mov    %esp,%ebp
 804cd70:	83 ec 08             	sub    $0x8,%esp
	return (thread->base.thread_state & state) != 0U;
 804cd73:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
 804cd76:	84 d2                	test   %dl,%dl
 804cd78:	79 0b                	jns    804cd85 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804cd7a:	83 e2 7f             	and    $0x7f,%edx
 804cd7d:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cd80:	e8 ed fb ff ff       	call   804c972 <sys_dlist_remove>
	update_cache(thread == _current);
 804cd85:	39 05 28 18 05 08    	cmp    %eax,0x8051828
}
 804cd8b:	c9                   	leave  
	update_cache(thread == _current);
 804cd8c:	0f 94 c0             	sete   %al
 804cd8f:	0f b6 c0             	movzbl %al,%eax
 804cd92:	e9 58 fd ff ff       	jmp    804caef <update_cache>

0804cd97 <add_to_waitq_locked>:
{
 804cd97:	55                   	push   %ebp
 804cd98:	89 e5                	mov    %esp,%ebp
 804cd9a:	56                   	push   %esi
 804cd9b:	89 d6                	mov    %edx,%esi
 804cd9d:	53                   	push   %ebx
 804cd9e:	89 c3                	mov    %eax,%ebx
	unready_thread(thread);
 804cda0:	e8 c8 ff ff ff       	call   804cd6d <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
 804cda5:	80 4b 0d 02          	orb    $0x2,0xd(%ebx)
	if (wait_q != NULL) {
 804cda9:	85 f6                	test   %esi,%esi
 804cdab:	74 44                	je     804cdf1 <add_to_waitq_locked+0x5a>
		thread->base.pended_on = wait_q;
 804cdad:	89 73 08             	mov    %esi,0x8(%ebx)
	return list->head == list;
 804cdb0:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cdb2:	85 c0                	test   %eax,%eax
 804cdb4:	74 2e                	je     804cde4 <add_to_waitq_locked+0x4d>
 804cdb6:	39 c6                	cmp    %eax,%esi
 804cdb8:	74 2a                	je     804cde4 <add_to_waitq_locked+0x4d>
	int32_t b1 = thread_1->base.prio;
 804cdba:	0f be 53 0e          	movsbl 0xe(%ebx),%edx
	int32_t b2 = thread_2->base.prio;
 804cdbe:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
	if (b1 != b2) {
 804cdc2:	39 ca                	cmp    %ecx,%edx
 804cdc4:	74 13                	je     804cdd9 <add_to_waitq_locked+0x42>
		if (z_sched_prio_cmp(thread, t) > 0) {
 804cdc6:	39 d1                	cmp    %edx,%ecx
 804cdc8:	7e 0f                	jle    804cdd9 <add_to_waitq_locked+0x42>
	sys_dnode_t *const prev = successor->prev;
 804cdca:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
 804cdcd:	89 03                	mov    %eax,(%ebx)
	node->prev = prev;
 804cdcf:	89 53 04             	mov    %edx,0x4(%ebx)
	prev->next = node;
 804cdd2:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
 804cdd4:	89 58 04             	mov    %ebx,0x4(%eax)
}
 804cdd7:	eb 18                	jmp    804cdf1 <add_to_waitq_locked+0x5a>
	return (node == list->tail) ? NULL : node->next;
 804cdd9:	3b 46 04             	cmp    0x4(%esi),%eax
 804cddc:	74 06                	je     804cde4 <add_to_waitq_locked+0x4d>
 804cdde:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cde0:	85 c0                	test   %eax,%eax
 804cde2:	75 da                	jne    804cdbe <add_to_waitq_locked+0x27>
	sys_dnode_t *const tail = list->tail;
 804cde4:	8b 46 04             	mov    0x4(%esi),%eax
	node->next = list;
 804cde7:	89 33                	mov    %esi,(%ebx)
	node->prev = tail;
 804cde9:	89 43 04             	mov    %eax,0x4(%ebx)
	tail->next = node;
 804cdec:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 804cdee:	89 5e 04             	mov    %ebx,0x4(%esi)
}
 804cdf1:	5b                   	pop    %ebx
 804cdf2:	5e                   	pop    %esi
 804cdf3:	5d                   	pop    %ebp
 804cdf4:	c3                   	ret    

0804cdf5 <pend_locked>:
{
 804cdf5:	55                   	push   %ebp
 804cdf6:	89 e5                	mov    %esp,%ebp
 804cdf8:	57                   	push   %edi
 804cdf9:	56                   	push   %esi
 804cdfa:	53                   	push   %ebx
 804cdfb:	89 c3                	mov    %eax,%ebx
 804cdfd:	83 ec 0c             	sub    $0xc,%esp
 804ce00:	8b 75 0c             	mov    0xc(%ebp),%esi
 804ce03:	8b 7d 08             	mov    0x8(%ebp),%edi
	add_to_waitq_locked(thread, wait_q);
 804ce06:	e8 8c ff ff ff       	call   804cd97 <add_to_waitq_locked>
	add_thread_timeout(thread, timeout);
 804ce0b:	89 f0                	mov    %esi,%eax
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804ce0d:	46                   	inc    %esi
 804ce0e:	89 fa                	mov    %edi,%edx
 804ce10:	75 05                	jne    804ce17 <pend_locked+0x22>
 804ce12:	83 ff ff             	cmp    $0xffffffff,%edi
 804ce15:	74 13                	je     804ce2a <pend_locked+0x35>
 804ce17:	83 c3 18             	add    $0x18,%ebx
 804ce1a:	50                   	push   %eax
 804ce1b:	52                   	push   %edx
 804ce1c:	68 54 cd 04 08       	push   $0x804cd54
 804ce21:	53                   	push   %ebx
 804ce22:	e8 52 04 00 00       	call   804d279 <z_add_timeout>
 804ce27:	83 c4 10             	add    $0x10,%esp
}
 804ce2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ce2d:	5b                   	pop    %ebx
 804ce2e:	5e                   	pop    %esi
 804ce2f:	5f                   	pop    %edi
 804ce30:	5d                   	pop    %ebp
 804ce31:	c3                   	ret    

0804ce32 <z_pend_curr>:
{
 804ce32:	55                   	push   %ebp
 804ce33:	89 e5                	mov    %esp,%ebp
 804ce35:	57                   	push   %edi
 804ce36:	56                   	push   %esi
 804ce37:	53                   	push   %ebx
 804ce38:	83 ec 1c             	sub    $0x1c,%esp
 804ce3b:	8b 55 10             	mov    0x10(%ebp),%edx
 804ce3e:	8b 75 14             	mov    0x14(%ebp),%esi
 804ce41:	8b 7d 18             	mov    0x18(%ebp),%edi
 804ce44:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 804ce47:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	return posix_irq_lock();
 804ce4a:	e8 10 e6 ff ff       	call   804b45f <posix_irq_lock>
	pend_locked(_current, wait_q, timeout);
 804ce4f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ce52:	50                   	push   %eax
 804ce53:	50                   	push   %eax
 804ce54:	a1 28 18 05 08       	mov    0x8051828,%eax
 804ce59:	57                   	push   %edi
 804ce5a:	56                   	push   %esi
 804ce5b:	e8 95 ff ff ff       	call   804cdf5 <pend_locked>
 804ce60:	89 5d 08             	mov    %ebx,0x8(%ebp)
 804ce63:	83 c4 10             	add    $0x10,%esp
}
 804ce66:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ce69:	5b                   	pop    %ebx
 804ce6a:	5e                   	pop    %esi
 804ce6b:	5f                   	pop    %edi
 804ce6c:	5d                   	pop    %ebp
 804ce6d:	e9 17 d9 ff ff       	jmp    804a789 <arch_swap>

0804ce72 <z_impl_k_thread_suspend>:
{
 804ce72:	55                   	push   %ebp
 804ce73:	89 e5                	mov    %esp,%ebp
 804ce75:	56                   	push   %esi
 804ce76:	53                   	push   %ebx
 804ce77:	8b 5d 08             	mov    0x8(%ebp),%ebx
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 804ce7a:	8d 43 18             	lea    0x18(%ebx),%eax
 804ce7d:	83 ec 0c             	sub    $0xc,%esp
 804ce80:	50                   	push   %eax
 804ce81:	e8 32 05 00 00       	call   804d3b8 <z_abort_timeout>
 804ce86:	83 c4 10             	add    $0x10,%esp
 804ce89:	e8 d1 e5 ff ff       	call   804b45f <posix_irq_lock>
 804ce8e:	89 c6                	mov    %eax,%esi
	return (thread->base.thread_state & state) != 0U;
 804ce90:	8a 43 0d             	mov    0xd(%ebx),%al
		if (z_is_thread_queued(thread)) {
 804ce93:	84 c0                	test   %al,%al
 804ce95:	79 0d                	jns    804cea4 <z_impl_k_thread_suspend+0x32>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804ce97:	83 e0 7f             	and    $0x7f,%eax
 804ce9a:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804ce9d:	89 d8                	mov    %ebx,%eax
 804ce9f:	e8 ce fa ff ff       	call   804c972 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
 804cea4:	80 4b 0d 10          	orb    $0x10,0xd(%ebx)
		update_cache(thread == _current);
 804cea8:	31 c0                	xor    %eax,%eax
 804ceaa:	39 1d 28 18 05 08    	cmp    %ebx,0x8051828
 804ceb0:	0f 94 c0             	sete   %al
 804ceb3:	e8 37 fc ff ff       	call   804caef <update_cache>
	posix_irq_unlock(key);
 804ceb8:	83 ec 0c             	sub    $0xc,%esp
 804cebb:	56                   	push   %esi
 804cebc:	e8 b0 e5 ff ff       	call   804b471 <posix_irq_unlock>
 804cec1:	83 c4 10             	add    $0x10,%esp
	if (thread == _current) {
 804cec4:	39 1d 28 18 05 08    	cmp    %ebx,0x8051828
 804ceca:	75 0b                	jne    804ced7 <z_impl_k_thread_suspend+0x65>
}
 804cecc:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cecf:	5b                   	pop    %ebx
 804ced0:	5e                   	pop    %esi
 804ced1:	5d                   	pop    %ebp
		z_reschedule_unlocked();
 804ced2:	e9 c9 fb ff ff       	jmp    804caa0 <z_reschedule_unlocked>
}
 804ced7:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ceda:	5b                   	pop    %ebx
 804cedb:	5e                   	pop    %esi
 804cedc:	5d                   	pop    %ebp
 804cedd:	c3                   	ret    

0804cede <k_sched_unlock>:
{
 804cede:	55                   	push   %ebp
 804cedf:	89 e5                	mov    %esp,%ebp
 804cee1:	53                   	push   %ebx
 804cee2:	50                   	push   %eax
	return posix_irq_lock();
 804cee3:	e8 77 e5 ff ff       	call   804b45f <posix_irq_lock>
 804cee8:	89 c3                	mov    %eax,%ebx
		++_current->base.sched_locked;
 804ceea:	a1 28 18 05 08       	mov    0x8051828,%eax
 804ceef:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
 804cef2:	31 c0                	xor    %eax,%eax
 804cef4:	e8 f6 fb ff ff       	call   804caef <update_cache>
	posix_irq_unlock(key);
 804cef9:	83 ec 0c             	sub    $0xc,%esp
 804cefc:	53                   	push   %ebx
 804cefd:	e8 6f e5 ff ff       	call   804b471 <posix_irq_unlock>
}
 804cf02:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804cf05:	83 c4 10             	add    $0x10,%esp
 804cf08:	c9                   	leave  
	z_reschedule_unlocked();
 804cf09:	e9 92 fb ff ff       	jmp    804caa0 <z_reschedule_unlocked>

0804cf0e <z_unpend_first_thread>:
{
 804cf0e:	55                   	push   %ebp
 804cf0f:	89 e5                	mov    %esp,%ebp
 804cf11:	56                   	push   %esi
 804cf12:	53                   	push   %ebx
	return posix_irq_lock();
 804cf13:	e8 47 e5 ff ff       	call   804b45f <posix_irq_lock>
		thread = _priq_wait_best(&wait_q->waitq);
 804cf18:	83 ec 0c             	sub    $0xc,%esp
 804cf1b:	ff 75 08             	push   0x8(%ebp)
 804cf1e:	89 c6                	mov    %eax,%esi
 804cf20:	e8 b6 fb ff ff       	call   804cadb <z_priq_dumb_best>
 804cf25:	83 c4 10             	add    $0x10,%esp
 804cf28:	89 c3                	mov    %eax,%ebx
		if (thread != NULL) {
 804cf2a:	85 c0                	test   %eax,%eax
 804cf2c:	74 14                	je     804cf42 <z_unpend_first_thread+0x34>
			unpend_thread_no_timeout(thread);
 804cf2e:	e8 ae fa ff ff       	call   804c9e1 <unpend_thread_no_timeout>
 804cf33:	83 ec 0c             	sub    $0xc,%esp
 804cf36:	8d 40 18             	lea    0x18(%eax),%eax
 804cf39:	50                   	push   %eax
 804cf3a:	e8 79 04 00 00       	call   804d3b8 <z_abort_timeout>
 804cf3f:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804cf42:	83 ec 0c             	sub    $0xc,%esp
 804cf45:	56                   	push   %esi
 804cf46:	e8 26 e5 ff ff       	call   804b471 <posix_irq_unlock>
 804cf4b:	83 c4 10             	add    $0x10,%esp
}
 804cf4e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cf51:	89 d8                	mov    %ebx,%eax
 804cf53:	5b                   	pop    %ebx
 804cf54:	5e                   	pop    %esi
 804cf55:	5d                   	pop    %ebp
 804cf56:	c3                   	ret    

0804cf57 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
 804cf57:	c7 05 38 18 05 08 38 	movl   $0x8051838,0x8051838
 804cf5e:	18 05 08 
	list->tail = (sys_dnode_t *)list;
 804cf61:	c7 05 3c 18 05 08 38 	movl   $0x8051838,0x805183c
 804cf68:	18 05 08 
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
 804cf6b:	c3                   	ret    

0804cf6c <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
 804cf6c:	55                   	push   %ebp
 804cf6d:	89 e5                	mov    %esp,%ebp
 804cf6f:	57                   	push   %edi
 804cf70:	56                   	push   %esi
 804cf71:	53                   	push   %ebx
 804cf72:	83 ec 0c             	sub    $0xc,%esp
	return posix_irq_lock();
 804cf75:	e8 e5 e4 ff ff       	call   804b45f <posix_irq_lock>
 804cf7a:	89 c3                	mov    %eax,%ebx

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
 804cf7c:	a1 28 18 05 08       	mov    0x8051828,%eax
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804cf81:	80 60 0d 7f          	andb   $0x7f,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cf85:	e8 e8 f9 ff ff       	call   804c972 <sys_dlist_remove>
	}
	queue_thread(_current);
 804cf8a:	a1 28 18 05 08       	mov    0x8051828,%eax
	thread->base.thread_state |= _THREAD_QUEUED;
 804cf8f:	80 48 0d 80          	orb    $0x80,0xd(%eax)
	return list->head == list;
 804cf93:	8b 15 38 18 05 08    	mov    0x8051838,%edx
 804cf99:	8b 0d 3c 18 05 08    	mov    0x805183c,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cf9f:	85 d2                	test   %edx,%edx
 804cfa1:	74 31                	je     804cfd4 <z_impl_k_yield+0x68>
 804cfa3:	81 fa 38 18 05 08    	cmp    $0x8051838,%edx
 804cfa9:	74 29                	je     804cfd4 <z_impl_k_yield+0x68>
	int32_t b1 = thread_1->base.prio;
 804cfab:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
 804cfaf:	0f be 7a 0e          	movsbl 0xe(%edx),%edi
	if (b1 != b2) {
 804cfb3:	39 fe                	cmp    %edi,%esi
 804cfb5:	74 13                	je     804cfca <z_impl_k_yield+0x5e>
		if (z_sched_prio_cmp(thread, t) > 0) {
 804cfb7:	39 f7                	cmp    %esi,%edi
 804cfb9:	7e 0f                	jle    804cfca <z_impl_k_yield+0x5e>
	sys_dnode_t *const prev = successor->prev;
 804cfbb:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804cfbe:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804cfc0:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804cfc3:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804cfc5:	89 42 04             	mov    %eax,0x4(%edx)
}
 804cfc8:	eb 1a                	jmp    804cfe4 <z_impl_k_yield+0x78>
	return (node == list->tail) ? NULL : node->next;
 804cfca:	39 ca                	cmp    %ecx,%edx
 804cfcc:	74 06                	je     804cfd4 <z_impl_k_yield+0x68>
 804cfce:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cfd0:	85 d2                	test   %edx,%edx
 804cfd2:	75 db                	jne    804cfaf <z_impl_k_yield+0x43>
	node->next = list;
 804cfd4:	c7 00 38 18 05 08    	movl   $0x8051838,(%eax)
	node->prev = tail;
 804cfda:	89 48 04             	mov    %ecx,0x4(%eax)
	tail->next = node;
 804cfdd:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
 804cfdf:	a3 3c 18 05 08       	mov    %eax,0x805183c
	update_cache(1);
 804cfe4:	b8 01 00 00 00       	mov    $0x1,%eax
 804cfe9:	e8 01 fb ff ff       	call   804caef <update_cache>
 804cfee:	83 ec 0c             	sub    $0xc,%esp
 804cff1:	53                   	push   %ebx
 804cff2:	e8 92 d7 ff ff       	call   804a789 <arch_swap>
 804cff7:	83 c4 10             	add    $0x10,%esp
	z_swap(&sched_spinlock, key);
}
 804cffa:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cffd:	5b                   	pop    %ebx
 804cffe:	5e                   	pop    %esi
 804cfff:	5f                   	pop    %edi
 804d000:	5d                   	pop    %ebp
 804d001:	c3                   	ret    

0804d002 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
 804d002:	55                   	push   %ebp
 804d003:	89 e5                	mov    %esp,%ebp
 804d005:	57                   	push   %edi
 804d006:	56                   	push   %esi
 804d007:	53                   	push   %ebx
 804d008:	89 c3                	mov    %eax,%ebx
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
 804d00a:	89 d0                	mov    %edx,%eax
{
 804d00c:	83 ec 1c             	sub    $0x1c,%esp
	if (ticks == 0) {
 804d00f:	09 d8                	or     %ebx,%eax
 804d011:	75 09                	jne    804d01c <z_tick_sleep+0x1a>
	z_impl_k_yield();
 804d013:	e8 54 ff ff ff       	call   804cf6c <z_impl_k_yield>
		k_yield();
		return 0;
 804d018:	31 c0                	xor    %eax,%eax
}
 804d01a:	eb 76                	jmp    804d092 <z_tick_sleep+0x90>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
 804d01c:	83 fb fe             	cmp    $0xfffffffe,%ebx
 804d01f:	89 d0                	mov    %edx,%eax
 804d021:	89 d6                	mov    %edx,%esi
 804d023:	83 d8 ff             	sbb    $0xffffffff,%eax
 804d026:	7c 09                	jl     804d031 <z_tick_sleep+0x2f>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 804d028:	e8 01 05 00 00       	call   804d52e <sys_clock_tick_get_32>
 804d02d:	01 d8                	add    %ebx,%eax
 804d02f:	eb 07                	jmp    804d038 <z_tick_sleep+0x36>
	} else {
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 804d031:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804d036:	29 d8                	sub    %ebx,%eax
 804d038:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804d03b:	e8 1f e4 ff ff       	call   804b45f <posix_irq_lock>
 804d040:	89 c7                	mov    %eax,%edi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
 804d042:	a1 28 18 05 08       	mov    0x8051828,%eax
 804d047:	e8 21 fd ff ff       	call   804cd6d <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 804d04c:	a1 28 18 05 08       	mov    0x8051828,%eax
 804d051:	56                   	push   %esi
 804d052:	53                   	push   %ebx

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 804d053:	31 db                	xor    %ebx,%ebx
 804d055:	83 c0 18             	add    $0x18,%eax
 804d058:	68 54 cd 04 08       	push   $0x804cd54
 804d05d:	50                   	push   %eax
 804d05e:	e8 16 02 00 00       	call   804d279 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
 804d063:	a1 28 18 05 08       	mov    0x8051828,%eax
 804d068:	80 48 0d 10          	orb    $0x10,0xd(%eax)
 804d06c:	89 3c 24             	mov    %edi,(%esp)
 804d06f:	e8 15 d7 ff ff       	call   804a789 <arch_swap>
 804d074:	83 c4 10             	add    $0x10,%esp
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 804d077:	e8 b2 04 00 00       	call   804d52e <sys_clock_tick_get_32>
 804d07c:	31 d2                	xor    %edx,%edx
 804d07e:	89 c1                	mov    %eax,%ecx
 804d080:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d083:	29 c8                	sub    %ecx,%eax
 804d085:	19 da                	sbb    %ebx,%edx
	if (ticks > 0) {
 804d087:	31 c9                	xor    %ecx,%ecx
 804d089:	39 c1                	cmp    %eax,%ecx
 804d08b:	89 cf                	mov    %ecx,%edi
 804d08d:	19 d7                	sbb    %edx,%edi
		return ticks;
 804d08f:	0f 4d c1             	cmovge %ecx,%eax
	}
#endif

	return 0;
}
 804d092:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d095:	5b                   	pop    %ebx
 804d096:	5e                   	pop    %esi
 804d097:	5f                   	pop    %edi
 804d098:	5d                   	pop    %ebp
 804d099:	c3                   	ret    

0804d09a <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
 804d09a:	55                   	push   %ebp
 804d09b:	89 e5                	mov    %esp,%ebp
 804d09d:	83 ec 08             	sub    $0x8,%esp
 804d0a0:	8b 55 0c             	mov    0xc(%ebp),%edx
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804d0a3:	8b 45 08             	mov    0x8(%ebp),%eax
 804d0a6:	83 fa ff             	cmp    $0xffffffff,%edx
 804d0a9:	75 1b                	jne    804d0c6 <z_impl_k_sleep+0x2c>
 804d0ab:	83 f8 ff             	cmp    $0xffffffff,%eax
 804d0ae:	75 16                	jne    804d0c6 <z_impl_k_sleep+0x2c>
		k_thread_suspend(_current);
 804d0b0:	a1 28 18 05 08       	mov    0x8051828,%eax
	z_impl_k_thread_suspend(thread);
 804d0b5:	83 ec 0c             	sub    $0xc,%esp
 804d0b8:	50                   	push   %eax
 804d0b9:	e8 b4 fd ff ff       	call   804ce72 <z_impl_k_thread_suspend>
 804d0be:	83 c4 10             	add    $0x10,%esp

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
 804d0c1:	83 c8 ff             	or     $0xffffffff,%eax
}
 804d0c4:	eb 08                	jmp    804d0ce <z_impl_k_sleep+0x34>
	}

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
 804d0c6:	e8 37 ff ff ff       	call   804d002 <z_tick_sleep>

	int32_t ret = k_ticks_to_ms_floor64(ticks);
 804d0cb:	6b c0 0a             	imul   $0xa,%eax,%eax

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
 804d0ce:	c9                   	leave  
 804d0cf:	c3                   	ret    

0804d0d0 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 804d0d0:	a1 28 18 05 08       	mov    0x8051828,%eax
 804d0d5:	c3                   	ret    

0804d0d6 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
 804d0d6:	55                   	push   %ebp
 804d0d7:	89 e5                	mov    %esp,%ebp
 804d0d9:	57                   	push   %edi
 804d0da:	56                   	push   %esi
 804d0db:	53                   	push   %ebx
 804d0dc:	83 ec 0c             	sub    $0xc,%esp
 804d0df:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804d0e2:	e8 78 e3 ff ff       	call   804b45f <posix_irq_lock>
 804d0e7:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
 804d0e9:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
 804d0ed:	74 36                	je     804d125 <z_thread_abort+0x4f>
	posix_irq_unlock(key);
 804d0ef:	83 ec 0c             	sub    $0xc,%esp
 804d0f2:	50                   	push   %eax
 804d0f3:	e8 79 e3 ff ff       	call   804b471 <posix_irq_unlock>
 804d0f8:	83 c4 0c             	add    $0xc,%esp
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
 804d0fb:	68 cb 06 00 00       	push   $0x6cb
 804d100:	68 e3 ed 04 08       	push   $0x804ede3
 804d105:	68 05 ee 04 08       	push   $0x804ee05
 804d10a:	e8 be d1 ff ff       	call   804a2cd <assert_print>
 804d10f:	58                   	pop    %eax
 804d110:	5a                   	pop    %edx
 804d111:	6a 00                	push   $0x0
 804d113:	6a 04                	push   $0x4
 804d115:	e8 0d f3 ff ff       	call   804c427 <z_fatal_error>
 804d11a:	83 c4 10             	add    $0x10,%esp
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
 804d11d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d120:	5b                   	pop    %ebx
 804d121:	5e                   	pop    %esi
 804d122:	5f                   	pop    %edi
 804d123:	5d                   	pop    %ebp
 804d124:	c3                   	ret    
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 804d125:	8a 43 0d             	mov    0xd(%ebx),%al
 804d128:	a8 08                	test   $0x8,%al
 804d12a:	0f 85 96 00 00 00    	jne    804d1c6 <z_thread_abort+0xf0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804d130:	89 c2                	mov    %eax,%edx
 804d132:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
 804d135:	80 ca 08             	or     $0x8,%dl
 804d138:	78 05                	js     804d13f <z_thread_abort+0x69>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804d13a:	88 53 0d             	mov    %dl,0xd(%ebx)
 804d13d:	eb 10                	jmp    804d14f <z_thread_abort+0x79>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804d13f:	83 e0 5f             	and    $0x5f,%eax
 804d142:	83 c8 08             	or     $0x8,%eax
 804d145:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804d148:	89 d8                	mov    %ebx,%eax
 804d14a:	e8 23 f8 ff ff       	call   804c972 <sys_dlist_remove>
		if (thread->base.pended_on != NULL) {
 804d14f:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 804d153:	74 07                	je     804d15c <z_thread_abort+0x86>
			unpend_thread_no_timeout(thread);
 804d155:	89 d8                	mov    %ebx,%eax
 804d157:	e8 85 f8 ff ff       	call   804c9e1 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
 804d15c:	83 ec 0c             	sub    $0xc,%esp
 804d15f:	8d 43 18             	lea    0x18(%ebx),%eax
 804d162:	50                   	push   %eax
 804d163:	e8 50 02 00 00       	call   804d3b8 <z_abort_timeout>
 804d168:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
 804d16b:	8b 7b 3c             	mov    0x3c(%ebx),%edi
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 804d16e:	85 ff                	test   %edi,%edi
 804d170:	74 2d                	je     804d19f <z_thread_abort+0xc9>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 804d172:	8d 43 3c             	lea    0x3c(%ebx),%eax
 804d175:	39 c7                	cmp    %eax,%edi
 804d177:	74 26                	je     804d19f <z_thread_abort+0xc9>
		unpend_thread_no_timeout(thread);
 804d179:	89 f8                	mov    %edi,%eax
 804d17b:	e8 61 f8 ff ff       	call   804c9e1 <unpend_thread_no_timeout>
 804d180:	83 ec 0c             	sub    $0xc,%esp
 804d183:	8d 47 18             	lea    0x18(%edi),%eax
 804d186:	50                   	push   %eax
 804d187:	e8 2c 02 00 00       	call   804d3b8 <z_abort_timeout>
 804d18c:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%edi)
 804d193:	83 c4 10             	add    $0x10,%esp
		ready_thread(thread);
 804d196:	89 f8                	mov    %edi,%eax
 804d198:	e8 81 fa ff ff       	call   804cc1e <ready_thread>
 804d19d:	eb cc                	jmp    804d16b <z_thread_abort+0x95>
		update_cache(1);
 804d19f:	b8 01 00 00 00       	mov    $0x1,%eax
 804d1a4:	e8 46 f9 ff ff       	call   804caef <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
 804d1a9:	39 1d 28 18 05 08    	cmp    %ebx,0x8051828
 804d1af:	75 15                	jne    804d1c6 <z_thread_abort+0xf0>
 804d1b1:	83 3d 20 18 05 08 00 	cmpl   $0x0,0x8051820
 804d1b8:	75 0c                	jne    804d1c6 <z_thread_abort+0xf0>
 804d1ba:	83 ec 0c             	sub    $0xc,%esp
 804d1bd:	56                   	push   %esi
 804d1be:	e8 c6 d5 ff ff       	call   804a789 <arch_swap>
 804d1c3:	83 c4 10             	add    $0x10,%esp
 804d1c6:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804d1c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d1cc:	5b                   	pop    %ebx
 804d1cd:	5e                   	pop    %esi
 804d1ce:	5f                   	pop    %edi
 804d1cf:	5d                   	pop    %ebp
 804d1d0:	e9 9c e2 ff ff       	jmp    804b471 <posix_irq_unlock>

0804d1d5 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 804d1d5:	83 3d 6c 19 05 08 00 	cmpl   $0x0,0x805196c
 804d1dc:	75 05                	jne    804d1e3 <elapsed+0xe>
 804d1de:	e9 07 f2 ff ff       	jmp    804c3ea <sys_clock_elapsed>
}
 804d1e3:	31 c0                	xor    %eax,%eax
 804d1e5:	c3                   	ret    

0804d1e6 <next_timeout>:

static int32_t next_timeout(void)
{
 804d1e6:	55                   	push   %ebp
 804d1e7:	89 e5                	mov    %esp,%ebp
 804d1e9:	53                   	push   %ebx
 804d1ea:	51                   	push   %ecx
 804d1eb:	8b 1d d0 11 05 08    	mov    0x80511d0,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804d1f1:	81 fb d0 11 05 08    	cmp    $0x80511d0,%ebx
 804d1f7:	75 02                	jne    804d1fb <next_timeout+0x15>
 804d1f9:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 804d1fb:	e8 d5 ff ff ff       	call   804d1d5 <elapsed>
 804d200:	89 c2                	mov    %eax,%edx
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
 804d202:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804d207:	85 db                	test   %ebx,%ebx
 804d209:	74 2e                	je     804d239 <next_timeout+0x53>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804d20b:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 804d20e:	89 d0                	mov    %edx,%eax
 804d210:	8b 5b 10             	mov    0x10(%ebx),%ebx
 804d213:	99                   	cltd   
 804d214:	29 c1                	sub    %eax,%ecx
	if ((to == NULL) ||
 804d216:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804d21b:	19 d3                	sbb    %edx,%ebx
	if ((to == NULL) ||
 804d21d:	39 c8                	cmp    %ecx,%eax
 804d21f:	b8 00 00 00 00       	mov    $0x0,%eax
 804d224:	19 d8                	sbb    %ebx,%eax
		ret = MAX_WAIT;
 804d226:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804d22b:	7c 0c                	jl     804d239 <next_timeout+0x53>
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
 804d22d:	31 c0                	xor    %eax,%eax
 804d22f:	89 da                	mov    %ebx,%edx
 804d231:	39 c1                	cmp    %eax,%ecx
 804d233:	83 da 00             	sbb    $0x0,%edx
 804d236:	0f 4d c1             	cmovge %ecx,%eax
	}

	return ret;
}
 804d239:	5a                   	pop    %edx
 804d23a:	5b                   	pop    %ebx
 804d23b:	5d                   	pop    %ebp
 804d23c:	c3                   	ret    

0804d23d <remove_timeout>:
{
 804d23d:	55                   	push   %ebp
 804d23e:	89 e5                	mov    %esp,%ebp
 804d240:	53                   	push   %ebx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 804d241:	85 c0                	test   %eax,%eax
 804d243:	74 1a                	je     804d25f <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 804d245:	3b 05 d4 11 05 08    	cmp    0x80511d4,%eax
 804d24b:	74 12                	je     804d25f <remove_timeout+0x22>
 804d24d:	8b 10                	mov    (%eax),%edx
	if (next(t) != NULL) {
 804d24f:	85 d2                	test   %edx,%edx
 804d251:	74 0c                	je     804d25f <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 804d253:	8b 48 0c             	mov    0xc(%eax),%ecx
 804d256:	8b 58 10             	mov    0x10(%eax),%ebx
 804d259:	01 4a 0c             	add    %ecx,0xc(%edx)
 804d25c:	11 5a 10             	adc    %ebx,0x10(%edx)
	sys_dnode_t *const prev = node->prev;
 804d25f:	8b 48 04             	mov    0x4(%eax),%ecx
	sys_dnode_t *const next = node->next;
 804d262:	8b 10                	mov    (%eax),%edx
	prev->next = next;
 804d264:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 804d266:	89 4a 04             	mov    %ecx,0x4(%edx)
}
 804d269:	5b                   	pop    %ebx
	node->next = NULL;
 804d26a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804d270:	5d                   	pop    %ebp
	node->prev = NULL;
 804d271:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 804d278:	c3                   	ret    

0804d279 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
 804d279:	55                   	push   %ebp
 804d27a:	89 e5                	mov    %esp,%ebp
 804d27c:	57                   	push   %edi
 804d27d:	56                   	push   %esi
 804d27e:	53                   	push   %ebx
 804d27f:	83 ec 1c             	sub    $0x1c,%esp
 804d282:	8b 7d 14             	mov    0x14(%ebp),%edi
 804d285:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804d288:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d28b:	8b 75 10             	mov    0x10(%ebp),%esi
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804d28e:	83 ff ff             	cmp    $0xffffffff,%edi
 804d291:	75 09                	jne    804d29c <z_add_timeout+0x23>
 804d293:	83 fe ff             	cmp    $0xffffffff,%esi
 804d296:	0f 84 14 01 00 00    	je     804d3b0 <z_add_timeout+0x137>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
 804d29c:	89 43 08             	mov    %eax,0x8(%ebx)
	return posix_irq_lock();
 804d29f:	e8 bb e1 ff ff       	call   804b45f <posix_irq_lock>
 804d2a4:	89 45 dc             	mov    %eax,-0x24(%ebp)

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 804d2a7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804d2ac:	39 f0                	cmp    %esi,%eax
 804d2ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804d2b3:	19 f8                	sbb    %edi,%eax
 804d2b5:	7c 2d                	jl     804d2e4 <z_add_timeout+0x6b>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804d2b7:	83 ca ff             	or     $0xffffffff,%edx
 804d2ba:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804d2bf:	2b 05 d8 18 05 08    	sub    0x80518d8,%eax
 804d2c5:	1b 15 dc 18 05 08    	sbb    0x80518dc,%edx
 804d2cb:	29 f0                	sub    %esi,%eax

			to->dticks = MAX(1, ticks);
 804d2cd:	be 01 00 00 00       	mov    $0x1,%esi
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804d2d2:	19 fa                	sbb    %edi,%edx
			to->dticks = MAX(1, ticks);
 804d2d4:	31 c9                	xor    %ecx,%ecx
 804d2d6:	39 f0                	cmp    %esi,%eax
 804d2d8:	89 d7                	mov    %edx,%edi
 804d2da:	19 cf                	sbb    %ecx,%edi
 804d2dc:	0f 4c c6             	cmovl  %esi,%eax
 804d2df:	0f 4c d1             	cmovl  %ecx,%edx
 804d2e2:	eb 10                	jmp    804d2f4 <z_add_timeout+0x7b>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
 804d2e4:	e8 ec fe ff ff       	call   804d1d5 <elapsed>
 804d2e9:	83 c6 01             	add    $0x1,%esi
 804d2ec:	83 d7 00             	adc    $0x0,%edi
 804d2ef:	99                   	cltd   
 804d2f0:	01 f0                	add    %esi,%eax
 804d2f2:	11 fa                	adc    %edi,%edx
			to->dticks = MAX(1, ticks);
 804d2f4:	89 43 0c             	mov    %eax,0xc(%ebx)
	return list->head == list;
 804d2f7:	a1 d0 11 05 08       	mov    0x80511d0,%eax
 804d2fc:	89 53 10             	mov    %edx,0x10(%ebx)
 804d2ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	sys_dnode_t *const tail = list->tail;
 804d302:	a1 d4 11 05 08       	mov    0x80511d4,%eax
 804d307:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804d30a:	81 7d e4 d0 11 05 08 	cmpl   $0x80511d0,-0x1c(%ebp)
 804d311:	74 55                	je     804d368 <z_add_timeout+0xef>
		}

		for (t = first(); t != NULL; t = next(t)) {
 804d313:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804d317:	74 4f                	je     804d368 <z_add_timeout+0xef>
			if (t->dticks > to->dticks) {
 804d319:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d31c:	8b 53 10             	mov    0x10(%ebx),%edx
 804d31f:	8b 70 0c             	mov    0xc(%eax),%esi
 804d322:	8b 78 10             	mov    0x10(%eax),%edi
 804d325:	89 d1                	mov    %edx,%ecx
 804d327:	8b 43 0c             	mov    0xc(%ebx),%eax
 804d32a:	39 f0                	cmp    %esi,%eax
 804d32c:	19 f9                	sbb    %edi,%ecx
 804d32e:	7d 1f                	jge    804d34f <z_add_timeout+0xd6>
				t->dticks -= to->dticks;
 804d330:	29 c6                	sub    %eax,%esi
 804d332:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d335:	19 d7                	sbb    %edx,%edi
	node->next = successor;
 804d337:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804d33a:	89 70 0c             	mov    %esi,0xc(%eax)
 804d33d:	89 78 10             	mov    %edi,0x10(%eax)
	sys_dnode_t *const prev = successor->prev;
 804d340:	8b 40 04             	mov    0x4(%eax),%eax
	node->next = successor;
 804d343:	89 13                	mov    %edx,(%ebx)
	node->prev = prev;
 804d345:	89 43 04             	mov    %eax,0x4(%ebx)
	prev->next = node;
 804d348:	89 18                	mov    %ebx,(%eax)
	successor->prev = node;
 804d34a:	89 5a 04             	mov    %ebx,0x4(%edx)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
 804d34d:	eb 2d                	jmp    804d37c <z_add_timeout+0x103>
			to->dticks -= t->dticks;
 804d34f:	29 f0                	sub    %esi,%eax
 804d351:	19 fa                	sbb    %edi,%edx
 804d353:	89 43 0c             	mov    %eax,0xc(%ebx)
 804d356:	89 53 10             	mov    %edx,0x10(%ebx)
	return (node == list->tail) ? NULL : node->next;
 804d359:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804d35c:	39 55 e0             	cmp    %edx,-0x20(%ebp)
 804d35f:	74 07                	je     804d368 <z_add_timeout+0xef>
 804d361:	8b 02                	mov    (%edx),%eax
 804d363:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804d366:	eb ab                	jmp    804d313 <z_add_timeout+0x9a>
	node->prev = tail;
 804d368:	8b 45 e0             	mov    -0x20(%ebp),%eax
	node->next = list;
 804d36b:	c7 03 d0 11 05 08    	movl   $0x80511d0,(%ebx)
	node->prev = tail;
 804d371:	89 43 04             	mov    %eax,0x4(%ebx)
	tail->next = node;
 804d374:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 804d376:	89 1d d4 11 05 08    	mov    %ebx,0x80511d4
	return list->head == list;
 804d37c:	a1 d0 11 05 08       	mov    0x80511d0,%eax
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 804d381:	3d d0 11 05 08       	cmp    $0x80511d0,%eax
 804d386:	74 16                	je     804d39e <z_add_timeout+0x125>
 804d388:	39 c3                	cmp    %eax,%ebx
 804d38a:	75 12                	jne    804d39e <z_add_timeout+0x125>
			sys_clock_set_timeout(next_timeout(), false);
 804d38c:	e8 55 fe ff ff       	call   804d1e6 <next_timeout>
 804d391:	52                   	push   %edx
 804d392:	52                   	push   %edx
 804d393:	6a 00                	push   $0x0
 804d395:	50                   	push   %eax
 804d396:	e8 24 f0 ff ff       	call   804c3bf <sys_clock_set_timeout>
 804d39b:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804d39e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804d3a1:	89 45 08             	mov    %eax,0x8(%ebp)
		}
	}
}
 804d3a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d3a7:	5b                   	pop    %ebx
 804d3a8:	5e                   	pop    %esi
 804d3a9:	5f                   	pop    %edi
 804d3aa:	5d                   	pop    %ebp
 804d3ab:	e9 c1 e0 ff ff       	jmp    804b471 <posix_irq_unlock>
 804d3b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d3b3:	5b                   	pop    %ebx
 804d3b4:	5e                   	pop    %esi
 804d3b5:	5f                   	pop    %edi
 804d3b6:	5d                   	pop    %ebp
 804d3b7:	c3                   	ret    

0804d3b8 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
 804d3b8:	55                   	push   %ebp
 804d3b9:	89 e5                	mov    %esp,%ebp
 804d3bb:	53                   	push   %ebx
 804d3bc:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 804d3bf:	e8 9b e0 ff ff       	call   804b45f <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
 804d3c4:	8b 55 08             	mov    0x8(%ebp),%edx
 804d3c7:	89 c3                	mov    %eax,%ebx
	return node->next != NULL;
 804d3c9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 804d3ce:	83 3a 00             	cmpl   $0x0,(%edx)
 804d3d1:	74 09                	je     804d3dc <z_abort_timeout+0x24>
			remove_timeout(to);
 804d3d3:	89 d0                	mov    %edx,%eax
 804d3d5:	e8 63 fe ff ff       	call   804d23d <remove_timeout>
			ret = 0;
 804d3da:	31 c0                	xor    %eax,%eax
	posix_irq_unlock(key);
 804d3dc:	83 ec 0c             	sub    $0xc,%esp
 804d3df:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804d3e2:	53                   	push   %ebx
 804d3e3:	e8 89 e0 ff ff       	call   804b471 <posix_irq_unlock>
		}
	}

	return ret;
}
 804d3e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d3eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804d3ee:	83 c4 10             	add    $0x10,%esp
 804d3f1:	c9                   	leave  
 804d3f2:	c3                   	ret    

0804d3f3 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
 804d3f3:	55                   	push   %ebp
 804d3f4:	89 e5                	mov    %esp,%ebp
 804d3f6:	57                   	push   %edi
 804d3f7:	56                   	push   %esi
 804d3f8:	53                   	push   %ebx
 804d3f9:	83 ec 1c             	sub    $0x1c,%esp
 804d3fc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 804d3ff:	e8 5b e0 ff ff       	call   804b45f <posix_irq_lock>
 804d404:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 804d407:	89 1d 6c 19 05 08    	mov    %ebx,0x805196c
	return list->head == list;
 804d40d:	8b 1d d0 11 05 08    	mov    0x80511d0,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804d413:	81 fb d0 11 05 08    	cmp    $0x80511d0,%ebx
 804d419:	0f 84 8f 00 00 00    	je     804d4ae <sys_clock_announce+0xbb>
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
 804d41f:	a1 d8 18 05 08       	mov    0x80518d8,%eax
 804d424:	8b 15 dc 18 05 08    	mov    0x80518dc,%edx
 804d42a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	     (t != NULL) && (t->dticks <= announce_remaining);
 804d42d:	a1 6c 19 05 08       	mov    0x805196c,%eax
		curr_tick += dt;
 804d432:	89 55 dc             	mov    %edx,-0x24(%ebp)
	     (t != NULL) && (t->dticks <= announce_remaining);
 804d435:	85 db                	test   %ebx,%ebx
 804d437:	74 75                	je     804d4ae <sys_clock_announce+0xbb>
 804d439:	89 c7                	mov    %eax,%edi
 804d43b:	8b 53 0c             	mov    0xc(%ebx),%edx
 804d43e:	8b 4b 10             	mov    0x10(%ebx),%ecx
 804d441:	89 c6                	mov    %eax,%esi
 804d443:	c1 ff 1f             	sar    $0x1f,%edi
 804d446:	39 d0                	cmp    %edx,%eax
 804d448:	89 f8                	mov    %edi,%eax
 804d44a:	19 c8                	sbb    %ecx,%eax
 804d44c:	7c 52                	jl     804d4a0 <sys_clock_announce+0xad>
		curr_tick += dt;
 804d44e:	89 d0                	mov    %edx,%eax
		t->dticks = 0;
 804d450:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		int dt = t->dticks;
 804d457:	89 d6                	mov    %edx,%esi
		t->dticks = 0;
 804d459:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		curr_tick += dt;
 804d460:	99                   	cltd   
 804d461:	03 45 d8             	add    -0x28(%ebp),%eax
 804d464:	a3 d8 18 05 08       	mov    %eax,0x80518d8
 804d469:	13 55 dc             	adc    -0x24(%ebp),%edx
		remove_timeout(t);
 804d46c:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
 804d46e:	89 15 dc 18 05 08    	mov    %edx,0x80518dc
		remove_timeout(t);
 804d474:	e8 c4 fd ff ff       	call   804d23d <remove_timeout>
	posix_irq_unlock(key);
 804d479:	83 ec 0c             	sub    $0xc,%esp
 804d47c:	ff 75 e4             	push   -0x1c(%ebp)
 804d47f:	e8 ed df ff ff       	call   804b471 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
 804d484:	89 1c 24             	mov    %ebx,(%esp)
 804d487:	ff 53 08             	call   *0x8(%ebx)
 804d48a:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 804d48d:	e8 cd df ff ff       	call   804b45f <posix_irq_lock>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
 804d492:	29 35 6c 19 05 08    	sub    %esi,0x805196c
 804d498:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804d49b:	e9 6d ff ff ff       	jmp    804d40d <sys_clock_announce+0x1a>
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
 804d4a0:	89 d0                	mov    %edx,%eax
 804d4a2:	89 ca                	mov    %ecx,%edx
 804d4a4:	29 f0                	sub    %esi,%eax
 804d4a6:	19 fa                	sbb    %edi,%edx
 804d4a8:	89 43 0c             	mov    %eax,0xc(%ebx)
 804d4ab:	89 53 10             	mov    %edx,0x10(%ebx)
	}

	curr_tick += announce_remaining;
 804d4ae:	a1 6c 19 05 08       	mov    0x805196c,%eax
	announce_remaining = 0;
 804d4b3:	c7 05 6c 19 05 08 00 	movl   $0x0,0x805196c
 804d4ba:	00 00 00 
	curr_tick += announce_remaining;
 804d4bd:	99                   	cltd   
 804d4be:	01 05 d8 18 05 08    	add    %eax,0x80518d8
 804d4c4:	11 15 dc 18 05 08    	adc    %edx,0x80518dc

	sys_clock_set_timeout(next_timeout(), false);
 804d4ca:	e8 17 fd ff ff       	call   804d1e6 <next_timeout>
 804d4cf:	52                   	push   %edx
 804d4d0:	52                   	push   %edx
 804d4d1:	6a 00                	push   $0x0
 804d4d3:	50                   	push   %eax
 804d4d4:	e8 e6 ee ff ff       	call   804c3bf <sys_clock_set_timeout>
 804d4d9:	59                   	pop    %ecx
	posix_irq_unlock(key);
 804d4da:	ff 75 e4             	push   -0x1c(%ebp)
 804d4dd:	e8 8f df ff ff       	call   804b471 <posix_irq_unlock>
 804d4e2:	83 c4 10             	add    $0x10,%esp
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
 804d4e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d4e8:	5b                   	pop    %ebx
 804d4e9:	5e                   	pop    %esi
 804d4ea:	5f                   	pop    %edi
 804d4eb:	5d                   	pop    %ebp
	z_time_slice();
 804d4ec:	e9 d4 f6 ff ff       	jmp    804cbc5 <z_time_slice>

0804d4f1 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
 804d4f1:	55                   	push   %ebp
 804d4f2:	89 e5                	mov    %esp,%ebp
 804d4f4:	57                   	push   %edi
 804d4f5:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 804d4f8:	e8 62 df ff ff       	call   804b45f <posix_irq_lock>
 804d4fd:	89 c7                	mov    %eax,%edi
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
 804d4ff:	e8 d1 fc ff ff       	call   804d1d5 <elapsed>
 804d504:	99                   	cltd   
 804d505:	03 05 d8 18 05 08    	add    0x80518d8,%eax
 804d50b:	13 15 dc 18 05 08    	adc    0x80518dc,%edx
	posix_irq_unlock(key);
 804d511:	83 ec 0c             	sub    $0xc,%esp
 804d514:	57                   	push   %edi
 804d515:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804d518:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804d51b:	e8 51 df ff ff       	call   804b471 <posix_irq_unlock>
	}
	return t;
}
 804d520:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d523:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804d526:	83 c4 10             	add    $0x10,%esp
 804d529:	8b 7d fc             	mov    -0x4(%ebp),%edi
 804d52c:	c9                   	leave  
 804d52d:	c3                   	ret    

0804d52e <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
 804d52e:	55                   	push   %ebp
 804d52f:	89 e5                	mov    %esp,%ebp
 804d531:	83 ec 08             	sub    $0x8,%esp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
 804d534:	e8 b8 ff ff ff       	call   804d4f1 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
 804d539:	c9                   	leave  
 804d53a:	c3                   	ret    

0804d53b <_posix_zephyr_main>:
	__asm__ volatile("nop");
 804d53b:	90                   	nop
{
	/* NOP default main() if the application does not provide one. */
	arch_nop();

	return 0;
}
 804d53c:	31 c0                	xor    %eax,%eax
 804d53e:	c3                   	ret    

0804d53f <boot_banner>:
#else
#define BANNER_VERSION KERNEL_VERSION_STRING
#endif

void boot_banner(void)
{
 804d53f:	55                   	push   %ebp
 804d540:	89 e5                	mov    %esp,%ebp
 804d542:	83 ec 14             	sub    $0x14,%esp
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
 804d545:	68 0e ee 04 08       	push   $0x804ee0e
 804d54a:	e8 83 c2 ff ff       	call   80497d2 <printk>
 804d54f:	83 c4 10             	add    $0x10,%esp
#endif /* CONFIG_BOOT_BANNER */
}
 804d552:	c9                   	leave  
 804d553:	c3                   	ret    

0804d554 <z_device_state_init>:
void z_device_state_init(void)
{
	STRUCT_SECTION_FOREACH(device, dev) {
		z_object_init(dev);
	}
}
 804d554:	c3                   	ret    

0804d555 <k_heap_init>:
#include <zephyr/init.h>
#include <zephyr/linker/linker-defs.h>
#include <zephyr/sys/iterable_sections.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
 804d555:	55                   	push   %ebp
 804d556:	89 e5                	mov    %esp,%ebp
 804d558:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dlist_init(&w->waitq);
 804d55b:	8d 50 0c             	lea    0xc(%eax),%edx
	list->head = (sys_dnode_t *)list;
 804d55e:	89 50 0c             	mov    %edx,0xc(%eax)
	list->tail = (sys_dnode_t *)list;
 804d561:	89 50 10             	mov    %edx,0x10(%eax)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}
 804d564:	5d                   	pop    %ebp
	sys_heap_init(&h->heap, mem, bytes);
 804d565:	e9 60 c3 ff ff       	jmp    80498ca <sys_heap_init>

0804d56a <statics_init>:

static int statics_init(void)
{
 804d56a:	55                   	push   %ebp
 804d56b:	89 e5                	mov    %esp,%ebp
 804d56d:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(k_heap, h) {
 804d56e:	bb 5c 12 05 08       	mov    $0x805125c,%ebx
{
 804d573:	52                   	push   %edx
	STRUCT_SECTION_FOREACH(k_heap, h) {
 804d574:	81 fb 5c 12 05 08    	cmp    $0x805125c,%ebx
 804d57a:	73 15                	jae    804d591 <statics_init+0x27>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
 804d57c:	50                   	push   %eax
 804d57d:	ff 73 08             	push   0x8(%ebx)
 804d580:	ff 73 04             	push   0x4(%ebx)
 804d583:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(k_heap, h) {
 804d584:	83 c3 14             	add    $0x14,%ebx
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
 804d587:	e8 c9 ff ff ff       	call   804d555 <k_heap_init>
 804d58c:	83 c4 10             	add    $0x10,%esp
	STRUCT_SECTION_FOREACH(k_heap, h) {
 804d58f:	eb e3                	jmp    804d574 <statics_init+0xa>
		}
	}
	return 0;
}
 804d591:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804d594:	31 c0                	xor    %eax,%eax
 804d596:	c9                   	leave  
 804d597:	c3                   	ret    

Disassembly of section .fini:

0804d598 <_fini>:
 804d598:	f3 0f 1e fb          	endbr32 
 804d59c:	53                   	push   %ebx
 804d59d:	83 ec 08             	sub    $0x8,%esp
 804d5a0:	e8 4b bd ff ff       	call   80492f0 <__x86.get_pc_thunk.bx>
 804d5a5:	81 c3 9f 39 00 00    	add    $0x399f,%ebx
 804d5ab:	83 c4 08             	add    $0x8,%esp
 804d5ae:	5b                   	pop    %ebx
 804d5af:	c3                   	ret    
